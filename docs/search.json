[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analysing Genomic Data with dartRverse",
    "section": "",
    "text": "Welcome!\nWelcome, Trailblazers of Biodiversity, to the Second Gathering of our Population Genetics Workshop — this time under the vast skies and red dust of the Australian Outback (well… Brisbane’s subtropical edge of it)!\nWe’re excited to bring this workshop to the International Congress for Conservation Biology (ICCB) — a meeting ground where conservationists from every corner gather to share stories, science, and strategies for protecting the wild heart of our planet. While Brisbane may not boast the rustle of Kioloa’s forests, it hums with its own rhythm — a place where mangroves meet skyscrapers and river currents carry both eDNA and ideas.\nIn this workshop — a compact but powerful expedition — we’ll explore Population Genetics using R. Whether you’re a seasoned fieldworker or new to the code trail, you’re in good company. Here, every voice matters, and learning is a shared journey.\nThis is your chance to sharpen your analytical tools, exchange ideas, and delve into the genomic threads that weave through ecosystems across Australia and beyond. And yes — we’ll get our hands dirty (metaphorically… unless your dataset’s really dusty) with hands-on practice using your own data.\nSo bring your resilience, your field-hardened humour, and your willingness to wrestle a few data-wrangling goannas. Bugs in your code? Think of them as wildlife encounters. We’ll handle it all with tenacity, teamwork, and maybe a bit of data-fuelled bush magic.\nWe’re glad to have you on this journey. Let’s get started.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#program-and-speakers",
    "href": "index.html#program-and-speakers",
    "title": "Analysing Genomic Data with dartRverse",
    "section": "Program and Speakers",
    "text": "Program and Speakers\nWe hope you are ready for a jam-packed PROGRAM! And before getting started why not check out the amazing speakers we have lined up. They are all excited to share their knowledge and expertise.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#here-are-some-things-you-might-see-along-your-journey",
    "href": "index.html#here-are-some-things-you-might-see-along-your-journey",
    "title": "Analysing Genomic Data with dartRverse",
    "section": "Here are some things you might see along your journey:",
    "text": "Here are some things you might see along your journey:\nBelow is an exercise box, this is encouraging you to give it a go yourself!\n\n\n\n\n\n\nExercise\n\n\n\n Give the code a go!\n\n\nBelow is a tip box, with added insights for your journey.\n\n\n\n\n\n\nTip\n\n\n\ntake a look…\nA variety of things to learn!\n\n\nBelow is a caution box, take note, this will keep you on your path.\n\n\n\n\n\n\nCaution\n\n\n\nTake CARE! It is easy to go astray, I am here to help.\n\n\nBelow is a warning box! Be careful and take head of what it says.\n\n\n\n\n\n\nWarning\n\n\n\nNOTICE! Thank you for noticing this warning!",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#a-big-thank-you-to-the-developers",
    "href": "index.html#a-big-thank-you-to-the-developers",
    "title": "Analysing Genomic Data with dartRverse",
    "section": "A big thank you to the developers!",
    "text": "A big thank you to the developers!\nDartR published first by Gruber et al. (2018), and DartR V2 published by Mijangos et al. (2022)\n\n\n\n\nGruber, Bernd, Peter J. Unmack, Oliver F. Berry, and Arthur Georges. 2018. “DARTR : An R Package to Facilitate Analysis of SNP Data Generated from Reduced Representation Genome Sequencing.” Molecular Ecology Resources 18 (3): 691–99. https://doi.org/10.1111/1755-0998.12745.\n\n\nMijangos, Jose Luis, Bernd Gruber, Oliver Berry, Carlo Pacioni, and Arthur Georges. 2022. “dartR V2: An Accessible Genetic Analysis Platform for Conservation, Ecology and Agriculture.” Methods in Ecology and Evolution 13 (10): 2150–58. https://doi.org/10.1111/2041-210X.13918.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Program",
    "section": "",
    "text": "#\nDay\nTime\nTopic\nPresenters\n\n\n\n\n1\nSaturday\n9 am – 11 am\nImporting and Handling Genomic Data\nArthur Georges, Diana Robledo\n\n\n2\n\n11:20 am – 12:50 pm\nEstimating Effective Population Size and Key Stats\nBernd Gruber, Luis Mijangos\n\n\n3\n\n1:30 pm – 3 pm\nIdentifying Population Structure\nLuis Mijangos, Emily Stringer\n\n\n4\n\n3:30 pm – 5 pm\nKinship, Pedigrees & Mating Recommendations\nLuis Mijangos, Bernd Gruber\n\n\n5\nSunday\n9 am – 11 am\nAssigning Individuals to Populations\nArthur Georges, Luis Mijangos, Elise Furlan\n\n\n6\n\n11:30 am – 12:30 pm\nSNP Panel Selection\nElise Furlan, Bernd Gruber, Andrzej Killian\n\n\n7\n\n1:10 pm – 2:10 pm\nSimulations for Conservation\nLuis Mijangos, Bernd Gruber\n\n\nBonus!\n\n2:10 pm – 3 pm\nSex Linked Markers\nDiana Robledo",
    "crumbs": [
      "Program"
    ]
  },
  {
    "objectID": "speakers.html",
    "href": "speakers.html",
    "title": "Speaker Bios",
    "section": "",
    "text": "Elise Furlan is a Senior Research Fellow with the eDNA Team at the University of Canberra, where she applies molecular genetic techniques to tackle a wide range of ecological questions. One of the early trailblazers in Australia’s environmental DNA (eDNA) space, Elise was among the first researchers in the country to develop methods for analysing eDNA — detecting species from the tiny traces they leave behind in the environment. Her main objective is to ensure her high quality research results in applied outcomes for conservation, therefore partnerships with government agencies and industry feature heavily in her projects. session 4 and session 6\nArthur Georges, a distinguished professor at the University of Canberra, has revolutionized the understanding of sex determination in reptiles. His major achievement? Unravelling how environmental factors influence sex in reptiles, a game-changer in herpetology and conservation genetics. Arthur’s work has far-reaching implications, from conservation strategies to understanding evolutionary processes. He’s the Dumbledore of herpetology, albeit more fascinated by dragon eggs than by magic ones, and probably wonders if he could genetically engineer a lizard to brew his morning coffee. session 1 and session 4\nBernd Gruber, from the University of Canberra, is a master at blending spatial and ecological modelling with genetics. His crowning achievement? Developing dartR, a tool that’s revolutionizing genetic data analysis in conservation projects. His approach to research is as innovative as it is impactful, making him the Houdini of ecology – he makes complex data disappear into meaningful conservation strategies. Bernd might secretly wish to decode the genetic basis for why every odd sock goes missing, solving one of life’s great mysteries.session 2, session 5, and session 6\nAndrzej Kilian, founder of DArT in 2001, has been a pioneer in genomics, creating a technology that simplifies high-throughput genotyping across various organisms. His work at DArT supports global food security, sustainable agriculture, and biodiversity, making significant strides towards understanding and improving agricultural and environmental practices. Andrzej’s commitment to science and humanity illustrates a unique blend of innovation with a purpose. Andrzej, much like a maestro in an orchestra of genomes, harmonizes the complex notes of genetics to compose a symphony for a sustainable planet, ensuring every note contributes to the grander vision of global harmony and well-being. session 4\nLuis Mijangos, at DArT, he combines his passion for technology and conservation, using genetic data analysis to protect biodiversity. His standout achievement? Applying his expertise in genetic data analysis to conservation projects, making him the tech-savvy guardian of the planet. Luis’s contributions are crucial in the fight against biodiversity loss, and he’s probably brainstorming ways to use genetic data to convince plants to grow in perfect Instagram-worthy arrangements. session 2, session 3, session 4, session 5, and session 6\nDiana Robledo-Ruiz is a name you’ll want to remember in the field of conservation biology, specifically at Monash University. She’s been making waves with her work on the Helmeted Honeyeater’s genome, leading to significant advancements in genetic rescue operations. Her high-quality genomic research is not just for the birds – it’s key to saving them from extinction and maintaining their unique identity. Diana is also the lead developer of dartR.sexlinked which will make your life easier when filtering genetic data! She is developing this and other genomic tools to keep the endangered Helmeted Honeyeater, Leadbeater’s possum and Macquarie perch buzzing in the wild. session 1 and session 3\nEmily Stringer recently completed her PhD (Whooh!) at the University of Canberra, diving deep into conservation ecology and genomics. She kicked off with a mission to save the elusive Canberra grassland earless dragon and then hopped into the world of population genetics. Her main gig? Unraveling the genetic puzzle of an Australian rodent known for its dramatic population swings. Emily’s all about cracking complex data to solve ecological mysteries, aiming to turn her findings into real-world conservation victories. session 2, session 3, and session 6. She also put this website together for you all :)",
    "crumbs": [
      "Speaker Bios"
    ]
  },
  {
    "objectID": "install.html",
    "href": "install.html",
    "title": "Install dartRverse",
    "section": "",
    "text": "Install dartRverse",
    "crumbs": [
      "Install dartRverse"
    ]
  },
  {
    "objectID": "install.html#rationale",
    "href": "install.html#rationale",
    "title": "Install dartRverse",
    "section": "Rationale",
    "text": "Rationale\nWe have developed a new suit of packages called “dartRverse” packages, that will replace the previous dartR package, which soon will be no longer supported. The new suit of packages are meant to be a 1:1 replacement and only in some instance very minor changes will be needed to update previous code. For example we reworked on the “output” of all functions, now being able to save figures in specified folders, which can be easier recovered and manipulated for further tweaking. The main reasons for splitting dartR into several packages and developing the dartRverse suit of packages was difficulty to maintain dartR, because of limits imposed by CRAN, but also limits due the the long time to test new function, when compiling the package. Therefore we were forced to split the package into several smaller packages. This has several advantages and in the best of all cases no disadvantages.\n\neasier maintenance\nfaster development\nless dependencies on other packages\neasier to become a contributor\nhave your own package developed that can be branded as part of the dartRverse\n\nThe main paradigm was also that for our users nothing (or at as little as possible) needed to change and all existing code and scripts should still work. Also the installation process was meant to be straightforward and finally the coexistance between dartR and dartRverse packages should be possible (for the interim until dartR will be no longer supported).",
    "crumbs": [
      "Install dartRverse"
    ]
  },
  {
    "objectID": "install.html#installation",
    "href": "install.html#installation",
    "title": "Install dartRverse",
    "section": "Installation",
    "text": "Installation\n\ninstall dartRverse\n\n#installs the necessary bioconductor packages\ninstall.packages(\"devtools\")\ninstall.packages(\"BiocManager\")\nBiocManager::install(\"SNPRelate\")\n\n#install dartRverse (dartRverse) & core (dartR.base, dartR.data)\ninstall.packages(\"dartRverse\")\n\nThe dartRverse package is the first package to install and its only purpose is to support the installation of the other dartRverse packages. It will also be the first port of call to provide links to tutorials and other documentation.\nIf everything works well this should install two more packages with form the core version of dartRverse, nameley dartR.base and dartR.data. Those core packages have all the main function of old dartR package that deals with input, conversion, reporting and filtering of data. Also some base function to analysse data (e.g. PCoA, Fst) are included.\nOnce the dartRverse package has been installed we can load the package to check which part of the dartRverse has been installed.\n\nlibrary(dartRverse)\n\n\n\n\n\n\n\n\ninstall additional packages\nNow we can install the additional packages that are part of the dartRverse. Depending on your needs you can install all of them or only the one you are interested.\nFor example if you are interested in additional functions to analyse population structure (e.g. run STRUCTURE or faststructure) you can install the dartR.popgen package. If you are interested in functions that support the simulation of data you can install the dartR.sim package.\nYou can check which packages are avaialbel and which of them you have installed by typing:\n\ndartRverse::dartRverse_install()\n\n\n\n\n\n\nThe currently available packages are:\n\ndartR.sim (simulate SNP data)\ndartR.popgen (run population genetic analysis)\ndartR.spatial (run landscape genetic analysis)\ndartR.captive (estimate relatedness, support captive breeding)\ndartR.sexlinked (identify sexlinked markers, not ready yet)\n\nSo to install the dartR.sim simply type:\n\ninstall.packages(\"dartR.sim\")\ninstall.packages(\"dartR.popgen\")\ninstall.packages(\"dartR.spatial\")\ninstall.packages(\"dartR.captive\")\n# currently dartR.sexlinked requires a different installation process (see below)\n\n\n\nGithub repositories\nWe make all of our packages available via CRAN. The reason for this is that CRAN packages follow a stringent testing before they are allowed to be uploaded to CRAN and therefore are more likely to contain less errors then packages that are available on other repositories. Nevertheless we also make our packages available during development via github.\nYou can find the repositories under: https://github.com/green-striped-gecko/dartR.base [for the dartR.base package] and equivalent for the other packages.\nThe reason why you might want to install a package from github is that you want to use the latest version of the package. However, you should be aware that the packages on github are not tested and therefore might contain errors. Also the packages on github might be updated on a daily basis and therefore might change without notice.\nWe use different branches and they are reflecting different stages of development and majurity.\n\nmain (the main branch, which is equivalent to the current CRAN version)\ndev (development branch, which has the latest functions that might be in the next CRAN version, but have not been tested yet)\ndev_name (these are branches of our main developers and are used for testing and development of new functions. Installing functions from here might cause problems and should only be done if you know what you are doing)\n\ndartRverse supports the installation of github version of the packages using the following syntax:\ndartRverse_install(package = \"dartR.base\", repo = \"github\", branch = \"dev\")\nThis install the dev branch of dartR.base from CRAN. All main and dev branches are tested if they can be installed (and some additional error checks via): https://github.com/green-striped-gecko/dartRverse\nPlease note that you should provide the package repository (github/cran), the branch (main, dev,dev_name) and version number in case you want to report a bug. You can use the github methods to report issues or use our google group: https://groups.google.com/d/forum/dartr.\n\n\nInstalling dartR.sexlinked\ndartRverse_install(package = \"dartR.sexlinked\", repo = \"github\", branch = \"dev\")",
    "crumbs": [
      "Install dartRverse"
    ]
  },
  {
    "objectID": "install.html#using-dartrverse",
    "href": "install.html#using-dartrverse",
    "title": "Install dartRverse",
    "section": "Using dartRverse",
    "text": "Using dartRverse\nTo use dartRverse you can simply load the package and use it as before.\n\nlibrary(dartRverse)",
    "crumbs": [
      "Install dartRverse"
    ]
  },
  {
    "objectID": "breakk.html",
    "href": "breakk.html",
    "title": "__________",
    "section": "",
    "text": "And without further ado lets get into the workshop",
    "crumbs": [
      "\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_"
    ]
  },
  {
    "objectID": "session01.html",
    "href": "session01.html",
    "title": "1  Importing and Handling Genomic Data",
    "section": "",
    "text": "Required packages\nSession Presenters\nlibrary(dartRverse)\nlibrary(dartR.sexlinked)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Importing and Handling Genomic Data</span>"
    ]
  },
  {
    "objectID": "session01.html#dartr-fundamentals",
    "href": "session01.html#dartr-fundamentals",
    "title": "1  Importing and Handling Genomic Data",
    "section": "dartR Fundamentals",
    "text": "dartR Fundamentals\nJust before you get started how about checking out some prerequisite tutorials if you are not up to date. These are the following two tutorials RStudio refresher and installing dartR.\n\n\n\n\n\n\nAlso a little reminder about dartRverse:\n\n\n\nAn accessible genetic analysis platform for conservation, ecology and agriculture\ndartRverse aims to support the installation of R packages of the dartRverse that are user-friendly and deliver a variety of analyses and pipelines on the one platform. Currently there are two core R packages that need to be installed to use dartR:\n\ndartR.base\ndartR.data\n\nAdditional packages are\n\ndartR.sim (functions to simulate SNP data)\ndartR.spatial (spatial analysis)\ndartR.popgenomics (popgenomics analysis)\ndartR.captive\ndartR.sexlinked\n\ndartR is a collaboration between the University of Canberra, CSIRO and Diversity Arrays Technology, and is supported with funding from the ACT Priority Investment Program, CSIRO and the University of Canberra.\n\n\n\nIntroduction\nSNPs, or single nucleotide polymorphisms, are single base pair mutations at a nuclear locus (Figure 2). That nuclear locus is represented in the dataset by two sequence tags which, at a heterozygous locus, take on two allelic states, one referred to as the reference state, the other as the alternate or SNP state.\n\n\n\nFigure 2. A diagram illustrating what is meant by a SNP (single point polymorphism)\n\n\nBecause it is extremely rare for a mutation to occur twice at the same site in the genome (perhaps with the exception of Eucalypts), the SNP data are considered to be effectively biallelic. Sites with more than two states that occur rarely are typically eliminated in the quality control steps as they are bundled with multiallelic sites arising from multiple copy sequences (e.g. as would arise from gene duplications) removed during preliminary filtering.\nThe data can be represented as SNP bases (A, T, C or G), with two states for each individual at each locus in a diploid organisms. Alternatively, because the data are biallelic, it is computationally convenient to code the data as 0 for homozyogotes for one allele, 1 for heterozygotes, and 2 for homozygotes of the other allele. The reference allele is arbitrarily taken to be the most common allele, so 0 is the score for homozygous reference, and 2 is the score for homozygous alternate or SNP state. NA indicates that the SNP could not be scored.\nSNP data when using dartR are held in a genlight object that is defined in R package adegenet (Jombart, 2008; Jombart and Ahmed, 2011). The locus metadata included in the genlight object are those provided as part of your Diversity Arrays Technology report. These metadata are obtained from the Diversity Arrays Technology csv file when it is read in to the genlight object. The locus metadata are held in an R data.frame that is associated with the SNP data as part of the genlight object.\nHere is an example of the data structure of a genlight object\n\n\n\n\n\nFor further details go check out the Data Structure tutorial.\n\n\nExample\nTo help us get our head around data interrogation, subsetting, and basic filtering we are going to work through a worked example using a test dataset.\n\n# dartR comes with a built in test dataset called testset.gl. \n# We first examine the contents of testset.gl\ntestset.gl\n\nHow many individuals have been genotyped? How many SNP loci have been scored? What is the percentage of missing data?\n\n\n\n\n\n\nQuiz!\n\n\n\nThis quiz is referring to the testset.gl data set you have interrogated above.\nType the correct number into the blank boxes below:\n\nnumber of SNPs \nnumber of individuals \npercent missing data \n\nboxes will go green if you have the answer correct\n\n\n\n# Next let us copy the contents of testset.gl to another genlight object called gl.\ngl &lt;- testset.gl\n# Use adegenet accessors to interrogate the genlight object further\nnInd(gl)\nnLoc(gl)\nnPop(gl)\npopNames(gl)\nindNames(gl)\nlocNames(gl)\n\nNow you have a better appreciation of the contents of genlight object gl. pop(gl) is a vector of population names against each individual. Note that it is distinguished from popNames(gl) which just lists the unique names.\n\n# So if you want to tablulate the number of individuals in each population, use\ntable(pop(gl))\n\n\n   EmmacBrisWive    EmmacBurdMist    EmmacBurnBara    EmmacClarJack \n              10               10               11                5 \n   EmmacClarYate    EmmacCoopAvin   EmmacCoopCully    EmmacCoopEulb \n               5               10               10               10 \n  EmmacFitzAllig    EmmacJohnWari    EmmacMaclGeor    EmmacMaryBoru \n              10               10               11                6 \n   EmmacMaryPetr     EmmacMDBBowm     EmmacMDBCond     EmmacMDBCudg \n               4               10               10               10 \n    EmmacMDBForb     EmmacMDBGwyd     EmmacMDBMaci EmmacMDBMurrMung \n              11                9               10               10 \n    EmmacMDBSanf    EmmacNormJack    EmmacNormLeic    EmmacNormSalt \n              10                6                1                1 \n   EmmacRichCasi        EmmacRoss    EmmacRussEube     EmmacTweeUki \n              10               10               10               10 \n   EmsubRopeMata    EmvicVictJasp \n               5                5 \n\n\nWe have learned that typing the name of the genlight object gives its attributes. How do we examine the genotypes in a genlight object. This is done by converting it to a matrix.\n\nas.matrix(gl)[1:7,1:5]\n\nWhat do you see. Is it what you expected for the coding of the SNP scores?\nLets start again.\n\n# Copy the original testset.gl\ngl &lt;- testset.gl\n# Set the global verbosity to 3 – this will result in some detailed comments as you run each # script\ngl.set.verbosity(3)\n# Now lets use a report function to report the call rate for genlight object gl\ngl.report.callrate(gl)\n\n\n\n\n\n\n\nTip\n\n\n\nNote that the call rate is reported against locus. This is the default. Both a tabulated result and a graph is produced. You can use both to determine a suitable threshold for filtering on callrate.\nWhat threshold do you think might be appropriate?\n\n\nNow let’s report the call rate for genlight object gl by individual.\n\ngl.report.callrate(gl,method=\"ind\")\n\nCan you see the difference. Again, both a tabulated result and a graph is produced. You can use both to determine a suitable threshold for filtering on callrate. What threshold do you think might be appropriate?\nWhat about reproducibility?\n\ngl.report.reproducibility(gl)\n\n\n\n\n\n\n\nTip\n\n\n\nRecall that DArT runs a series of technical replicates as part of its routine workflow. This enables an assessment of the quality of data associated with each locus. What threshold do you think might be appropriate for a filter of reproducability?\n\n\nNow let’s try some filtering. Return to call rate.\n\n# First look at a report to decide a threshold\ngl.report.callrate(gl,method=\"ind\")\n# Then filter using that threshold\ngl &lt;- gl.filter.callrate(gl, method=\"ind\", threshold=0.80)\n# Use a smear plot for a visual assessment of the effectiveness of filtering\ngl &lt;- testset.gl\ngl.smearplot(gl)\n\n\n\n\n\n\n\nTip\n\n\n\nNote the whitespace, which indicates missing data.\n\n\n\n# Filter on callrate by locus, then on individual\ngl &lt;- gl.filter.callrate(gl,verbose=0)\ngl &lt;- gl.filter.callrate(gl, method= \"ind\", threshold=0.80, verbose=0)\n\n# Examine the smearplot again\ngl.smearplot(gl)\n\nWhat has happened. What do you conclude?\n\n\nExercise\n\nFiltering out sex-linked markers\nFor this exercise we will use the data of the Leadbeater’s possum (LBP). This data is included in the package dartR.sexlinked\n\n\n\nThe Leadbeater’s possum :)\n\n\n\n# Load data\nLBP                   # Explore the dataset\nLBP@n.loc             # Number of SNPs\nlength(LBP@ind.names) # Number of individuals\n\n\n\n\n\n\n\nQuestion:\n\n\n\n How many SNPs and individuals does the LBP genlight object have?\nType the correct number into the blank boxes below:\n\nnumber of SNPs \nnumber of individuals \n\nboxes will go green if you have the answer correct\n\n\n\nRun gl.report.sexlinked\nThis function identifies sex-linked and autosomal loci present in a SNP dataset (i.e., genlight object) using individuals with known sex. It identifies five types of loci: w-linked or y-linked, sex-biased, z-linked or x-linked, gametologous and autosomal.\n\n\n\n\n\n\nTip\n\n\n\nThe genlight object must contain in gl\\@other\\$ind.metrics a column named id, and a column named sex in which individuals with known-sex are assigned M for male, or F for female. The function ignores individuals that are assigned anything else or nothing at all (unknown-sex).\n\n\n Check that ind.metrics has the necessary columns:\n\nhead(LBP@other$ind.metrics)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nid\nsex\npop\nYear.collected\nservice\nplate_location\n\n\n\n\nY2\nY2\nF\nYellingbo\n1997\nDLpos17-2786\n1-A1\n\n\nY16\nY16\nM\nYellingbo\n2001\nDLpos17-2786\n1-A10\n\n\nY17\nY17\nF\nYellingbo\n1997\nDLpos17-2786\n1-A11\n\n\nY18\nY18\nF\nYellingbo\n1999\nDLpos17-2786\n1-A12\n\n\nY3\nY3\nF\nYellingbo\n1997\nDLpos17-2786\n1-A2\n\n\nY4\nY4\nM\nYellingbo\n1997\nDLpos17-2786\n1-A3\n\n\n\n\n\n Check the manual of function gl.report.sexlinked to investigate its other requirements:\n\nhelp(gl.report.sexlinked)\n\n Run the function to identify sex-linked loci in the LBP genlight object:\n\nout &lt;- gl.report.sexlinked(LBP, system = \"xy\")\n\nStarting gl.report.sexlinked \n  Processing genlight object with SNP data\n\n\nDetected 162 females and 211 males.\n\n\nStarting phase 1. May take a while...\n\n\nBuilding call rate plot.\n\n\nDone building call rate plot.\n\n\nStarting phase 2. May take a while...\n\n\nBuilding heterozygosity plot.\n\n\nDone building heterozygosity plot.\n\n\n**FINISHED** Total of analyzed loci: 1000.\nFound 77 sex-linked loci:\n   1 Y-linked loci (yellow)\n   9 sex-biased loci (blue)\n   66 X-linked loci (orange)\n   1 gametologs (green).\nAnd 923 autosomal loci (grey).\n\n\n\n\n\n\n\n\n\nCompleted: gl.report.sexlinked \n\n\n\n\n\n\n\n\nQuestion time\n\n\n\nQuestion: Why are we using “xy”?\nQuestion: How many males and females does the dataset contain?\nQuestion: How many sex-linked loci were found?\n\n\nThe output consists of two plots, plus a table. Examine the plots.\n\n\n\n\n\n\nNote\n\n\n\nQuestion: What do the colours mean in the plots? Look at the figure below for a hint.\n\n\n\n\n\nSex-linked loci in XY sex determination systems\n\n\n Now check the output table:\n\nout\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nindex\ncount.F.miss\ncount.M.miss\ncount.F.scored\ncount.M.scored\nratio\np.value\np.adjusted\nscoringRate.F\nscoringRate.M\ny.linked\nsex.biased\ncount.F.het\ncount.M.het\ncount.F.hom\ncount.M.hom\nstat\nstat.p.value\nstat.p.adjusted\nheterozygosity.F\nheterozygosity.M\nx.linked\ngametolog\n\n\n\n\n28681424-34-G/T\n1\n0\n1\n162\n210\n1.2953770\n1.0000000\n1.0000000\n1.0000000\n0.9952607\nFALSE\nFALSE\n1\n0\n161\n210\n1.3033972\n1.0000000\n1.0000000\n0.0061728\n0.0000000\nFALSE\nFALSE\n\n\n28678947-56-C/T\n2\n12\n8\n150\n203\n2.0261283\n0.1638428\n1.0000000\n0.9259259\n0.9620853\nFALSE\nFALSE\n9\n7\n141\n196\n1.7841965\n0.3044519\n0.9598961\n0.0600000\n0.0344828\nFALSE\nFALSE\n\n\n28680567-32-T/G\n3\n12\n12\n150\n199\n1.3256351\n0.5289429\n1.0000000\n0.9259259\n0.9431280\nFALSE\nFALSE\n9\n11\n141\n188\n1.0906350\n1.0000000\n1.0000000\n0.0600000\n0.0552764\nFALSE\nFALSE\n\n\n28688313-7-C/G\n4\n0\n0\n162\n211\n1.3015303\n1.0000000\n1.0000000\n1.0000000\n1.0000000\nFALSE\nFALSE\n6\n0\n156\n211\n8.0761921\n0.0459068\n0.3917911\n0.0370370\n0.0000000\nFALSE\nFALSE\n\n\n28681679-51-C/T\n5\n22\n30\n140\n181\n0.9482168\n0.8814171\n1.0000000\n0.8641975\n0.8578199\nFALSE\nFALSE\n1\n1\n139\n180\n1.2939001\n1.0000000\n1.0000000\n0.0071429\n0.0055249\nFALSE\nFALSE\n\n\n28681994-14-G/A\n6\n0\n1\n162\n210\n1.2953770\n1.0000000\n1.0000000\n1.0000000\n0.9952607\nFALSE\nFALSE\n18\n19\n144\n191\n1.2557905\n0.6007790\n1.0000000\n0.1111111\n0.0904762\nFALSE\nFALSE\n\n\n28687273-35-G/A\n7\n2\n2\n160\n209\n1.3052926\n1.0000000\n1.0000000\n0.9876543\n0.9905213\nFALSE\nFALSE\n64\n81\n96\n128\n1.0533255\n0.8302485\n1.0000000\n0.4000000\n0.3875598\nFALSE\nFALSE\n\n\n28679824-59-A/G\n8\n11\n6\n151\n205\n2.4828757\n0.0823245\n0.9968818\n0.9320988\n0.9715640\nFALSE\nFALSE\n52\n62\n99\n143\n1.2108041\n0.4225316\n1.0000000\n0.3443709\n0.3024390\nFALSE\nFALSE\n\n\n28684498-48-C/T\n9\n32\n40\n130\n171\n1.0521355\n0.8949886\n1.0000000\n0.8024691\n0.8104265\nFALSE\nFALSE\n1\n1\n129\n170\n1.3165942\n1.0000000\n1.0000000\n0.0076923\n0.0058480\nFALSE\nFALSE\n\n\n28686771-26-C/T\n10\n1\n0\n161\n211\n1.3095886\n1.0000000\n1.0000000\n0.9938272\n1.0000000\nFALSE\nFALSE\n54\n79\n107\n132\n0.8436386\n0.4470382\n1.0000000\n0.3354037\n0.3744076\nFALSE\nFALSE\n\n\n28685826-39-C/A\n11\n11\n10\n151\n201\n1.4626962\n0.4976794\n1.0000000\n0.9320988\n0.9526066\nFALSE\nFALSE\n2\n0\n149\n201\n2.6904699\n0.5782830\n1.0000000\n0.0132450\n0.0000000\nFALSE\nFALSE\n\n\n28685909-47-A/G\n12\n1\n3\n161\n208\n0.4315262\n0.6359454\n1.0000000\n0.9938272\n0.9857820\nFALSE\nFALSE\n19\n15\n142\n193\n1.7189806\n0.1483226\n0.7656290\n0.1180124\n0.0721154\nFALSE\nFALSE\n\n\n28684339-40-T/C\n13\n8\n10\n154\n201\n1.0440609\n1.0000000\n1.0000000\n0.9506173\n0.9526066\nFALSE\nFALSE\n33\n38\n121\n163\n1.1693320\n0.5934502\n1.0000000\n0.2142857\n0.1890547\nFALSE\nFALSE\n\n\n28679629-14-C/T\n14\n5\n6\n157\n205\n1.0878623\n1.0000000\n1.0000000\n0.9691358\n0.9715640\nFALSE\nFALSE\n28\n44\n129\n161\n0.7947239\n0.4270510\n1.0000000\n0.1783439\n0.2146341\nFALSE\nFALSE\n\n\n28679675-66-C/T\n15\n2\n0\n160\n211\n2.6307469\n0.5810799\n1.0000000\n0.9876543\n1.0000000\nFALSE\nFALSE\n5\n9\n155\n202\n0.7246290\n0.7844119\n1.0000000\n0.0312500\n0.0426540\nFALSE\nFALSE\n\n\n28679229-66-T/C\n16\n3\n3\n159\n208\n1.3072117\n1.0000000\n1.0000000\n0.9814815\n0.9857820\nFALSE\nFALSE\n43\n65\n116\n143\n0.8159706\n0.4192173\n1.0000000\n0.2704403\n0.3125000\nFALSE\nFALSE\n\n\n28690243-21-G/A\n17\n3\n15\n159\n196\n0.2473174\n0.0259465\n0.5976030\n0.9814815\n0.9289100\nFALSE\nFALSE\n23\n0\n136\n196\n32.9246419\n0.0000001\n0.0000013\n0.1446541\n0.0000000\nTRUE\nFALSE\n\n\n28681769-49-T/G\n18\n1\n0\n161\n211\n1.3095886\n1.0000000\n1.0000000\n0.9938272\n1.0000000\nFALSE\nFALSE\n29\n40\n132\n171\n0.9393419\n0.8931260\n1.0000000\n0.1801242\n0.1895735\nFALSE\nFALSE\n\n\n28691027-42-G/A\n19\n2\n3\n160\n208\n0.8670091\n1.0000000\n1.0000000\n0.9876543\n0.9857820\nFALSE\nFALSE\n11\n1\n149\n207\n15.1955169\n0.0006362\n0.0095436\n0.0687500\n0.0048077\nTRUE\nFALSE\n\n\n28681640-28-G/A\n20\n6\n5\n156\n206\n1.5826038\n0.5425067\n1.0000000\n0.9629630\n0.9763033\nFALSE\nFALSE\n24\n40\n132\n166\n0.7551270\n0.3339841\n0.9919948\n0.1538462\n0.1941748\nFALSE\nFALSE\n\n\n\n\n\nonly showing the first 20 rows\n\n\nRun gl.drop.sexlinked\n Remove the sex-linked loci from the LBP genlight object:\n\nnew.gl &lt;- gl.drop.sexlinked(LBP, system = \"xy\")\nnew.gl\nnew.gl@n.loc\n\n\n\n\n\n\n\nNote\n\n\n\nQuestion: How many SNPs are there left after removing sex-linked loci?\n\nnumber of SNPs \n\n\n\n\n\n\nMore filtering\n\n\n\n\n\n\nKnock yourself out trying all the different report and filtering functions\n\n\n\nRemember to use them as pairs – report function to decide a threshold, filter function to apply the threshold (where appropriate)\nHow about trying it with a different dataset?\n\n\n\n\n\n\n Download SNP data (2 row)\n\n\n\n\n\n\n\n\n\n Download metadata\n\n\n\n\n# how to load a genlight object\ngl &lt;- gl.read.dart(filename=\"./data/sample_data_2Row.csv\", \n                   ind.metafile=\"./data/sample_metadata.csv\")\n\nYou can even try it with your own data.\n\n\n\n\n\n\n\n\n\nReport functions\ndescription\n\n\n\n\ngl.report.callrate\nsummarises CallRate values\n\n\ngl.report.reproducibility\nsummarises repAvg (SNP) or reproducibility (SilicoDArT) values.\n\n\ngl. report.monomorphs\nprovides a count of polymorphic and monomorphic loci\n\n\ngl.report.secondaries\nprovides a count of loci that are secondaries, that is, loci that reside on the one sequence tag.\n\n\ngl.report.rdepth\nreports the estimate of average read depth for each locus\n\n\ngl.report.hamming\nreports on Hamming distances between sequence tags\n\n\ngl.report.overshoot\nreports loci for which the SNP has been trimmed along with the adaptor sequence\n\n\ngl.report.taglength\nreports a frequency tabulation of sequence tag lengths\n\n\ngl.report.sexlinked\nreports the number and type of loci likely to be in sex chromosomes\n\n\n\n\n\n\n\n\n\n\nFilter functions\ndescription\n\n\n\n\ngl.filter.callrate\nfilter out loci or individuals for which the call rate (rate of non-missing values) is less than a specified threshold, say threshold = 0.95\n\n\ngl.filter.reproducibility\nfilter out loci for which the reproducibility (strictly repeatability) is less than a specified threshold, say threshold = 0.99\n\n\ngl. filter.monomorphs\nprovides a count of polymorphic and monomorphic loci\n\n\ngl.filter.allna\nfilter out loci that are all missing values (NA)\n\n\ngl.filter.secondaries\nfilter out SNPs that share a sequence tag, except one retained at random [or the best based on reproducibility (RepAvg) and information content (AvgPIC)].\n\n\ngl.filter.rdepth\nfilter out loci with exceptionally low or high read depth (coverage)\n\n\ngl.filter.hamming\nfilter out loci that differ from each other by less than a specified number of base pairs\n\n\ngl.filter.overshoot\nfilter out loci where the SNP location lies outside the trimmed sequence tag\n\n\ngl.filter.taglength\nfilter out loci for which the tag length is less that a threshold\n\n\ngl.filter.sexlinked\nfilter out loci that are likely to be in sex chromosomes",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Importing and Handling Genomic Data</span>"
    ]
  },
  {
    "objectID": "session01.html#further-study",
    "href": "session01.html#further-study",
    "title": "1  Importing and Handling Genomic Data",
    "section": "Further Study",
    "text": "Further Study\nFor more tuturials see the dartR Tutorials section.\nCheck out the other functions contained in package dartR.sexlinked. What do they do?\nKeep your eyes peeled for Session 8!\n\nReadings\nGruber et al. (2018)\nMijangos et al. (2022)\nJombart and Ahmed (2011)\nRobledo-Ruiz et al. (2023)\n\n\n\n\nGruber, Bernd, Peter J. Unmack, Oliver F. Berry, and Arthur Georges. 2018. “DARTR : An R Package to Facilitate Analysis of SNP Data Generated from Reduced Representation Genome Sequencing.” Molecular Ecology Resources 18 (3): 691–99. https://doi.org/10.1111/1755-0998.12745.\n\n\nJombart, T., and I. Ahmed. 2011. “Adegenet 1.3-1: New Tools for the Analysis of Genome-Wide SNP Data.” Bioinformatics. https://doi.org/10.1093/bioinformatics/btr521.\n\n\nMijangos, Jose Luis, Bernd Gruber, Oliver Berry, Carlo Pacioni, and Arthur Georges. 2022. “dartR V2: An Accessible Genetic Analysis Platform for Conservation, Ecology and Agriculture.” Methods in Ecology and Evolution 13 (10): 2150–58. https://doi.org/10.1111/2041-210X.13918.\n\n\nRobledo-Ruiz, Diana A., Lana Austin, J. Nevil Amos, Jesús Castrejón-Figueroa, Daniel K. P. Harley, Michael J. L. Magrath, Paul Sunnucks, and Alexandra Pavlova. 2023. “Easy-to-Use R Functions to Separate Reduced-Representation Genomic Datasets into Sex-Linked and Autosomal Loci, and Conduct Sex Assignment.” Molecular Ecology Resources 0 (n/a). https://doi.org/10.1111/1755-0998.13844.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Importing and Handling Genomic Data</span>"
    ]
  },
  {
    "objectID": "session02.html",
    "href": "session02.html",
    "title": "2  Estimating Effective Population Size and Key Stats",
    "section": "",
    "text": "Required packages\nSession Presenters\nlibrary(dartRverse)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Estimating Effective Population Size and Key Stats</span>"
    ]
  },
  {
    "objectID": "session02.html#session-content",
    "href": "session02.html#session-content",
    "title": "2  Estimating Effective Population Size and Key Stats",
    "section": "Session Content",
    "text": "Session Content\nThis session will cover the basic statistics that are used to study populations, mainly towards a conservation perspective. We will explore how to estimate effective population size (Ne), heterozygosity (Ho, He), and other key statistics using genomic data. The session will include practical exercises using R and the dartRverse packages.\nfor this session you can use your own data, but feel free to use the example data provided in the dartRverse package.\n\ngls &lt;- possums.gl[c(1:5,31:35),1:7]  #small data set \n\n\nCalculating the number of Alleles\nIn conservation genetics, the number of alleles (allelic richness) is important because it reflects the genetic diversity within a population. This diversity is crucial for:\n\nAdaptive potential – more alleles mean a greater chance that some individuals carry beneficial variants to cope with environmental changes or disease.\nLong-term survival – populations with low allelic diversity are more vulnerable to inbreeding, genetic drift, and extinction.\nConservation decision-making – monitoring allele numbers helps identify populations that are genetically depauperate and may need management (e.g., genetic rescue).\n\nIn short: more alleles = higher evolutionary potential.\nThere are two ways to meassure this quantity.\n\nNumber of Alleles (Na) for SNPs:\nSince SNPs are biallelic by design, Na is either 1 or 2.\n\nIf everyone has the same allele → Na = 1 (monomorphic)\n\nIf both alleles are present → Na = 2 (polymorphic)\n\n\n\nAllelic Richness (Ar) for SNPs:\nStill measures how many alleles are present, but adjusted for sample size via rarefaction. In biallelic SNPs, Ar also ranges from 1 to 2, but:\n\nIn small samples, rare alleles might be missed → Ar &lt; Na\nAr estimates the expected number of alleles if the sample had fewer individuals.\n\n\n#by hand number of alleles\nas.matrix(gls[1:5,])\n\n  X1 X2 X3 X4 X5 X6 X7\n1  1  2  1  2  2  2  1\n2  1  1  1  1  1  1  0\n3  2  0  2  0  1  1  1\n4  0  1  2  0  0  1  0\n5  1  2  1  2  2  2  1\n\n#count the number of alleles per locus in each popu\n\n \n\nnas1 &lt;- gl.report.allelerich(gls)\n\nStarting gl.report.allelerich \n  Processing genlight object with SNP data\n  Calculating Allelic Richness, averaged across\n                    loci, for each population\nStarting gl.colors \nSelected color type dis \nCompleted: gl.colors \nCompleted: gl.report.allelerich \n\n\n\n\n\n\n\n\nnas1$`Allelic Richness per population`\n\n  pop sum_corrected_richness mean_corrected_richness popsize      SD\n1   A                     14                2.000000       5 0.00000\n2   B                     12                1.714286       5 0.48795\n\nnas2 &lt;- gl.report.diversity(gls, table = \"D\")\n\nStarting gl.report.diversity \n  Processing genlight object with SNP data\nStarting gl.filter.allna \n  Identifying and removing loci and individuals scored all \n                missing (NA)\n  Deleting loci that are scored as all missing (NA)\n  Deleting individuals that are scored as all missing (NA)\nCompleted: gl.filter.allna \nStarting gl.colors \nSelected color type dis \nCompleted: gl.colors \n\n\n\n\n\n\n\n\n\n\n\n|   | nloci| m_0Da| sd_0Da| m_1Da| sd_1Da| m_2Da| sd_2Da|\n|:--|-----:|-----:|------:|-----:|------:|-----:|------:|\n|A  |     7| 2.000|  0.000| 1.921|  0.076| 1.860|  0.131|\n|B  |     7| 1.714|  0.488| 1.641|  0.453| 1.595|  0.439|\n\n\npairwise non-missing loci\n\n|   |  A|  B|\n|:--|--:|--:|\n|A  | NA| NA|\n|B  |  7| NA|\n\n\n0_D_beta\n\n|   |     A|     B|\n|:--|-----:|-----:|\n|A  |    NA| 0.244|\n|B  | 1.143|    NA|\n\n\n1_D_beta\n\n|   |     A|     B|\n|:--|-----:|-----:|\n|A  |    NA| 0.094|\n|B  | 1.077|    NA|\n\n\n2_D_beta\n\n|   |    A|     B|\n|:--|----:|-----:|\n|A  |   NA| 0.198|\n|B  | 1.16|    NA|\nCompleted: gl.report.diversity \n\n\nA nice function to have is to run a bootstrapped simulation that selects a random sample of individuals and calculates the allelic richness for that sample and compares it from a sample of the same number of individuals from the combined population.\n\ngg &lt;- gl.report.nall(gls, simlevels = 1:10, reps = 20, ncores = 1)  #change the number of cores if you have more available\n\nStarting gl.report.nall \n  Processing genlight object with SNP data\nStarting gl.filter.allna \n  Identifying and removing loci that are all missing (NA) \n                    in any one population\n  Deleting loci that are all missing (NA) in any one population\n  Warning: no loci listed to delete! Genlight object returned unchanged\nCompleted: gl.filter.allna \nStarting gl.colors \nSelected color type dis \nCompleted: gl.colors \n\n\n\n\n\n\n\n\n\nCompleted: gl.report.nall \n\n\nTask: rerun the analysis with your own data (or use the glb dataset provided here)\n\n\n\nCalculating Heterozygosity\n\nObserved Heterozygosity (Ho):\nObserved heterozygosity (Ho) is the proportion of individuals in a population that are heterozygous at a given locus. It is calculated as per individual and often averaged per population.\n\ngl.report.heterozygosity(gls, method = \"ind\")\n\nStarting gl.report.heterozygosity \n  Processing genlight object with SNP data\n  Calculating observed heterozygosity for individuals\n  Note: No adjustment for invariant loci (n.invariant set to 0)\nStarting gl.colors \nSelected color type 2 \nCompleted: gl.colors \n\n\n\n\n\n\n\n\n\n ind.name        Ho f.hom.ref f.hom.alt n.Loc\n        1 0.4285714 0.0000000 0.5714286     7\n        2 0.8571429 0.1428571 0.0000000     7\n        3 0.4285714 0.2857143 0.2857143     7\n        4 0.2857143 0.5714286 0.1428571     7\n        5 0.4285714 0.0000000 0.5714286     7\n       31 0.4285714 0.2857143 0.2857143     7\n       32 0.7142857 0.1428571 0.1428571     7\n       33 0.4285714 0.2857143 0.2857143     7\n       34 0.2857143 0.5714286 0.1428571     7\n       35 0.4285714 0.2857143 0.2857143     7\nCompleted: gl.report.heterozygosity \n\ngl.report.heterozygosity(gls, method = \"pop\")\n\nStarting gl.report.heterozygosity \n  Processing genlight object with SNP data\n  Calculating Observed Heterozygosities, averaged across\n                    loci, for each population\n  Calculating Expected Heterozygosities\n\nStarting gl.colors \nSelected color type dis \nCompleted: gl.colors \n\n\n\n\n\n\n\n\n\n  pop n.Ind n.Loc n.Loc.adj polyLoc monoLoc all_NALoc       Ho     HoSD\nA   A     5     7         1       7       0         0 0.485714 0.157359\nB   B     5     7         1       5       2         0 0.457143 0.359894\n      HoSE   He     HeSD     HeSE      uHe    uHeSD    uHeSE      FIS   FISSD\nA 0.059476 0.46 0.038297 0.014475 0.511111 0.042552 0.016083  0.02898 0.36056\nB 0.136027 0.32 0.226274 0.085524 0.355556 0.251416 0.095026 -0.27500 0.33541\n     FISSE\nA 0.136279\nB       NA\nCompleted: gl.report.heterozygosity \n\n\nThere is a lot of discussion no the best way to calculate heterozygosity, but the most common method is to use the proportion of heterozygous individuals at each locus. This is “okay” if you compare individuals and populations of the same species (but see Sopniewski and Catullo 2022 and Schmidt et al. 2021 for a discussion on the limitations of this approach). The main problem is that when filtering for low quality (low read depth) often heterozygous loci are lost, which can bias the results. In addition to calculate a comparable heterozygosity across species, we would need to know the number of invariant sites, which are not easily obtained. dartR aims to estimate this number from closely neighbouring loci, if you are using dartR data (secondaries). This estimate is based on a Poisson distribution assumption which is most likely not a good idea as it underestimates the number of invariant sites. We are currently aiming to implement a better method to estimate the number of invariant sites, but for now we will use the gl.report.heterozygosity function to calculate Ho. Schmidt et al. (2021) suggests to calculate genome-wide/autosomal heterozygosity, but it basically means you need whole genome sequences, which is often not available. In summary be careful to calculate Heterozygosity, especially when comparing across species or uneven sampled populations. A rarefaction approach is often used to standardise the sample size. We can do that with the gl.report.heterozygosity function, which allows us to calculate Ho for each individual and then average it per population in combination of gl.subsample.ind() function.\n\n#create a sample data sets (two populations, once with 10 individuals and one with 5 individuals)\n\ngls1 &lt;- possums.gl[c(1:10, 31:35),]\n\n#cr\nsubfun &lt;- function(x) { \n  xx &lt;- gl.subsample.ind(x, n = 5, replace = TRUE, verbose = 0)\n  out &lt;- gl.report.heterozygosity(xx, method = \"pop\", verbose = 0)\n  return(out$Ho)\n  \n  }\n\nsubfun(gls1)\n\n  Warning: Input genlight objects both lack individual metrics\n\n\n[1] 0.329 0.442\n\nsubfun(gls1)\n\n  Warning: Input genlight objects both lack individual metrics\n\n\n[1] 0.343 0.441\n\n#ignore the warning\nres &lt;- sapply(1:50, function(x) subfun(gls1) ) \n\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n  Warning: Input genlight objects both lack individual metrics\n\nrownames(res) &lt;- popNames(gls1)\nboxplot(t(res))\n\n\n\n\n\n\n\nsummary(t(res))\n\n       A                B         \n Min.   :0.3080   Min.   :0.4280  \n 1st Qu.:0.3302   1st Qu.:0.4330  \n Median :0.3435   Median :0.4370  \n Mean   :0.3416   Mean   :0.4367  \n 3rd Qu.:0.3535   3rd Qu.:0.4397  \n Max.   :0.3710   Max.   :0.4440  \n\n\n\n\nTask: Try with your own data set\n\n\nExpected Heterozygosity (He):\n\n\n\nExpected Heterozygosity\nExpected heterozygosity (He) is a key measure of genetic diversity in conservation genetics, representing the probability that two alleles randomly drawn from a population are different. High He indicates a genetically diverse population, which is critical for adaptive potential and long-term viability. In contrast, low He can signal inbreeding, genetic drift, or population bottlenecks. Monitoring He helps conservationists assess population health, guide management actions such as translocations or genetic rescue, and evaluate the success of captive breeding programs in maintaining genetic variation..\n\nDecline of Heterozygosity Over Time in an Ideal Population\nIn an ideal population, the expected heterozygosity (He) declines over time due to genetic drift, even in the absence of selection, mutation, or migration. The rate of this decline is governed by the effective population size (Ne) and follows this mathematical law:\n\\[\nH_t = H_0 \\left(1 - \\frac{1}{2N_e} \\right)^t\n\\]\n\n( H_0 ): initial heterozygosity\n\n( H_t ): heterozygosity after ( t ) generations\n\n( N_e ): effective population size\n\n( (1 - ) ): per-generation retention of heterozygosity\n\n\n\n\nInterpretation\n\nLarger ( N_e ) → slower loss of He\n\nSmall ( N_e ) → rapid loss of He due to drift\n\nThis law underscores why maintaining a large Ne is a central goal in conservation: to preserve genetic variation over time and reduce the risk of inbreeding and loss of adaptive potential.\nExpected heterozygosity (He) is a key measure of genetic diversity in conservation genetics, representing the probability that two alleles randomly drawn from a population are different. High He indicates a genetically diverse population, which is critical for adaptive potential and long-term viability. In contrast, low He can signal inbreeding, genetic drift, or population bottlenecks. Monitoring He helps conservationists assess population health, guide management actions such as translocations or genetic rescue, and evaluate the success of captive breeding programs in maintaining genetic variation.\n\ngg &lt;- gl.report.heterozygosity(gls)\n\nStarting gl.report.heterozygosity \n  Processing genlight object with SNP data\n  Calculating Observed Heterozygosities, averaged across\n                    loci, for each population\n  Calculating Expected Heterozygosities\n\nStarting gl.colors \nSelected color type dis \nCompleted: gl.colors \n\n\n\n\n\n\n\n\n\n  pop n.Ind n.Loc n.Loc.adj polyLoc monoLoc all_NALoc       Ho     HoSD\nA   A     5     7         1       7       0         0 0.485714 0.157359\nB   B     5     7         1       5       2         0 0.457143 0.359894\n      HoSE   He     HeSD     HeSE      uHe    uHeSD    uHeSE      FIS   FISSD\nA 0.059476 0.46 0.038297 0.014475 0.511111 0.042552 0.016083  0.02898 0.36056\nB 0.136027 0.32 0.226274 0.085524 0.355556 0.251416 0.095026 -0.27500 0.33541\n     FISSE\nA 0.136279\nB       NA\nCompleted: gl.report.heterozygosity \n\ngg\n\n  pop n.Ind n.Loc n.Loc.adj polyLoc monoLoc all_NALoc       Ho     HoSD\nA   A     5     7         1       7       0         0 0.485714 0.157359\nB   B     5     7         1       5       2         0 0.457143 0.359894\n      HoSE   He     HeSD     HeSE      uHe    uHeSD    uHeSE      FIS   FISSD\nA 0.059476 0.46 0.038297 0.014475 0.511111 0.042552 0.016083  0.02898 0.36056\nB 0.136027 0.32 0.226274 0.085524 0.355556 0.251416 0.095026 -0.27500 0.33541\n     FISSE\nA 0.136279\nB       NA\n\n\nExpected heterozygosity can be standardised by sample size (because allele frequencies are estimated and they are missing rare alleles at low sample size, hence is biased downwards. Therefore the correction is 2n/(2n-1) where n is the number of individuals. This is then called uHe, but is mainly important due to low sample sizes. Again you can use a rarefaction approach to standardise the sample size, which is implemented in the gl.report.heterozygosity function.\n\n\nHardy-Weinberg Equilibrium (HWE)\nHWE is a principle that describes the genetic variation in a population under certain conditions. It states that allele and genotype frequencies will remain constant from generation to generation in the absence of evolutionary influences.\nIn conservation genetics, testing for HWE is important because:\n\nDeviations from HWE can indicate inbreeding, genetic drift, or selection pressures.\nHelps identify populations at risk of losing genetic diversity.\nCan inform management strategies to maintain genetic health.\n\nTo test for HWE, we can use the gl.report.hwe function, which performs a chi-squared test for each locus and returns the p-values.\nThis can be done on population level (subset=“each”) or on the whole dataset (subset=“all”).\n\n#does not make much sense (sample size too low)\ngl.report.hwe(gls,subset = \"each\",min_sample_size = 1 )\n\nStarting gl.report.hwe \n  Processing genlight object with SNP data\n\n\nRegistered S3 methods overwritten by 'ggtern':\n  method           from   \n  grid.draw.ggplot ggplot2\n  plot.ggplot      ggplot2\n  print.ggplot     ggplot2\n\n\n  Analysing each population separately\nStarting gl.colors \nSelected color type 2c \nCompleted: gl.colors \n\n\n`geom_line()`: Each group consists of only one observation.\nℹ Do you need to adjust the group aesthetic?\n\n\n`geom_line()`: Each group consists of only one observation.\nℹ Do you need to adjust the group aesthetic?\n\n\n\n\n\n\n\n\n\n    Reporting significant departures from Hardy-Weinberg \n            Equilibrium\n    No significant departures\n\nCompleted: gl.report.hwe \n\n# only 10 loci...\ngl.report.hwe(possums.gl[1:90,],subset = \"each\")\n\nStarting gl.report.hwe \n  Processing genlight object with SNP data\n  Analysing each population separately\nStarting gl.colors \nSelected color type 2c \nCompleted: gl.colors \n\n\n\n\n\n\n\n\n\n    Reporting significant departures from Hardy-Weinberg \n            Equilibrium\n    NB: Departures significant at the alpha level of 0.05 are listed\n    Adjustment of p-values for multiple comparisons vary\n                    with sample size\n Population  Locus Hom_1   Het Hom_2     N         Prob    Sig Prob.adj Sig.adj\n     &lt;char&gt; &lt;char&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;num&gt;        &lt;num&gt; &lt;char&gt;   &lt;lgcl&gt;  &lt;lgcl&gt;\n          B   X114    19     7     4    30 0.0481152745    sig       NA      NA\n          B   X120    22     5     3    30 0.0322894276    sig       NA      NA\n          B   X123     3    24     3    30 0.0026880391    sig       NA      NA\n          C   X128    10    20     0    30 0.0108195955    sig       NA      NA\n          C   X140     4    22     4    30 0.0261558384    sig       NA      NA\n          B   X142     2    21     7    30 0.0275978824    sig       NA      NA\n          A   X152    18     7     5    30 0.0248050366    sig       NA      NA\n          B   X171    22     5     3    30 0.0322894276    sig       NA      NA\n          B   X177     1    24     5    30 0.0009308178    sig       NA      NA\n          A   X181     4     7    19    30 0.0481152745    sig       NA      NA\n          B   X198     9     9    12    30 0.0324438457    sig       NA      NA\n          A    X30    11    19     0    30 0.0279783750    sig       NA      NA\n          B    X31     3    22     5    30 0.0250646233    sig       NA      NA\n          B    X47     6    22     2    30 0.0118328520    sig       NA      NA\n          A    X48     3    22     5    30 0.0250646233    sig       NA      NA\n          A    X50     5    23     2    30 0.0079779773    sig       NA      NA\n          B    X55    11    19     0    30 0.0279783750    sig       NA      NA\n          B    X65     8     7    15    30 0.0066040187    sig       NA      NA\n  npop\n &lt;int&gt;\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n\nCompleted: gl.report.hwe \n\n\n\n\nInbreeding Fis\nInbreeding coefficient (Fis) is a measure of the degree of inbreeding in a population. It quantifies the reduction in heterozygosity due to inbreeding compared to a randomly mating population. A positive Fis indicates inbreeding, while a negative value suggests outbreeding or excess heterozygosity.\n\ngl.report.heterozygosity(gls)\n\nStarting gl.report.heterozygosity \n  Processing genlight object with SNP data\n  Calculating Observed Heterozygosities, averaged across\n                    loci, for each population\n  Calculating Expected Heterozygosities\n\nStarting gl.colors \nSelected color type dis \nCompleted: gl.colors \n\n\n\n\n\n\n\n\n\n  pop n.Ind n.Loc n.Loc.adj polyLoc monoLoc all_NALoc       Ho     HoSD\nA   A     5     7         1       7       0         0 0.485714 0.157359\nB   B     5     7         1       5       2         0 0.457143 0.359894\n      HoSE   He     HeSD     HeSE      uHe    uHeSD    uHeSE      FIS   FISSD\nA 0.059476 0.46 0.038297 0.014475 0.511111 0.042552 0.016083  0.02898 0.36056\nB 0.136027 0.32 0.226274 0.085524 0.355556 0.251416 0.095026 -0.27500 0.33541\n     FISSE\nA 0.136279\nB       NA\nCompleted: gl.report.heterozygosity \n\n\n\nFixed and private Alleles\nPrivate alleles are alleles found only in a single population, while fixed alleles are alleles that occur at 100% frequency within a population. In conservation genetics, private alleles can indicate unique evolutionary history or local adaptation and are useful for identifying distinct populations or units for conservation. Fixed alleles, on the other hand, may signal a loss of genetic diversity due to drift or inbreeding. Monitoring both helps assess population structure, track gene flow, and guide decisions about mixing or isolating populations. Private alleles can also be used to identify assymetry in geneflow (Campbell et al. 2021).\n\n\nPrivate Alleles\n\ngl.map.interactive(possums.gl[1:120,])\n\nStarting gl.map.interactive \n  Processing genlight object with SNP data\nCompleted: gl.map.interactive \n\n\n\n\n\ngl.report.pa(possums.gl[1:120,] )\n\nStarting gl.report.pa \n  Processing genlight object with SNP data\n  Warning: no loci listed to keep! Genlight object returned unchanged\n  Warning: no loci listed to keep! Genlight object returned unchanged\n  p1 p2 pop1 pop2 N1 N2 fixed priv1 priv2 Chao1 Chao2 totalpriv   AFD asym\n1  1  2    A    B 30 30     0     1    24    NA     0        25 0.309   NA\n2  1  3    A    C 30 30     0     1    24    NA     0        25 0.302   NA\n3  1  4    A    D 30 30     2    49    21     0     0        70 0.370   NA\n4  2  3    B    C 30 30     0     0     0     0     0         0 0.180   NA\n5  2  4    B    D 30 30     1    52     1     0    NA        53 0.332   NA\n6  3  4    C    D 30 30     1    52     1     0    NA        53 0.314   NA\n  asym.sig\n1       NA\n2       NA\n3       NA\n4       NA\n5       NA\n6       NA\n  Table of private alleles and fixed differences returned\nCompleted: gl.report.pa \n\ngl.fixed.diff(possums.gl[1:120,])  \n\nStarting gl.fixed.diff \n  Processing genlight object with SNP data\n  Comparing populations for absolute fixed differences\n  Monomorphic loci removed\n  Comparing populations pairwise -- this may take time. Please be patient\nCompleted: gl.fixed.diff \n\n\n$gl\n ********************\n *** DARTR OBJECT ***\n ********************\n\n ** 120 genotypes,  200 SNPs , size: 233.8 Kb\n\n    missing data: 0 (=0 %) scored as NA\n\n ** Genetic data\n   @gen: list of 120 SNPbin\n   @ploidy: ploidy of each individual  (range: 2-2)\n\n ** Additional data\n   @ind.names:  120 individual labels\n   @loc.names:  200 locus labels\n   @loc.all:   no allele labels\n   @pop: population of each individual (group size range: 30-30)\n   @other: a list containing: xy, loc.metrics, loc.metrics.flags, verbose, history, latlon \n   @other$latlon[g]: coordinates for all individuals are attached\n\n$fd\n  A B C\nB 0    \nC 0 0  \nD 2 1 1\n\n$pcfd\n  A B C\nB 0    \nC 0 0  \nD 1 0 0\n\n$nobs\n   A  B  C  D\nA NA 60 60 60\nB 60 NA 60 60\nC 60 60 NA 60\nD 60 60 60 NA\n\n$nloc\n    A   B   C   D\nA  NA 200 200 200\nB 200  NA 200 200\nC 200 200  NA 200\nD 200 200 200  NA\n\n$expfpos\n     [,1] [,2] [,3] [,4]\n[1,]   NA   NA   NA   NA\n[2,]   NA   NA   NA   NA\n[3,]   NA   NA   NA   NA\n[4,]   NA   NA   NA   NA\n\n$sdfpos\n     [,1] [,2] [,3] [,4]\n[1,]   NA   NA   NA   NA\n[2,]   NA   NA   NA   NA\n[3,]   NA   NA   NA   NA\n[4,]   NA   NA   NA   NA\n\n$pval\n     [,1] [,2] [,3] [,4]\n[1,]   NA   NA   NA   NA\n[2,]   NA   NA   NA   NA\n[3,]   NA   NA   NA   NA\n[4,]   NA   NA   NA   NA\n\nattr(,\"class\")\n[1] \"fd\"\n\n\n\n\nRelatedness and Kinship\nRelatedness and kinship are measures of genetic relatedness between individuals in a population. They are crucial for understanding population structure, mating systems, and the potential for inbreeding.\nRelatedness in dartRverse is calculated via the gl.grm function:\nBased on the A.mat function (package rrBLUP) R estimates a genomic additive relationship matrix (GRM) based on SNP genotype data. The matrix it produces approximates realized additive genetic relationships between individuals, capturing shared alleles weighted by allele frequencies. The additive relationship matrix (often denoted AA) quantifies the expected proportion of alleles shared identical-by-descent (IBD) between individuals due to additive genetic effects. This generates an n×n matrix where each entry reflects the genomic similarity between two individuals.\nEach entry \\(A_ij\\) reflects the expected genetic relatedness between individuals i and j under the additive genetic model. Diagonal entries \\(A_ii\\) represent the self-relatedness or inbreeding coefficient (1+Fi). Offf-diagonals \\(A_ij\\) represent the proportion of alleles shared IBD between individuals. It produces values centered around 0 (unrelated) and 1 (identical).\n\n#simulate some relatedness data\n\nglsim &lt;- gl.sim.Neconst(ninds = 50, nlocs = 1000)\nAmat &lt;- gl.grm(glsim)\n\nStarting gl.grm \n  Processing genlight object with SNP data\n  Processing genlight object with SNP data\n\n\n\n\n\n\n\n\n\nCompleted: gl.grm \n\n### F is diag(A)-1\n# centered around 1\nhist(diag(Amat)-1)\n\n\n\n\n\n\n\n#proportion of shared alleles  IBD between individuals\nrelA &lt;- Amat\ndiag(relA)&lt;-NA \nhist(relA)\n\n\n\n\n\n\n\n\nSo we have created a population of 50 individuals with 1000 loci, and calculated the Amat. The diagonal entries represent the inbreeding coefficient (1+Fi), so Fi is centered around 0, indicating that individuals are not highly inbred. The off-diagonal entries represent the proportion of alleles shared IBD between individuals, which is centered around 0, indicating that individuals are not closely related. As we have simulated theindividuals, we know that they are not related, so this is expected.\nNow lets add some offsprings to the mix and see how the turn up in the A mat.\n\n#create an 10 offsprings from indivivdual 1 and 2\noffsprings &lt;- gl.sim.offspring(glsim[1,], glsim[2,], noffpermother = 10, popname = \"off12\")\nglsimoff &lt;- rbind(glsim, offsprings)\n\nAmat &lt;- gl.grm(glsimoff)\n\nStarting gl.grm \n  Processing genlight object with SNP data\n  Processing genlight object with SNP data\n\n\n\n\n\n\n\n\n\nCompleted: gl.grm \n\n\nAnd here you can see the offsprings in the A mat, they are related to the parents (1 and 2) and to each other, but not to the rest of the population. There relatedness value (the proportion of alleles that individuals share IBD at any locus) is 0.5 (the expected value for half siblings and offsprings).\n\n# matrix between offsprings and parents\n\nApo &lt;- Amat[c(1,2,51:60),c(1,2,51:60) ]\nround(Apo,2)\n\n          1     2 Po_1 Po_2 Po_3 Po_4 Po_5 Po_6 Po_7 Po_8 Po_9 Po_10\n1      0.79 -0.10 0.33 0.36 0.36 0.33 0.32 0.31 0.35 0.34 0.30  0.32\n2     -0.10  0.84 0.30 0.35 0.35 0.34 0.40 0.35 0.36 0.39 0.33  0.35\nPo_1   0.33  0.30 0.78 0.30 0.30 0.33 0.39 0.23 0.31 0.26 0.29  0.25\nPo_2   0.36  0.35 0.30 0.87 0.36 0.30 0.38 0.31 0.35 0.35 0.36  0.35\nPo_3   0.36  0.35 0.30 0.36 0.88 0.32 0.34 0.30 0.39 0.41 0.37  0.32\nPo_4   0.33  0.34 0.33 0.30 0.32 0.89 0.38 0.27 0.31 0.31 0.32  0.35\nPo_5   0.32  0.40 0.39 0.38 0.34 0.38 0.86 0.40 0.36 0.34 0.32  0.34\nPo_6   0.31  0.35 0.23 0.31 0.30 0.27 0.40 0.85 0.35 0.32 0.25  0.28\nPo_7   0.35  0.36 0.31 0.35 0.39 0.31 0.36 0.35 0.89 0.30 0.39  0.32\nPo_8   0.34  0.39 0.26 0.35 0.41 0.31 0.34 0.32 0.30 0.88 0.30  0.39\nPo_9   0.30  0.33 0.29 0.36 0.37 0.32 0.32 0.25 0.39 0.30 0.81  0.29\nPo_10  0.32  0.35 0.25 0.35 0.32 0.35 0.34 0.28 0.32 0.39 0.29  0.84\n\n## only related to parents and each other\nrelpo &lt;- Apo\ndiag(relpo)&lt;-NA\nhist(relpo, main = \"Relatedness between offsprings and parents\", xlab = \"Relatedness\", ylab = \"Frequency\")\n\n\n\n\n\n\n\n\nNow lets look at the kinship matrix, which is calculated via the gl.run.EMIBD9 function. For this function to work you need to have the emibd9 package installed. An easy way to do so, is using the gl.download.binary in the dartRverse package. We asked for permission from the Author ()\n\n#install emibd9 from Wang 2022 in the temporary directory\ndir_emibd &lt;- './binaries/'\ndir &lt;- gl.download.binary(\"emibd9\", out.dir = dir_emibd)\n\nDownloaded binary to  C:\\Users\\ejstr\\AppData\\Local\\Temp\\Rtmpg7tfJR\\file42c4646c591 \nUnzipped binary to ./binaries//emibd9\n\n\nWhen estimating relatedness and kinship, there is one major difficulty. We need to have a good estimate of the allele frequencies in the population. If we have a population with a lot of missing data, or if we have a population with a lot of inbred individuals the estimates of relatedness and kinship will be biased. In the best case you would estimate allele frequencies from a sample of unrelated individuals and then use these allele frequencies to estimate relatedness and kinship in the whole population. However, this is rarely possible, especially in conservation genetics where we often work with small populations and have only one sample\nEMIBD9 is aiming to take care of that, but using an algorithm that aims to estimate allele frequencies and kinship in a ‘shinkage’ fashion so both at the same time and optimising the result. It performs really well in simulations. Please note there are many other relatedness estimates, but they all suffer from this problem and often give negative results, which in principle should not happen. Lets use EMIBD9 to estimate the kinship matrix for our simulated population.\n\n#ignore the warnings...\nkinmat &lt;- gl.run.EMIBD9(glsimoff, Inbreed = 1, emibd9.path = dir_emibd)\n\nStarting gl.run.EMIBD9 \n  Processing genlight object with SNP data\n  Found necessary files to run EMIBD9.\nExporting individual diversity and inbreeding values \n  Returning a list containing the input gl object, a square matrix  of pairwise kinship, and the raw EMIBD9 results table as follows:\n           $rel -- a square matrix of relatedness \n           $raw -- raw EMIBD9 results table \n           $processed -- EMIBD9 results without self and redundant comparison \n           $inbreeding -- Individual diversity and inbreeding (if requested) \nStarting gl.colors \nSelected color type div \nCompleted: gl.colors \n\n\nFound more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics'\n\n\nAlso defined by 'spam'\n\n\nRegistered S3 method overwritten by 'dendextend':\n  method     from \n  rev.hclust vegan\n\n\nWarning in rep(col, length.out = leaves_length): 'x' is NULL so the result will\nbe NULL\n\n\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\n\n\n\n\n\n\n\n\n\nCompleted: gl.run.EMIBD9 \n\n\nAs before we find the related individuals. Lets check the results as before:\n\n### F is diag(kinmat$rel)-1\nhist((2*diag(kinmat$rel) - 1), main = \"Kinship\", xlab = \"Kinship\", ylab = \"Frequency\" )\n\n\n\n\n\n\n\n#kinship values between parents and offsprings and between offsprings =0.25\nkinpo &lt;- kinmat$rel[c(1,2,51:60),c(1,2,51:60) ]\ndiag(kinpo)&lt;- NA\nhist(kinpo, main = \"Kinship between offsprings and parents\", xlab = \"Kinship\", ylab = \"Frequency\" )\n\n\n\n\n\n\n\n#variance is different. \n#Parent off spring variance is zero.\n\nFinally lets compare the relatedness estimates using gl.grm and EMIBD9. The results are very similar, but in theory the EMIBD9 estimates should be more precise, as they take into account the non independence of allele frequencies in the population.\n\n#compare the two matrices\nArel &lt;- Amat[lower.tri(Amat, diag = FALSE)]\nkinrel &lt;- kinmat$rel[lower.tri(kinmat$rel, diag = FALSE)]\nplot(Arel, kinrel, \n     xlab = \"Relatedness (gl.grm)\", \n     ylab = \"Kinship (EMIBD9)\", \n     main = \"Comparison of F values from gl.grm and EMIBD9\",\n     pch = 19, col = \"blue\")\n\n\n\n\n\n\n\n\n\n\n\nEffective Population Size\n\nCurrent effective population size\nEffective population size (Ne) is the size of an idealized population that would experience genetic drift or inbreeding at the same rate as the observed population.\nIt is almost always smaller than the actual census size (N) due to factors like unequal sex ratios, variation in reproductive success, or population size fluctuations.\n\n#install the Neestimator package\n\ndir &lt;- dartRverse::gl.download.binary(\"neestimator\", out.dir = tempdir())\n\nDownloaded binary to  C:\\Users\\ejstr\\AppData\\Local\\Temp\\RtmpcJUpXh\\file68ac334331f \nUnzipped binary to C:\\Users\\ejstr\\AppData\\Local\\Temp\\RtmpcJUpXh/neestimator\n\n\n\n#simulate a population of 50 individuals with 1000 loci\n\nsim50 &lt;- gl.sim.Neconst(ninds = 50, nlocs = 3000)\n#need to reproduce a bit (to get the population to be in Hardy-Weinberg equilibrium)\n\nsim50 &lt;- gl.sim.offspring(sim50, sim50, noffpermother = 1) #ideal population\nsim50 &lt;- gl.sim.offspring(sim50, sim50, noffpermother = 1) #ideal population\nsim50 &lt;- gl.sim.offspring(sim50, sim50, noffpermother = 1) #ideal population\nsim50 &lt;- gl.sim.offspring(sim50, sim50, noffpermother = 1) #ideal population\nsim50 &lt;- gl.sim.offspring(sim50, sim50, noffpermother = 1) #ideal population\n\n\ngg &lt;-gl.LDNe(sim50, neest.path = dir, mating = \"random\", critical = c(0.1,0.05))\n\nStarting gl.LDNe \n  Processing genlight object with SNP data\nStarting gl2genepop \n  Processing genlight object with SNP data\n  The genepop file is saved as:  C:\\Users\\ejstr\\AppData\\Local\\Temp\\RtmpcJUpXh/dummy.gen/\nCompleted: gl2genepop \n  Processing genlight object with SNP data\n\n\n\n\n\n\n\n\n\n$offspring_Po\n                    Statistic Frequency 1 Frequency 2 Frequency 3 Frequency 4\n Lowest Allele Frequency Used       0.100       0.050       No S*          0+\n    Harmonic Mean Sample Size          50          50          50          50\n      Independent Comparisons      660675     1133265     1668051     1840321\n                  OverAll r^2    0.028091    0.028048    0.027454    0.026909\n          Expected r^2 Sample    0.021276    0.021276    0.021276    0.021276\n                Estimated Ne^        46.7        47.1        51.8          57\n            CI low Parametric        46.1        46.5        51.3        56.5\n           CI high Parametric        47.4        47.6        52.3        57.6\n             CI low JackKnife        38.7        39.4        43.4        48.1\n            CI high JackKnife        57.8        57.4          63          69\n\n  The results are saved in: C:\\Users\\ejstr\\AppData\\Local\\Temp\\RtmpcJUpXh/genepopLD.txt \nCompleted: gl.LDNe \n\n\n\n\nHistoric population sizes\n\n#install the Neestimator package\n\ndir &lt;- dartRverse::gl.download.binary(\"epos\", out.dir = tempdir())\n\nDownloaded binary to  C:\\Users\\ejstr\\AppData\\Local\\Temp\\RtmpcJUpXh\\file68ac65a75100 \nUnzipped binary to C:\\Users\\ejstr\\AppData\\Local\\Temp\\RtmpcJUpXh/epos\n\n\n\ngl.sfs(sim50)\n\nStarting gl.sfs \n  Processing genlight object with SNP data\n\n\n\n\n\n\n\n\n\nCompleted: gl.sfs \n\n\n  d0   d1   d2   d3   d4   d5   d6   d7   d8   d9  d10  d11  d12  d13  d14  d15 \n1081   92  125  106   90   83   83   70   61   59   70   42   49   38   45   47 \n d16  d17  d18  d19  d20  d21  d22  d23  d24  d25  d26  d27  d28  d29  d30  d31 \n  38   24   42   27   28   26   29   24   20   26   36   25   35   22   26   27 \n d32  d33  d34  d35  d36  d37  d38  d39  d40  d41  d42  d43  d44  d45  d46  d47 \n  27   23   28   20   21   20   15   23   14   26   19   19   22   29   18   23 \n d48  d49  d50 \n  25   18   14 \n\n\n\n#parameters for epos\n# mutation rate\nu =1e-8  #from simulation\n\n#To get L we need estimate the Length of the genome in base pairs.\n# watterson estimate for a sample of 50 is 4.499\nL &lt;- sum(gl.sfs(sim50)[-1])/( 4 * 50 *1e-8 * 4.499)\n\nStarting gl.sfs \n  Processing genlight object with SNP data\n\n\n\n\n\n\n\n\n\nCompleted: gl.sfs \n\ngepos &lt;- gl.run.epos(sim50, epos.path = dir, L=L, u=u, boot=10, minbinsize = 2)\n\n  Processing genlight object with SNP data\n  Output written to C:\\Users\\ejstr\\AppData\\Local\\Temp\\RtmpcJUpXh/epos.out \n\n\n\n\n\n\n\n\n\nCompleted: gl.run.epos \n\n\n\n\nCGED example\n\nlibrary(dartRverse)\nnorth &lt;- readRDS(\"./data/TympoNorth.rds\")\n\n\n#filters \nnorth2 &lt;- gl.filter.callrate(north, method = \"loc\", threshold = 0.95)\n\nStarting gl.filter.callrate \n  Processing genlight object with SNP data\n  Warning: data include loci that are scored NA across all individuals.\n  Consider filtering using gl &lt;- gl.filter.allna(gl)\n  Warning: Data may include monomorphic loci in call rate \n                    calculations for filtering\n  Recalculating Call Rate\n  Removing loci based on Call Rate, threshold = 0.95 \n\n\n\n\n\n\n\n\n\nCompleted: gl.filter.callrate \n\nnorth3 &lt;- gl.filter.rdepth(north2, lower = 10, upper=40)\n\nStarting gl.filter.rdepth \n  Processing genlight object with SNP data\n  Removing loci with rdepth &lt;= 10 and &gt;= 40 \n\n\n\n\n\n\n\n\n\nCompleted: gl.filter.rdepth \n\nnorth4 &lt;- gl.filter.monomorphs(north3)\n\nStarting gl.filter.monomorphs \n  Processing genlight object with SNP data\n  Identifying monomorphic loci\n  Removing monomorphic loci and loci with all missing \n                       data\nCompleted: gl.filter.monomorphs \n\nnorth5 &lt;- gl.filter.callrate(north4, threshold = 0.9, method=\"ind\")\n\nStarting gl.filter.callrate \n  Processing genlight object with SNP data\n  Recalculating Call Rate\n  Removing individuals based on Call Rate, threshold = 0.9 \n\n\n\n\n\n\n\n\n\n  Note: Locus metrics not recalculated\n  Note: Resultant monomorphic loci not deleted\nCompleted: gl.filter.callrate \n\n#checks\nnorth5\n\n ********************\n *** DARTR OBJECT ***\n ********************\n\n ** 121 genotypes,  10,832 SNPs , size: 44.6 Mb\n\n    missing data: 13360 (=1.02 %) scored as NA\n\n ** Genetic data\n   @gen: list of 121 SNPbin\n   @ploidy: ploidy of each individual  (range: 2-2)\n\n ** Additional data\n   @ind.names:  121 individual labels\n   @loc.names:  10832 locus labels\n   @loc.all:  10832 allele labels\n   @position: integer storing positions of the SNPs [within 69 base sequence]\n   @pop: population of each individual (group size range: 121-121)\n   @other: a list containing: loc.metrics, latlon, loc.metrics.flags, verbose, history \n   @other$latlon[g]: coordinates for all individuals are attached\n\ngl.sfs(north5)\n\nStarting gl.sfs \n  Processing genlight object with SNP data\nYour data contains missing data, better filter stronger or use gl.impute to fill those gaps meaningful!\n\n\n\n\n\n\n\n\n\nCompleted: gl.sfs \n\n\n  d0   d1   d2   d3   d4   d5   d6   d7   d8   d9  d10  d11  d12  d13  d14  d15 \n   0  747  557  375  244  203  165  154  118  125  122  114  114  122  107  115 \n d16  d17  d18  d19  d20  d21  d22  d23  d24  d25  d26  d27  d28  d29  d30  d31 \n  96  106  102   96  104  106   79  105  103   98   78   89   86   79   91   89 \n d32  d33  d34  d35  d36  d37  d38  d39  d40  d41  d42  d43  d44  d45  d46  d47 \n  86   89   83  101   95   78   83   87   53   90   77   89   78   76   73   90 \n d48  d49  d50  d51  d52  d53  d54  d55  d56  d57  d58  d59  d60  d61  d62  d63 \n  66   75   88  100   75   70   71   80   75   72   77   54   81   74   63   67 \n d64  d65  d66  d67  d68  d69  d70  d71  d72  d73  d74  d75  d76  d77  d78  d79 \n  65   90   64   63   70   49   72   74   60   61   72   60   50   70   62   71 \n d80  d81  d82  d83  d84  d85  d86  d87  d88  d89  d90  d91  d92  d93  d94  d95 \n  49   70   70   64   69   58   62   51   76   51   63   54   59   56   44   61 \n d96  d97  d98  d99 d100 d101 d102 d103 d104 d105 d106 d107 d108 d109 d110 d111 \n  51   61   54   54   76   42   49   62   43   49   56   37   53   53   53   62 \nd112 d113 d114 d115 d116 d117 d118 d119 d120 d121 \n  67   60   60   61   55   66   53   43   58   39 \n\nnInd(north5)\n\n[1] 121\n\nnLoc(north5)\n\n[1] 10832\n\n### takes 10 minutes or so....\n#curNe &lt;- gl.LDNe(north5, neest.path = dir, critical = 0.05)  #-&gt; ~40\n\n\n#for dart data (times 75), 69+\nL &lt;- nLoc(north5)*75*200\nmu = 16.17e-9\n\n\n# takes a minute or so\ngg &lt;- gl.run.epos(north5, epos.path = dir,L = L, u = mu, method = \"greedy\", depth = 2, boot=5)\n\n  Processing genlight object with SNP data\n  Output written to C:\\Users\\ejstr\\AppData\\Local\\Temp\\RtmpcJUpXh/epos.out \n\n\n\n\n\n\n\n\n\nCompleted: gl.run.epos \n\ngg$plot",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Estimating Effective Population Size and Key Stats</span>"
    ]
  },
  {
    "objectID": "session02.html#further-study",
    "href": "session02.html#further-study",
    "title": "2  Estimating Effective Population Size and Key Stats",
    "section": "Further Study",
    "text": "Further Study\n\n\n\n\n\n\nExercise\n\n\n\n Now run your own data set (or use the tympo data set) to study any of the topics from the tutorial. Have fun !!!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Estimating Effective Population Size and Key Stats</span>"
    ]
  },
  {
    "objectID": "session02.html#further-study-1",
    "href": "session02.html#further-study-1",
    "title": "2  Estimating Effective Population Size and Key Stats",
    "section": "Further Study",
    "text": "Further Study\n\nReadings\n\nCampbell, C.D., Cowan, P., Gruber, B. et al. Has the introduction of two subspecies generated dispersal barriers among invasive possums in New Zealand?. Biol Invasions 23, 3831–3845 (2021). https://doi.org/10.1007/s10530-021-02609-1\nSchmidt, T. L., Jasper, M.-E., Weeks, A. R., & Hoffmann, A. A. (2021). Unbiased population heterozygosity estimates from genome-wide sequence data. Methods in Ecology and Evolution, 12, 1888–1898. https://doi.org/10.1111/2041-210X.13659\nSopniewski J, Catullo RA. Estimates of heterozygosity from single nucleotide polymorphism markers are context-dependent and often wrong. Mol Ecol Resour. 2024 May;24(4):e13947. doi: 10.1111/1755-0998.13947. Epub 2024 Mar 3. PMID: 38433491.\nWang, J. (2022). A joint likelihood estimator of relatedness and allele frequencies from a small sample of individuals. Methods in Ecology and Evolution, 13(11), 2443-2462.\nWaples, R. S. (2006). “A bias correction for estimates of effective population size based on linkage disequilibrium at unlinked gene loci*.” Conservation Genetics 7(2): 167-184.\nWaples, R. K., et al. (2016). “Estimating contemporary effective population size in non-model species using linkage disequilibrium across thousands of loci.” Heredity 117(4): 233-240.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Estimating Effective Population Size and Key Stats</span>"
    ]
  },
  {
    "objectID": "session03.html",
    "href": "session03.html",
    "title": "3  Identifying Population Structure",
    "section": "",
    "text": "Required packages\nSession Presenters\nAs always we need to have dartRverse installed and loaded. In addition you need to have dartR.popgen installend.\nlibrary(dartRverse)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Identifying Population Structure</span>"
    ]
  },
  {
    "objectID": "session03.html#uncovering-population-structure",
    "href": "session03.html#uncovering-population-structure",
    "title": "3  Identifying Population Structure",
    "section": "Uncovering Population Structure",
    "text": "Uncovering Population Structure\n\nIntroduction\nWhy population structure matters\n\nWhat is a “population” in population genetics?\nGenetic structure defined – how allele frequencies vary among groups.\nKey drivers: effective population size, gene flow/immigration, natural selection, drift.\nIsolation-by-distance & sampling design – avoiding spurious structure.\nWhy we care: management units, inbreeding, local adaptation, introgression.\n\n\nAnalytical toolkit\n\n\n\n\n\n\n\n\nApproach\nPurpose\ndartR entry point\n\n\nPCoA / PCA\nQuick multivariate overview\ngl.pcoa(), gl.pcoa.plot()\n\n\nSTRUCTURE\nBayesian clustering\ngl.run.structure(), gl.plot.structure(), gl.map.structure()\n\n\nfastSTRUCTURE\nFast variational STRUCTURE (Mac/Linux)\ngl.run.faststructure(), gl.plot.faststructure()\n\n\nsNMF\nSparse non-negative matrix factorisation\ngl.run.snmf(), gl.plot.snmf(), gl.map.snmf()\n\n\nPOPCLUSTER\nUltra-fast admixture inference\ngl.run.popcluster(), gl.plot.popcluster(), gl.map.popcluster()\n\n\n\n\n\n\nExample\nTo help us understand our analytical toolkit better let’s start with a simple example using a simulated dataset.\nThe dataset is a genlight object and contains 10 populations of 30 individuals each and 1000 loci and is part of the dartRverse package. The populations are fairly independent but are linked by some imigration, so a typical Metapopulation scenario. The populations are named A to J and follow more or less an isolation by distance (actually an isolation by resistance model). So population next to each other (e.g. B and C) are fairly well mixed and populations further apart from the rest (e.g. D) are more isolated.\nTo simplify this further we limit our exercise to the first 150 individuals only (which entails now 5 populations a 30 individuals, A to E). To get an overview on the population we use the function: gl.map.interactive which plots the individuals on a map. Please note the genlight/dartR object needs to have valid lat long coordinates for each individual to be able to do so.\nLets get started.\n\nPCA\n\n# Read in the simulated possum data\ngl &lt;- possums.gl[1:150,]\n# Interrogate to see what the data are\nnLoc(gl)\n\n[1] 200\n\nnInd(gl)\n\n[1] 150\n\ntable(pop(gl))\n\n\n A  B  C  D  E \n30 30 30 30 30 \n\n# SNP coding for individuals 1-5 and loci 1-8\nas.matrix(gl)[1:5, 1:8]\n\n  X1 X2 X3 X4 X5 X6 X7 X8\n1  1  2  1  2  2  2  1  2\n2  1  1  1  1  1  1  0  1\n3  2  0  2  0  1  1  1  1\n4  0  1  2  0  0  1  0  1\n5  1  2  1  2  2  2  1  0\n\n\nThe next step is to actually calculate genetic difference between individuals. We do this by measuring euclidean distance but it is worth remembering that there are a myriad of different distances we can use. There are five different options for the function we will using, gl.dist.ind, that may be worth exploring depending on the context of your data.\nThe distance measure for SNP genotypes can be one of:\n\nEuclidean Distance\nScaled Euclidean Distance\nSimple Mismatch Distance\nAbsolute Mismatch Distance\nCzekanowski (Manhattan) Distance\n\nBut lets stick with euclidean distance for now. Euclidean distance is quite simple it treats\npossum.gl\n\n# Calculate an Euclidean Distance Matrix on individuals\nD &lt;- gl.dist.ind(gl)\n\n\n\n\n\n\n\n# Represent visually as a heat map\ngl.plot.heatmap(D)\n\nWarning in rep(col, length.out = leaves_length): 'x' is NULL so the result will\nbe NULL\n\n\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\n\n\n\n\n\n\n\n\n\n\n# Undertake a PCA on the raw data\npc &lt;- gl.pcoa(gl, verbose = 3)\n\nStarting gl.pcoa \n  Processing genlight object with SNP data\n  Performing a PCA, individuals as entities, loci as attributes, SNP genotype as state\n\n\n\n\n\n\n\n\n\n  Ordination yielded 4 informative dimensions( broken-stick criterion) from 149 original dimensions\n    PCA Axis 1 explains 15.5 % of the total variance\n    PCA Axis 1 and 2 combined explain 30.8 % of the total variance\n    PCA Axis 1-3 combined explain 41.2 % of the total variance\nStarting gl.colors \nSelected color type 2 \nCompleted: gl.colors \n\n\n\n\n\n\n\n\n\nCompleted: gl.pcoa \n\n\n\n# Plot the first two dimensions of the PCA\npc_a1a2 &lt;- gl.pcoa.plot(pc,gl,pop.labels=\"legend\")\n\n\n\n\n\n\n\n# Plot the first and third dimensions of the PCA\npc_a1a3 &lt;- gl.pcoa.plot(pc,gl,xaxis=1,yaxis=3, pop.labels=\"legend\")\n\n\n\n\n\n\n\n\n\n\nSelect one cluster\n\n# Select only the data from one cluster in the primary PCA\ntemp &lt;- gl.drop.pop(gl, pop.list=c('D', 'A'))\n\nStarting gl.drop.pop \n  Processing genlight object with SNP data\n  Checking for presence of nominated populations, deleting them\n  Warning: Resultant dataset may contain monomorphic loci\n  Locus metrics not recalculated\nCompleted: gl.drop.pop \n\n# Plot the first two dimensions of the secondary PCA\npc &lt;- gl.pcoa(temp, verbose = 3)\n\nStarting gl.pcoa \n  Processing genlight object with SNP data\n  Performing a PCA, individuals as entities, loci as attributes, SNP genotype as state\n\n\n\n\n\n\n\n\n\n  Ordination yielded 2 informative dimensions( broken-stick criterion) from 89 original dimensions\n    PCA Axis 1 explains 22.9 % of the total variance\n    PCA Axis 1 and 2 combined explain 30.5 % of the total variance\n    PCA Axis 1-3 combined explain NA % of the total variance\nStarting gl.colors \nSelected color type 2 \nCompleted: gl.colors \n\n\n\n\n\n\n\n\n\nCompleted: gl.pcoa \n\npc_plot &lt;- gl.pcoa.plot(pc, temp,pop.labels=\"legend\")\n\nStarting gl.pcoa.plot \n  Processing an ordination file (glPca)\n  Processing genlight object with SNP data\n  Plotting populations identified by a legend\n  Preparing plot .... please wait\n\n\n\n\n\n\n\n\n\nCompleted: gl.pcoa.plot \n\n\n\n\n\nWhat can go wrong\nMissing data causes distortion, which can lead to misinterpretation.\ndartR, that uses the adgenet package for its pca, fills missing data with the global average.\nYou can choose alternative methods of filling in the missing data prior to running your pca using the gl.impute function.\nPCA is a hypothesis generating tool, not a tool for definitive decisions of the structure of populations.\nStructure variants can also turn up on a PCA, like an inversion.\nPCA is sample size dependent - but this is more for the top two dimensions not all the informative dimensions.\n\n\nStructure and FastStructure\nTo run STRUCTURE from within R, we need to install the non-GUI executable (the version without frontend) for your operating system [e.g windows, mac or linux]. You can download STRUCTURE for your OS from http://web.stanford.edu/group/pritchardlab/structure_software/release_versions/v2.3.4/html/structure.html.\nTo let R know where the executable is, you need to set the path to the executable. For example, under windows, if you have the executable in d:/programms/structure/structure.exe, you can use the command below.\n\n\nRunning STRUCTURE\n\nsrnoad &lt;- gl.run.structure(possums, k.range = 2:7, num.k.rep = 10, exec =\n                             './binaries/structure.exe',plot.out = FALSE,\n                           burnin=50, numreps=100, # this is just for a test run\n                         # burnin=50000, numreps=100000, # for robust results\n                           noadmix=FALSE)\n\nev &lt;- gl.evanno(srnoad)\n\nqmatnoad &lt;- gl.plot.structure(srnoad2, K=4, clumpak = TRUE)\n\n\ngm &lt;- gl.map.structure(qmat = qmatnoad, x = possums, K=3, scalex=1, scaley=0.5 )\n\n\n\n\n\n\n\nExercise: Study the results using different Ks and with/without admixture\n\n\n\n The above run was a structure run using the no-admixture model for a range of K=2:7. Study the results by plotting it for various Ks and try to interpret the results in the light of the simulated population structure.\nHow about trying it on your own data or the example data provided.\n\n\n\n\nsnmf\n\n\nPopclusture",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Identifying Population Structure</span>"
    ]
  },
  {
    "objectID": "session03.html#exercise",
    "href": "session03.html#exercise",
    "title": "3  Identifying Population Structure",
    "section": "Exercise",
    "text": "Exercise\nFun example on real data.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Identifying Population Structure</span>"
    ]
  },
  {
    "objectID": "session03.html#further-study",
    "href": "session03.html#further-study",
    "title": "3  Identifying Population Structure",
    "section": "Further Study",
    "text": "Further Study\nPdfs/links\n\nReadings\n• Evanno et al. 2005 – Detecting the number of clusters (ΔK).\n• Lawson et al. 2018 – How not to over-interpret STRUCTURE/ADMIXTURE plots.\n• Wang 2017 – Common pitfalls when using STRUCTURE.\n• Raj et al. 2014 – fastSTRUCTURE.\n• Frichot et al. 2014 – sNMF.\n• Wang 2022 – POPCLUSTER.\n• Kopelman et al. 2015 – CLUMPAK.\n• Jakobsson & Rosenberg 2007 – CLUMPP.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Identifying Population Structure</span>"
    ]
  },
  {
    "objectID": "session04.html",
    "href": "session04.html",
    "title": "4  Kinship, Pedigrees & Mating Recommendations",
    "section": "",
    "text": "Required packages\nSession Presenters\nlibrary(dartR.base)\nlibrary(dartR.data)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Kinship, Pedigrees & Mating Recommendations</span>"
    ]
  },
  {
    "objectID": "session04.html#session-content",
    "href": "session04.html#session-content",
    "title": "4  Kinship, Pedigrees & Mating Recommendations",
    "section": "Session Content",
    "text": "Session Content",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Kinship, Pedigrees & Mating Recommendations</span>"
    ]
  },
  {
    "objectID": "session04.html#further-study",
    "href": "session04.html#further-study",
    "title": "4  Kinship, Pedigrees & Mating Recommendations",
    "section": "Further Study",
    "text": "Further Study\n\nReadings",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Kinship, Pedigrees & Mating Recommendations</span>"
    ]
  },
  {
    "objectID": "session05.html",
    "href": "session05.html",
    "title": "5  Assigning Individuals to Populations",
    "section": "",
    "text": "Required packages\nSession Presenter\nlibrary(dartRverse)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Assigning Individuals to Populations</span>"
    ]
  },
  {
    "objectID": "session05.html#session-content",
    "href": "session05.html#session-content",
    "title": "5  Assigning Individuals to Populations",
    "section": "Session Content",
    "text": "Session Content\nThis is a workflow associated with Session on Population Assignment in the dartR workshop\n\n# We will first set the verbosity globally to level 3\ngl.set.verbosity(3)\n\nStarting gl.set.verbosity \n  Global verbosity set to: 3 \nCompleted: gl.set.verbosity \n\n\n\n# Read in the data set for the worked example\ngl &lt;- readRDS(\"./data/assignment_example1.Rdata\")\n# Familiarize yourself with its contents\ngl  \n\n ********************\n *** DARTR OBJECT ***\n ********************\n\n ** 835 genotypes,  20,688 SNPs , size: 57.3 Mb\n\n    missing data: 289548 (=1.68 %) scored as NA\n\n ** Genetic data\n   @gen: list of 835 SNPbin\n   @ploidy: ploidy of each individual  (range: 2-2)\n\n ** Additional data\n   @ind.names:  835 individual labels\n   @loc.names:  20688 locus labels\n   @loc.all:  20688 allele labels\n   @position: integer storing positions of the SNPs [within 69 base sequence]\n   @pop: population of each individual (group size range: 3-30)\n   @other: a list containing: loc.metrics, ind.metrics, latlon, loc.metrics.flags, verbose, history \n    @other$ind.metrics: id, pop, lat, lon, sex, maturity, collector, location, basin, drainage, service, plate_location \n    @other$loc.metrics: AlleleID, CloneID, AlleleSequence, SNP, SnpPosition, CallRate, OneRatioRef, OneRatioSnp, FreqHomRef, FreqHomSnp, FreqHets, PICRef, PICSnp, AvgPIC, AvgCountRef, AvgCountSnp, RepAvg, clone, uid, rdepth, monomorphs, maf, OneRatio, PIC, TrimmedSequence \n   @other$latlon[g]: coordinates for all individuals are attached\n\nnLoc(gl)\n\n[1] 20688\n\nnInd(gl)\n\n[1] 835\n\nnPop(gl)\n\n[1] 81\n\n# Display a list of populations and sample sizes\ntable(pop(gl))\n\n\n         Brisbane          Burdekin           Burnett          Clarence \n               10                10                11                10 \n     Cooper_Alvin      Cooper_Cully  Cooper_Eulbertie        Dumaresque \n               10                10                10                10 \nFitzroy_Alligator  Fitzroy_Carnavan  Fitzroy_Fairburn     Fraser_Island \n               10                10                10                10 \n           Hunter     EmmacJohnWari     EmmacMaclGeor              Mary \n               10                10                11                10 \n     EmmacMDBBarr      EmmacMDBBarw     EmmacMDBBooth      EmmacMDBBowm \n               10                10                 9                10 \n     EmmacMDBBurr      EmmacMDBCond      EmmacMDBCudg  EmmacMDBDarlBour \n               10                10                10                10 \n EmmacMDBDarlWeth      EmmacMDBDart      EmmacMDBEulo      EmmacMDBForb \n               10                10                10                10 \n     EmmacMDBGoul        GurraGurra      EmmacMDBGwyd      EmmacMDBLach \n               10                10                10                10 \n     EmmacMDBLodd      EmmacMDBMaci      EmmacMDBMoon  EmmacMDBMurrGunb \n               10                10                10                10 \n EmmacMDBMurrLock  EmmacMDBMurrMorg  EmmacMDBMurrMung  EmmacMDBMurrMurr \n               10                10                10                10 \n EmmacMDBMurrTink EmmacMDBMurrYarra      EmmacMDBOven  EmmacMDBParoBiny \n               10                10                10                10 \n     EmmacMDBPind      EmmacMDBSanf      EmmacMDBToon          Normanby \n               10                10                11                11 \n             Pine     EmmacRichCasi         EmmacRoss      EmmacTweeUki \n               10                10                10                10 \n     EmsubBamuAli     EmsubBamuAwab     EmsubMorehead      EmsubFlyGuka \n               10                 9                16                10 \n     EmsubFlyJikw      EmsubJardine       EmsubKerema       EmsubKikori \n               30                16                10                 4 \n       EmworRoper        EmtanBlyth      EmtanFinniss     EmtanHolrChai \n               11                10                 7                10 \n    EmtanMitchell     EmtanMitcMitc     EmtanPascFarm      EmtanWenlock \n                9                 3                 9                10 \n        EmvicDaly     EmvicDrysdale        Fitzroy_WA     EmvicIsdeBell \n               10                10                10                12 \n    EmvicKingMool          EmvicOrd     EmworClavPung         EmworDaly \n               10                18                10                10 \n    EmworDalySlei     EmworLeicAlex     EmworLimmNath     EmworLiveMann \n                7                10                10                 9 \n    EmworNichGreg \n               12 \n\n\n\n\n\n\n\n\nNote that several populations have sample sizes less than 10 and will be discarded during the analysis\n\n\n\n\n\n\n\nAnalysis 1: Assignment by genotype likelihood\n\n#gen.result&lt;-gl.assign.on.genotype(gl, unknown=\"AA011731\", nmin=10)\n\n\n\nAnalysis 2: Assignment by Private Alleles\n\n# pa.result &lt;- gl.assign.pa(gl, unknown=\"AA011731\", nmin=10, alpha=0.05)\npa.result &lt;- gl.assign.pa(gl, unknown=\"AA011731\", nmin=10)\n\nStarting gl.assign.pa \n  Processing genlight object with SNP data\n  Discarding 9 populations with sample size &lt; 10 :\nEmmacMDBBooth, EmsubBamuAwab, EmsubKikori, EmtanFinniss, EmtanMitchell, EmtanMitcMitc, EmtanPascFarm, EmworDalySlei, EmworLiveMann \n                 pop count    Z-score  p-value assign\n16              Mary    81 -0.1692350 0.567194    yes\n3            Burnett    77  0.2743299 0.391916    yes\n48              Pine   167  1.1555039 0.123942    yes\n21      EmmacMDBCond   785  2.0204271 0.021670    yes\n46      EmmacMDBToon   668  2.7347470 0.003121     no\n15     EmmacMaclGeor  1040  3.4791497 0.000252     no\n62         EmvicDaly  1284  3.5437788 0.000197     no\n19      EmmacMDBBowm   992  3.6051586 0.000156     no\n72     EmworNichGreg  1260  3.8784997 0.000053     no\n58        EmworRoper  1273  4.1008215 0.000021     no\n24  EmmacMDBDarlWeth   865  4.8762430 0.000001     no\n1           Brisbane   523 17.1445337 0.000000     no\n2           Burdekin   821 15.7683126 0.000000     no\n4           Clarence   915 14.1798931 0.000000     no\n5       Cooper_Alvin   992 15.6406240 0.000000     no\n6       Cooper_Cully  1008 18.1191005 0.000000     no\n7   Cooper_Eulbertie  1001  9.1930282 0.000000     no\n8         Dumaresque   929 31.3868949 0.000000     no\n9  Fitzroy_Alligator   306 11.4289937 0.000000     no\n10  Fitzroy_Carnavan   339 10.2951686 0.000000     no\n11  Fitzroy_Fairburn   303  7.6467045 0.000000     no\n12     Fraser_Island   457  5.0064421 0.000000     no\n13            Hunter  1340 12.4578521 0.000000     no\n14     EmmacJohnWari   893 11.1739703 0.000000     no\n17      EmmacMDBBarr   940 26.7349588 0.000000     no\n18      EmmacMDBBarw   937 26.1751262 0.000000     no\n20      EmmacMDBBurr  1025 15.2447327 0.000000     no\n22      EmmacMDBCudg   952 18.4925912 0.000000     no\n23  EmmacMDBDarlBour   916 13.1037035 0.000000     no\n25      EmmacMDBDart  1079 14.9852921 0.000000     no\n26      EmmacMDBEulo   639  6.1130987 0.000000     no\n27      EmmacMDBForb  1051  5.2168208 0.000000     no\n28      EmmacMDBGoul   922 12.4532508 0.000000     no\n29        GurraGurra   957 13.0155533 0.000000     no\n30      EmmacMDBGwyd   940 23.3109909 0.000000     no\n31      EmmacMDBLach  1053 17.7866486 0.000000     no\n32      EmmacMDBLodd   950 16.0172441 0.000000     no\n33      EmmacMDBMaci   925 15.1899478 0.000000     no\n34      EmmacMDBMoon   928 21.5894040 0.000000     no\n35  EmmacMDBMurrGunb   898  7.6464411 0.000000     no\n36  EmmacMDBMurrLock   959  8.1186128 0.000000     no\n37  EmmacMDBMurrMorg   922 15.3803498 0.000000     no\n38  EmmacMDBMurrMung   946 15.3622303 0.000000     no\n39  EmmacMDBMurrMurr   958 27.7218281 0.000000     no\n40  EmmacMDBMurrTink   912 11.1714406 0.000000     no\n41 EmmacMDBMurrYarra   950 27.2732611 0.000000     no\n42      EmmacMDBOven   949 27.2094137 0.000000     no\n43  EmmacMDBParoBiny   975 11.8093091 0.000000     no\n44      EmmacMDBPind  1037 25.1472989 0.000000     no\n45      EmmacMDBSanf   995 20.6254532 0.000000     no\n47          Normanby  1014  8.9353965 0.000000     no\n49     EmmacRichCasi   727 23.4264098 0.000000     no\n50         EmmacRoss   853 16.4775772 0.000000     no\n51      EmmacTweeUki   591 10.7132631 0.000000     no\n52      EmsubBamuAli  1286 23.2269725 0.000000     no\n53     EmsubMorehead  1238 21.7595831 0.000000     no\n54      EmsubFlyGuka  1268 25.9689306 0.000000     no\n55      EmsubFlyJikw  1226 17.9295179 0.000000     no\n56      EmsubJardine  1287 10.9701686 0.000000     no\n57       EmsubKerema  1370  5.1264437 0.000000     no\n59        EmtanBlyth  1396  8.9673202 0.000000     no\n60     EmtanHolrChai  1361 10.7419476 0.000000     no\n61      EmtanWenlock  1351 10.6423539 0.000000     no\n63     EmvicDrysdale  1365 13.7459176 0.000000     no\n64        Fitzroy_WA  1372 10.2841962 0.000000     no\n65     EmvicIsdeBell  1355 14.7314585 0.000000     no\n66     EmvicKingMool  1363 24.4944007 0.000000     no\n67          EmvicOrd  1333 12.5867638 0.000000     no\n68     EmworClavPung  1299 22.5017244 0.000000     no\n69         EmworDaly  1307  5.2935238 0.000000     no\n70     EmworLeicAlex  1324 15.9637009 0.000000     no\n71     EmworLimmNath  1322  5.7857267 0.000000     no\n  Warning: parameter by must be either 'join.by.ind' or 'join.by.loc', set to default 'join.by.loc'\nCompleted: gl.assign.pa \n\n\n\n\nAnalysis 3: Assignment by PCA\n\n#pca_pa_result &lt;-gl.assign.pca(pa.result, unknown=\"AA011731\")\n\n\n\nAnalysis 4: Assignment by Mahalanobis Distances\n\n#mahal_result &lt;- gl.assign.mahalanobis(pa.result,unknown=\"AA011731\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Assigning Individuals to Populations</span>"
    ]
  },
  {
    "objectID": "session05.html#exercise",
    "href": "session05.html#exercise",
    "title": "5  Assigning Individuals to Populations",
    "section": "Exercise",
    "text": "Exercise\n\nThe data\n\ngl\n\n ********************\n *** DARTR OBJECT ***\n ********************\n\n ** 835 genotypes,  20,688 SNPs , size: 57.3 Mb\n\n    missing data: 289548 (=1.68 %) scored as NA\n\n ** Genetic data\n   @gen: list of 835 SNPbin\n   @ploidy: ploidy of each individual  (range: 2-2)\n\n ** Additional data\n   @ind.names:  835 individual labels\n   @loc.names:  20688 locus labels\n   @loc.all:  20688 allele labels\n   @position: integer storing positions of the SNPs [within 69 base sequence]\n   @pop: population of each individual (group size range: 3-30)\n   @other: a list containing: loc.metrics, ind.metrics, latlon, loc.metrics.flags, verbose, history \n    @other$ind.metrics: id, pop, lat, lon, sex, maturity, collector, location, basin, drainage, service, plate_location \n    @other$loc.metrics: AlleleID, CloneID, AlleleSequence, SNP, SnpPosition, CallRate, OneRatioRef, OneRatioSnp, FreqHomRef, FreqHomSnp, FreqHets, PICRef, PICSnp, AvgPIC, AvgCountRef, AvgCountSnp, RepAvg, clone, uid, rdepth, monomorphs, maf, OneRatio, PIC, TrimmedSequence \n   @other$latlon[g]: coordinates for all individuals are attached\n\n# The unknown\nUnknown = \"AA046092\"\n# Preliminaries\npopNames(gl)\n\n [1] \"Brisbane\"          \"Burdekin\"          \"Burnett\"          \n [4] \"Clarence\"          \"Cooper_Alvin\"      \"Cooper_Cully\"     \n [7] \"Cooper_Eulbertie\"  \"Dumaresque\"        \"Fitzroy_Alligator\"\n[10] \"Fitzroy_Carnavan\"  \"Fitzroy_Fairburn\"  \"Fraser_Island\"    \n[13] \"Hunter\"            \"EmmacJohnWari\"     \"EmmacMaclGeor\"    \n[16] \"Mary\"              \"EmmacMDBBarr\"      \"EmmacMDBBarw\"     \n[19] \"EmmacMDBBooth\"     \"EmmacMDBBowm\"      \"EmmacMDBBurr\"     \n[22] \"EmmacMDBCond\"      \"EmmacMDBCudg\"      \"EmmacMDBDarlBour\" \n[25] \"EmmacMDBDarlWeth\"  \"EmmacMDBDart\"      \"EmmacMDBEulo\"     \n[28] \"EmmacMDBForb\"      \"EmmacMDBGoul\"      \"GurraGurra\"       \n[31] \"EmmacMDBGwyd\"      \"EmmacMDBLach\"      \"EmmacMDBLodd\"     \n[34] \"EmmacMDBMaci\"      \"EmmacMDBMoon\"      \"EmmacMDBMurrGunb\" \n[37] \"EmmacMDBMurrLock\"  \"EmmacMDBMurrMorg\"  \"EmmacMDBMurrMung\" \n[40] \"EmmacMDBMurrMurr\"  \"EmmacMDBMurrTink\"  \"EmmacMDBMurrYarra\"\n[43] \"EmmacMDBOven\"      \"EmmacMDBParoBiny\"  \"EmmacMDBPind\"     \n[46] \"EmmacMDBSanf\"      \"EmmacMDBToon\"      \"Normanby\"         \n[49] \"Pine\"              \"EmmacRichCasi\"     \"EmmacRoss\"        \n[52] \"EmmacTweeUki\"      \"EmsubBamuAli\"      \"EmsubBamuAwab\"    \n[55] \"EmsubMorehead\"     \"EmsubFlyGuka\"      \"EmsubFlyJikw\"     \n[58] \"EmsubJardine\"      \"EmsubKerema\"       \"EmsubKikori\"      \n[61] \"EmworRoper\"        \"EmtanBlyth\"        \"EmtanFinniss\"     \n[64] \"EmtanHolrChai\"     \"EmtanMitchell\"     \"EmtanMitcMitc\"    \n[67] \"EmtanPascFarm\"     \"EmtanWenlock\"      \"EmvicDaly\"        \n[70] \"EmvicDrysdale\"     \"Fitzroy_WA\"        \"EmvicIsdeBell\"    \n[73] \"EmvicKingMool\"     \"EmvicOrd\"          \"EmworClavPung\"    \n[76] \"EmworDaly\"         \"EmworDalySlei\"     \"EmworLeicAlex\"    \n[79] \"EmworLimmNath\"     \"EmworLiveMann\"     \"EmworNichGreg\"    \n\ngl2 &lt;- gl.keep.pop(gl, pop.list=c(\"EmsubBamuAli\", \"EmsubFlyGuka\", \"EmsubFlyJikw\",\n                                  \"EmsubJardine\", \"EmsubKerema\", \"EmsubMorehead\"))\n\nStarting gl.keep.pop \n  Processing genlight object with SNP data\n  Checking for presence of nominated populations\n  Retaining only populations EmsubBamuAli, EmsubFlyGuka, EmsubFlyJikw, EmsubJardine, EmsubKerema, EmsubMorehead \n  Locus metrics not recalculated\n  Summary of recoded dataset\n  Original no. of populations 81 \n     No. of populations deleted: 75 \n  Final No. of Populations: 6 \n  Original No. of loci: 20688 \n    Deleted monomorphic loci arising (if mono.rm=TRUE): 0 \n  Final No. of Loci: 20688 \n  Original No. of individuals: 835 \n    Deleted: 743 \n  Final No. of individuals: 92 \nCompleted: gl.keep.pop \n\n# Knock yourself out",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Assigning Individuals to Populations</span>"
    ]
  },
  {
    "objectID": "session05.html#further-study",
    "href": "session05.html#further-study",
    "title": "5  Assigning Individuals to Populations",
    "section": "Further Study",
    "text": "Further Study\n\nReadings",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Assigning Individuals to Populations</span>"
    ]
  },
  {
    "objectID": "session06.html",
    "href": "session06.html",
    "title": "6  SNP Panel Selection & Simulations for Conservation",
    "section": "",
    "text": "Required packages\nSession Presenters\nlibrary(dartRverse)\nlibrary(knitr)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>SNP Panel Selection & Simulations for Conservation</span>"
    ]
  },
  {
    "objectID": "session06.html#session-content",
    "href": "session06.html#session-content",
    "title": "6  SNP Panel Selection & Simulations for Conservation",
    "section": "Session Content",
    "text": "Session Content",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>SNP Panel Selection & Simulations for Conservation</span>"
    ]
  },
  {
    "objectID": "session06.html#session-content-1",
    "href": "session06.html#session-content-1",
    "title": "6  SNP Panel Selection & Simulations for Conservation",
    "section": "Session Content",
    "text": "Session Content\nThis session will cover the selection of SNP panels for conservation genetics. We will explore how to select SNPs that are informative for population structure, inbreeding, and other conservation-related analyses. The session will include practical exercises using R and the dartRverse packages.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>SNP Panel Selection & Simulations for Conservation</span>"
    ]
  },
  {
    "objectID": "session06.html#selecting-panels",
    "href": "session06.html#selecting-panels",
    "title": "6  SNP Panel Selection & Simulations for Conservation",
    "section": "Selecting panels",
    "text": "Selecting panels\nTo select panels we will use an example dataset of a fish species as introduced by the slides. The idea is to select a SNP panel that helps to monitor the species. Key aspects to consider a panel is to think about the following:\n\nWhat is the purpose of the panel? (estimates of Ne, Ho, Fst or all of the above)\nHow many SNPs can you afford to sequence?\n\nOnce you decided on those aspects, you can use the dartRverse package to select a panel of SNPs. The package provides functions to - 1. filter SNPs based on various criteria, mainly for quality - 2. filter SNPs in accordance lab consideration (mainly can we get reliable sequences from the SNPs) - 3. select of the remaining SNPs an informative subsample for the purpose of the panel\n\nExample data\nThe first two decisions are that we would like to create a SNP panel that is informative for population structure (Fst) and we have resources to develop a panel of 50 SNPs.\nLets load our example data\n\nrfbe &lt;- readRDS(\"./data/rfbe.rds\")\ngl.report.basics(rfbe)\n\nStarting gl.report.basics \n\nSUMMARY STATISTICS\n\nDatatype: SNP \nLoci: 9849 \nIndividuals: 383 \nPopulations: 16 \n\nAverage Read Depth: 28.70085\nValues: 3772167 \n           0    1    2   NA\npercent 65.5 22.0 11.2  1.3\n\nMonomorphic Loci: 2 \nLoci all NA: 0 \nIndividuals all NA: 0 \n\nSample Sizes:\n\n    BHA_A2       E504       E508       E509       E518       NW30       NW70 \n        19         19         20         20         20         20         20 \n      NW72       NW80 PJTub1.2.3   PJTub4.5     PJTub6       SE60       SW10 \n        10         10         64         51         33         20         19 \n      SW20       SW60 \n        18         20 \n\nLoci all NA across individuals by Population\n BHA_A2 E504 E508 E509 E518 NW30 NW70 NW72 NW80 PJTub1.2.3 PJTub4.5 PJTub6 SE60\n      0    0    0    0    0    0    0    0    0          0        0      0    0\n SW10 SW20 SW60\n    0    0    0\n\nIndividuals all NA across loci by Population\n BHA_A2 E504 E508 E509 E518 NW30 NW70 NW72 NW80 PJTub1.2.3 PJTub4.5 PJTub6 SE60\n      0    0    0    0    0    0    0    0    0          0        0      0    0\n SW10 SW20 SW60\n    0    0    0\n\nCompleted: gl.report.basics \n\n\n\n\nFiltering for quality\nSo we have 9849 SNPs (they are prefiltered for quality already). You can check the looking at callrate, rdepth). So we already have high quality SNPs, with a low missing value rate across loci.\nour main aim is to find a panel of 50 SNPs that are informative for population structure (Fst).\nTo be able to calculate Fst reliably we decided to have a threshold of more than 10 individuals per population so we filter the SNPs for a minimum of 11 individuals per population.\n\ntt &lt;- table(pop(rfbe))\npop20 &lt;- names(tt)[tt&gt;10]\n\nrfbe20 &lt;- gl.keep.pop(rfbe, pop.list=pop20)\n\nStarting gl.keep.pop \n  Processing genlight object with SNP data\n  Checking for presence of nominated populations\n  Retaining only populations BHA_A2, E504, E508, E509, E518, NW30, NW70, PJTub1.2.3, PJTub4.5, PJTub6, SE60, SW10, SW20, SW60 \n  Warning: Resultant dataset may contain monomorphic loci\n  Locus metrics not recalculated\nCompleted: gl.keep.pop \n\nkable(table(pop(rfbe20)))\n\n\n\n\nVar1\nFreq\n\n\n\n\nBHA_A2\n19\n\n\nE504\n19\n\n\nE508\n20\n\n\nE509\n20\n\n\nE518\n20\n\n\nNW30\n20\n\n\nNW70\n20\n\n\nPJTub1.2.3\n64\n\n\nPJTub4.5\n51\n\n\nPJTub6\n33\n\n\nSE60\n20\n\n\nSW10\n19\n\n\nSW20\n18\n\n\nSW60\n20\n\n\n\n\n\nBecause we have filtered the data by individual we want to make sure we have not created missing data in any of the populations and we want to filter also finally for minor allele frequency (MAF) using the count option as we want to make sure we have high quality SNPs which are not spurious in terms of aonly occuring in very low frequency.\nYou can use the report function before filtering to test their effect.\n\nrfbe20_1 &lt;- gl.filter.allna(rfbe20, by.pop = T)\n\nStarting gl.filter.allna \n  Identifying and removing loci that are all missing (NA) \n                    in any one population\n  Deleting loci that are all missing (NA) in any one population\n  Warning: no loci listed to delete! Genlight object returned unchanged\nCompleted: gl.filter.allna \n\nrfbe20_2 &lt;- gl.filter.callrate(rfbe20_1, threshold=0.99)\n\nStarting gl.filter.callrate \n  Processing genlight object with SNP data\n  Warning: Data may include monomorphic loci in call rate \n                    calculations for filtering\n  Recalculating Call Rate\n  Removing loci based on Call Rate, threshold = 0.99 \n\n\n\n\n\n\n\n\n\nCompleted: gl.filter.callrate \n\nrfbe20_3 &lt;- gl.filter.maf(rfbe20_2, threshold = 5, by.pop = FALSE)\n\nStarting gl.filter.maf \n  Processing genlight object with SNP data\n  Warning: genlight object contains monomorphic loci\n  Removing loci with MAF &lt; 0.0068870523415978 over all the dataset\n                and recalculating FreqHoms and FreqHets\n\n\n\n\n\n\n\n\n\nCompleted: gl.filter.maf \n\nnLoc(rfbe20_3)\n\n[1] 6815\n\n\nThis should result in high quality SNPs.\nIf you have a reference genome you would like to filter for SNPs that are 100% aligned and of a certain length. For example you want to make sure the sequences you have are at least of a certain length.\n\n\nFilter SNPs with sequences that are less than 30 characters long\n\nindex &lt;- nchar(as.character(rfbe20_3@other$loc.metrics$TrimmedSequence))&gt;29\nrfbe20_4 &lt;- rfbe20_3[, index]\n\nAs we have a reference genome we include another step, manly to filter for SNPs that are aligned very well to the reference genome. This is important and can help if your SNP is towards the beginning of your sequence but you want to design primers that have the SNP more towards the middle of a sequence.\n\n\nblast to find SNPs\n\n#takes a while to run, hence load the pre run data set\n#rfbe20_5 &lt;- gl.blast(rfbe20_4,ref_genome = \"d:/bernd/r/Elise_pansnp/final.genome.scf.fasta\", task = \"blastn\", number_of_threads = 10 )\n#saveRDS(rfbe20_5, \"d:/bernd/r/Elise_pansnp/rfbe20_5_blast.rds\")\n\nrfbe20_5 &lt;- readRDS(\"./data/rfbe20_5_blast.rds\")\n\nWe can now filter the SNPs based on the blast results.\n\n#bitscore &gt;=100\nindex &lt;- rfbe20_5@other$loc.metrics$bitscore &gt;= 100\nindex &lt;- ifelse(is.na(index), FALSE, index)\nrfbe20_6 &lt;- rfbe20_5[,index]\n\nDepending on your lab requirements you might want to filter for SNPs that are not too close to close to the beginning of the sequence. As we have a reference genome, that allows us to extend sequences, we do not do that here. In case you are interested we are currently have a semi-developed script that allows to do this, but it is not yet part of the package.\n\n\nSelecting informative SNPs\nWe can now selected a subsample of SNPs using several different methods. Depending on the aim of your panel you might want to select SNPs that are informative for population structure (Fst) or inbreeding (Ho). It turns out that the dapc method is a good method to select SNPs that are informative for population structure. The code below uses this method to select 50 SNPs.\n###run gl.select.panel\n\n#takes a while to run\npanel &lt;- gl.select.panel(rfbe20_6, method=\"dapc\", nl = 50)\n\nStarting gl.select.panel \n  Processing genlight object with SNP data\n\n\nFound more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics'\n\n\nAlso defined by 'spam'\n\n\nFound more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics'\n\n\nAlso defined by 'spam'\n\n\nStarting gl.keep.loc \n  Processing genlight object with SNP data\n  List of loci to keep has been specified\n  Deleting all but the specified loci\nCompleted: gl.keep.loc \nCompleted: gl.select.panel \n\nnLoc(panel)\n\n[1] 66\n\n\n\n\nrun gl.check.panel\n\noutdapc &lt;- gl.check.panel(panel, rfbe20_6, parameter = \"Fst\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nAs we can see Fst values between populations is nicely reconstructed by selecting only 50 SNPs based on the dapc method. We can compare it to a random selection:\n\npanel_random &lt;- gl.select.panel(rfbe20_6, method=\"random\", nl = 50)\n\nStarting gl.select.panel \n  Processing genlight object with SNP data\nStarting gl.keep.loc \n  Processing genlight object with SNP data\n  List of loci to keep has been specified\n  Deleting all but the specified loci\nCompleted: gl.keep.loc \nCompleted: gl.select.panel \n\noutrandom &lt;- gl.check.panel(panel_random, rfbe20_6, parameter = \"Fst\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nNot as good so it pays off.\n\n\n\n\n\n\nExercise\n\n\n\n\nNow it is time for you to select a SNP panel. You can try differen methods and compare them. E.g How good is a random panel, or one based on PIC values.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>SNP Panel Selection & Simulations for Conservation</span>"
    ]
  },
  {
    "objectID": "session06.html#further-study",
    "href": "session06.html#further-study",
    "title": "6  SNP Panel Selection & Simulations for Conservation",
    "section": "Further Study",
    "text": "Further Study\n\nReadings",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>SNP Panel Selection & Simulations for Conservation</span>"
    ]
  },
  {
    "objectID": "session07.html",
    "href": "session07.html",
    "title": "7  Simulations for Conservation",
    "section": "",
    "text": "Required packages\nSession Presenters\nlibrary(dartR.base)\nlibrary(dartR.data)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Simulations for Conservation</span>"
    ]
  },
  {
    "objectID": "session07.html#session-content",
    "href": "session07.html#session-content",
    "title": "7  Simulations for Conservation",
    "section": "Session Content",
    "text": "Session Content",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Simulations for Conservation</span>"
    ]
  },
  {
    "objectID": "session07.html#further-study",
    "href": "session07.html#further-study",
    "title": "7  Simulations for Conservation",
    "section": "Further Study",
    "text": "Further Study\n\nReadings",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Simulations for Conservation</span>"
    ]
  },
  {
    "objectID": "session08.html",
    "href": "session08.html",
    "title": "8  Bonus! Sex Linked Markers",
    "section": "",
    "text": "Required packages\nSession Presenters\nlibrary(dartRverse)\nlibrary(dartR.sexlinked)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Bonus! Sex Linked Markers</span>"
    ]
  },
  {
    "objectID": "session08.html#session-content",
    "href": "session08.html#session-content",
    "title": "8  Bonus! Sex Linked Markers",
    "section": "Session Content",
    "text": "Session Content",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Bonus! Sex Linked Markers</span>"
    ]
  },
  {
    "objectID": "session08.html#session-content-1",
    "href": "session08.html#session-content-1",
    "title": "8  Bonus! Sex Linked Markers",
    "section": "Session Content",
    "text": "Session Content\nIn this tutorial you will read about sex-linked loci and do two excercises.\n\nIntroduction\nExercises\n\nExercise 1: Identifying sex-linked loci and using them for sexing\nExercise 2: Observing the effects of not removing sex-linked loci on population genetic analyses\n\n2.1. Differences in PCoA\n2.2. Differences in genetic diversity and fixation indices\n\n\nReferences",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Bonus! Sex Linked Markers</span>"
    ]
  },
  {
    "objectID": "session08.html#introduction",
    "href": "session08.html#introduction",
    "title": "8  Bonus! Sex Linked Markers",
    "section": "Introduction",
    "text": "Introduction\nMany population genetic studies assume autosomal loci. Therefore, it is best practice to exclude sex-linked loci from SNP datasets. Failing to remove these loci can lead to skewed estimates of genetic diversity—such as heterozygosity, fixation indices (like FIS), polymorphism, and allelic richness—especially when the sample has an uneven sex ratio or when there are differences in diversity between sex chromosomes and autosomes. Identifying population structure also improves when sex-linked loci are excluded, since these markers can obscure patterns shaped by evolutionary forces like gene flow, selection, and drift. Similarly, parentage analyses, which rely on autosomal Mendelian inheritance, can be compromised by sex-linked loci, leading to apparent mismatches between true parent-offspring pairs. Therefore, accurately identifying sex-linked loci is essential for reliable genetic analysis and informed management decisions.\nOn the other hand, identifying sex-linked markers can be valuable for determining the sex of individuals in species without sexual dimorphism, and for uncovering sex-specific ecological or evolutionary patterns.\nSex-linked markers are those that are inherited differently between the sexes, usually because they are present in sex chromosomes. In animal species, the two most common chromosomal sex-determination systems are ZW and XY. In the ZW system, typical for birds and some reptiles and insects, females are heterogametic (ZW) and males are homogametic (ZZ). On the contrary, in an XY system, typical for mammals and some insects, males are the heterogametic sex with one X and one Y chromosome, and females are the homogametic sex with two X chromosomes.\nSex-linked markers can be classified into three types (Figure 1):\n\nW-linked or Y-linked loci\nZ-linked or X-linked loci\nGametologs\n\n\n\n\nFigure 1. Sex-linked markers in ZW sex-determination systems",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Bonus! Sex Linked Markers</span>"
    ]
  },
  {
    "objectID": "session08.html#exercises",
    "href": "session08.html#exercises",
    "title": "8  Bonus! Sex Linked Markers",
    "section": "Exercises",
    "text": "Exercises\nThe following exercises can be done with the dataset included in the dartR.sexlinked package (that of the beautiful Eastern Yellow Robin, EYR; Figure 2; Robledo-Ruiz et al. 2023) or on your own data!\n\n\n\nFigure 2. Eastern Yellow Robin. Isn’t it a cutie?",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Bonus! Sex Linked Markers</span>"
    ]
  },
  {
    "objectID": "session08.html#exercise-1-identify-sex-linked-loci-and-use-them-for-sexing",
    "href": "session08.html#exercise-1-identify-sex-linked-loci-and-use-them-for-sexing",
    "title": "8  Bonus! Sex Linked Markers",
    "section": "Exercise 1: Identify sex-linked loci and use them for sexing ",
    "text": "Exercise 1: Identify sex-linked loci and use them for sexing \nImagine you have a genetic dataset in which you have the sexes of most individuals but not all. You are also not sure about the sexes you have recorded for some individuals during fieldwork (human error exists!). Because you know a lot about sex-linked loci, you want to see if you can identify some in order to help you double-check sexes.\n\nLoad data\nStart by calling the dataset and exploring it.\n\ndata(\"EYR\")\nEYR                   # Explore the dataset\n\n ********************\n *** DARTR OBJECT ***\n ********************\n\n ** 782 genotypes,  1,000 SNPs , size: 20.2 Mb\n\n    missing data: 147031 (=18.8 %) scored as NA\n\n ** Genetic data\n   @gen: list of 782 SNPbin\n   @ploidy: ploidy of each individual  (range: 2-2)\n\n ** Additional data\n   @ind.names:  782 individual labels\n   @loc.names:  1000 locus labels\n   @loc.all:  1000 allele labels\n   @position: integer storing positions of the SNPs [within 69 base sequence]\n   @pop: population of each individual (group size range: 52-421)\n   @other: a list containing: loc.metrics, ind.metrics, loc.metrics.flags, verbose, history \n    @other$ind.metrics: id, pop, sex, Mito, service, plate_location \n    @other$loc.metrics: AlleleID, CloneID, AlleleSequence, TrimmedSequence, Chrom_Yellow_robin_HiC_v2, ChromPos_Yellow_robin_HiC_v2, AlnCnt_Yellow_robin_HiC_v2, AlnEvalue_Yellow_robin_HiC_v2, SNP, SnpPosition, CallRate, OneRatioRef, OneRatioSnp, FreqHomRef, FreqHomSnp, FreqHets, PICRef, PICSnp, AvgPIC, AvgCountRef, AvgCountSnp, RepAvg, clone, uid, rdepth, maf \n   @other$latlon[g]: no coordinates attached\n\nEYR@n.loc             # Number of SNPs\n\n[1] 1000\n\nlength(EYR@ind.names) # Number of individuals\n\n[1] 782\n\n\n\n\nSearch for sex-linked loci\nThe function gl.report.sexlinked identifies sex-linked and autosomal loci present in a SNP dataset (genlight object) using individuals with known sex. It identifies five types of loci: w-linked or y-linked, sex-biased, z-linked or x-linked, gametologous and autosomal.\n\n\n\n\n\n\nNote\n\n\n\nThe genlight object must contain in gl@other$ind.metrics a column named id, and a column named sex in which individuals with known-sex are assigned M for male, or F for female. The function ignores individuals that are assigned anything else or nothing at all (unknown-sex).\n\n\nCheck that ind.metrics has the necessary columns:\n\nknitr::kable(EYR@other$ind.metrics[1:10,])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nid\npop\nsex\nMito\nservice\nplate_location\n\n\n\n\n024-96401\n024-96401\nCrusoe\nM\nB\nDYro17-3039\n2-D9\n\n\n024-96401b\n024-96401b\nCrusoe\nM\nB\nDYro21-6107\n3-D3\n\n\n024-96402\n024-96402\nCrusoe\nF\nA\nDYro17-3039\n2-C9\n\n\n024-96403\n024-96403\nCrusoe\nM\nB\nDYro17-3039\n2-B9\n\n\n024-96404\n024-96404\nCrusoe\nM\nA\nDYro17-3039\n2-A9\n\n\n024-96405\n024-96405\nMuckleford\nM\nA\nDYro17-3039\n2-D6\n\n\n024-96406\n024-96406\nCrusoe\nF\nA\nDYro17-3039\n2-H8\n\n\n024-96407\n024-96407\nCrusoe\nF\nA\nDYro17-3039\n2-G8\n\n\n024-96408\n024-96408\nCrusoe\nM\nA\nDYro17-3039\n2-F8\n\n\n024-96410\n024-96410\nMuckleford\nM\nA\nDYro17-3039\n1-E9\n\n\n\n\n\nonly showing first 10 rows\nRun the function to identify sex-linked loci in the EYR genlight object:\n\nout &lt;- gl.report.sexlinked(EYR, system = \"zw\")\n\nStarting gl.report.sexlinked \n  Processing genlight object with SNP data\n\n\nDetected 352 females and 429 males.\n\n\nStarting phase 1. May take a while...\n\n\nBuilding call rate plot.\n\n\nDone building call rate plot.\n\n\nStarting phase 2. May take a while...\n\n\nBuilding heterozygosity plot.\n\n\nDone building heterozygosity plot.\n\n\n**FINISHED** Total of analyzed loci: 1000.\nFound 150 sex-linked loci:\n   16 W-linked loci (yellow)\n   82 sex-biased loci (blue)\n   32 Z-linked loci (orange)\n   20 gametologs (green).\nAnd 850 autosomal loci (grey).\n\n\n\n\n\n\n\n\n\nCompleted: gl.report.sexlinked \n\n\n\n\n\n\n\n\nNote\n\n\n\nQuestion: How many males and females does the dataset contain?\nQuestion: How many sex-linked loci were found?\nQuestion: Why are there two plots?\nQuestion: What does each point in the plots represent?\nQuestion: What do the colours in the plots mean? Look at Figure 1 for a hint. What about the blue dots?\n\n\n\n\nSexing individuals with unknown sex\nThe dartR.sexlinked package has more functions that can be useful when a dataset has some missing sex data.\n\n\n\n\n\n\nNote\n\n\n\nQuestion: How many individuals does the EYR genlight object contain?\nQuestion: How many males and females were detected by function gl.report.sexlinked? Are there individuals with unknown sex?\n\n\nFind the id of the individual that is not sexed:\n\nEYR@other$ind.metrics[!(EYR@other$ind.metrics$sex %in% c(\"M\", \"F\")), ]\n\n                 id        pop sex Mito     service plate_location\n024-96417 024-96417 Muckleford        B DYro17-3039           2-E5\n\n\nUse the sex-linked loci you have identified to infer the sex of that individual by running function infer.sex.\nThis function uses the output of function gl.keep.sexlinked to infer the sex of all individuals in the dataset. It uses 3 types of sex-linked loci (W-/Y-linked, Z-/X-linked, and gametologs), assigns a preliminary genetic sex for each type of sex-linked loci available, and outputs an agreed sex:\n\nEYR_sexLinked &lt;- gl.keep.sexlinked(EYR, system = \"zw\") # save sex-linked loci\n\nStarting gl.keep.sexlinked \n  Processing genlight object with SNP data\n\n\nDetected 352 females and 429 males.\n\n\nStarting phase 1. May take a while...\n\n\nBuilding call rate plots.\n\n\nStarting phase 2. May take a while...\n\n\nBuilding heterozygosity plots.\n\n\nDone building heterozygosity plots.\n\n\n**FINISHED** Total of analyzed loci: 1000.\nKept 150 sex-linked loci:\n   16 W-linked loci (yellow)\n   82 sex-biased loci (blue)\n   32 Z-linked loci (orange)\n   20 gametologs (green).\nAnd removed 850 autosomal loci (grey).\n\n\n\n\n\n\n\n\n\nCompleted: gl.keep.sexlinked \n\n#inferred.sexes &lt;- gl.infer.sex(gl_sexlinked = EYR_sexLinked, system = \"zw\", seed = 124) # use sex-linked loci\n\nThe function outputs a table with assigned sexes based on sex-linked loci:\n\n#View(inferred.sexes)\n\nExamine the output table. There are four assigned sexes per individual: one according to w-linked loci, one according to z-linked loci, one according to gametologs, and one final agreed sex.\n\n\n\n\n\n\nNote\n\n\n\nQuestion: What agreed sex was assigned to the individual with missing sex?\nQuestion: Can you find individuals for which the agreed sex is uncertain (i.e., has an asterisk ‘*’)? How would you decide which is their correct sex?",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Bonus! Sex Linked Markers</span>"
    ]
  },
  {
    "objectID": "session08.html#exercise-2-observe-the-effects-of-not-removing-sex-linked-loci-on-population-genetic-analyses",
    "href": "session08.html#exercise-2-observe-the-effects-of-not-removing-sex-linked-loci-on-population-genetic-analyses",
    "title": "8  Bonus! Sex Linked Markers",
    "section": "Exercise 2: Observe the effects of not removing sex-linked loci on population genetic analyses ",
    "text": "Exercise 2: Observe the effects of not removing sex-linked loci on population genetic analyses \nImagine you are analyzing the genetic data of a species and you want to look at its population structure and genetic diversity. You start by filtering your beautiful set of SNPs. Because you are a rigorous scientist, you want to test whether using function gl.drop.sexlinked to properly filter out sex-linked loci changes the results of the populations analyses. So you: (1) process your SNP dataset by applying only standard filters (from here on “sloppy filtering”) and run analyses, and (2) process the dataset by filtering out sex-linked loci first, applying standard filters second (from here on “correct filtering”), and then run analyses.\nUse the EYR dataset or your own data to report:\n\nDo you see any changes in a population structure analysis (PCoA) when you filter out sex-linked markers versus when you do not?\nDo you see any differences in genetic diversity and fixation indices when you filter out sex-linked markers versus when you do not?\n\n\nFiltering SNPs only with standard filters (“sloppy filtering”)\nLet’s apply only standard filters (read depth, call rate, and MAC):\n\n# Filter for read depth\ngl.report.rdepth(EYR)\n\nStarting gl.report.rdepth \n  Processing genlight object with SNP data\n  Reporting Read Depth by Locus\n  No. of loci = 1000 \n  No. of individuals = 782 \n    Minimum      :  2.6 \n    1st quartile :  4.3 \n    Median       :  5.6 \n    Mean         :  5.9649 \n    3r quartile  :  7.325 \n    Maximum      :  13.2 \n    Missing Rate Overall:  0.19 \n\n\n\n\n\n\n\n\n\n   Quantile Threshold Retained Percent Filtered Percent\n1      100%      13.2        1     0.1      999    99.9\n2       95%       9.9       51     5.1      949    94.9\n3       90%       9.0      105    10.5      895    89.5\n4       85%       8.3      151    15.1      849    84.9\n5       80%       7.8      208    20.8      792    79.2\n6       75%       7.3      258    25.8      742    74.2\n7       70%       6.9      304    30.4      696    69.6\n8       65%       6.5      354    35.4      646    64.6\n9       60%       6.2      404    40.4      596    59.6\n10      55%       5.9      451    45.1      549    54.9\n11      50%       5.6      504    50.4      496    49.6\n12      45%       5.3      563    56.3      437    43.7\n13      40%       5.1      602    60.2      398    39.8\n14      35%       4.8      659    65.9      341    34.1\n15      30%       4.6      702    70.2      298    29.8\n16      25%       4.3      752    75.2      248    24.8\n17      20%       4.0      823    82.3      177    17.7\n18      15%       3.9      852    85.2      148    14.8\n19      10%       3.6      906    90.6       94     9.4\n20       5%       3.3      956    95.6       44     4.4\n21       0%       2.6     1000   100.0        0     0.0\nCompleted: gl.report.rdepth \n\nEYR.sloppy &lt;- gl.filter.rdepth(EYR, lower = 3, upper = 11, verbose = 0)\n\n\n\n\n\n\n\n# Filter for loci call rate\ngl.report.callrate(EYR.sloppy, method = \"loc\")\n\nStarting gl.report.callrate \n  Processing genlight object with SNP data\n  Reporting Call Rate by Locus\n  No. of loci = 958 \n  No. of individuals = 782 \n    Minimum      :  0.20844 \n    1st quartile :  0.7202688 \n    Median       :  0.895141 \n    Mean         :  0.8131871 \n    3r quartile  :  0.950128 \n    Maximum      :  0.988491 \n    Missing Rate Overall:  0.1868 \n\n   Quantile Threshold Retained Percent Filtered Percent\n1      100%  0.988491        1     0.1      957    99.9\n2       95%  0.979540       52     5.4      906    94.6\n3       90%  0.973146      104    10.9      854    89.1\n4       85%  0.965473      145    15.1      813    84.9\n5       80%  0.956522      197    20.6      761    79.4\n6       75%  0.950128      247    25.8      711    74.2\n7       70%  0.943734      291    30.4      667    69.6\n8       65%  0.932225      339    35.4      619    64.6\n9       60%  0.921995      386    40.3      572    59.7\n10      55%  0.910486      434    45.3      524    54.7\n11      50%  0.895141      482    50.3      476    49.7\n12      45%  0.872123      527    55.0      431    45.0\n13      40%  0.847826      575    60.0      383    40.0\n14      35%  0.819693      623    65.0      335    35.0\n15      30%  0.780051      671    70.0      287    30.0\n16      25%  0.719949      719    75.1      239    24.9\n17      20%  0.662404      768    80.2      190    19.8\n18      15%  0.594629      815    85.1      143    14.9\n19      10%  0.523018      863    90.1       95     9.9\n20       5%  0.402813      911    95.1       47     4.9\n21       0%  0.208440      958   100.0        0     0.0\n\n\n\n\n\n\n\n\n\nCompleted: gl.report.callrate \n\nEYR.sloppy &lt;- gl.filter.callrate(EYR.sloppy, method = \"loc\",  threshold = 0.75, verbose = 0, recalc = TRUE)\n\n# Filter for individual call rate\ngl.report.callrate(EYR.sloppy, method = \"ind\")\n\nStarting gl.report.callrate \n  Processing genlight object with SNP data\n\n  Reporting Call Rate by Individual\n  No. of loci = 703 \n  No. of individuals = 782 \n    Minimum      :  0.03556188 \n    1st quartile :  0.9174964 \n    Median       :  0.9416785 \n    Mean         :  0.9108097 \n    3r quartile  :  0.9573257 \n    Maximum      :  0.9829303 \n    Missing Rate Overall:  0.0892 \n\nListing 4 populations and their average CallRates\n  Monitor again after filtering\n  Population CallRate   N\n1     Crusoe   0.9027 238\n2 Muckleford   0.9073 421\n3      Timor   0.9402  52\n4     Wombat   0.9371  71\n\nListing 20 individuals with the lowest CallRates\n  Use this list to see which individuals will be lost on filtering by individual\n  Set ind.to.list parameter to see more individuals\n   Individual Population   CallRate\n1    M18.29.1 Muckleford 0.03556188\n2    M18.18.1 Muckleford 0.03982930\n3    M18.47.2 Muckleford 0.06970128\n4    C18.16.1     Crusoe 0.07112376\n5   027-34168     Crusoe 0.07681366\n6    C18.15.2     Crusoe 0.08534851\n7    C18.21.2     Crusoe 0.08677098\n8    M18.47.3 Muckleford 0.14224751\n9    M18.35.2 Muckleford 0.17211949\n10   M18.20.3 Muckleford 0.24039829\n11   M20.70.2 Muckleford 0.39687055\n12   C18.28.1     Crusoe 0.39971550\n13   C18.17.2     Crusoe 0.46088193\n14  027-34065 Muckleford 0.50640114\n15   C18.14.1     Crusoe 0.50640114\n16   M20.70.3 Muckleford 0.50782361\n17  M20.110.1 Muckleford 0.52347084\n18   M19.12.1 Muckleford 0.53342817\n19    M19.8.1 Muckleford 0.54907539\n20   M20.64.3 Muckleford 0.56045519\n\n)\n\n\n\n\n\n\n\n\n\nCompleted: gl.report.callrate \n\nEYR.sloppy &lt;- gl.filter.callrate(EYR.sloppy, method = \"ind\", threshold = 0.65, verbose = 0, recalc = TRUE)\n# Filter for MAC (= 3)\ngl.report.maf(EYR.sloppy)\n\nStarting gl.report.maf \n  Processing genlight object with SNP data\nStarting gl.report.maf \n\n  Reporting Minor Allele Frequency (MAF) by Locus for population Crusoe \n  No. of loci = 670 \n  No. of individuals = 231 \n    Minimum      :  0.002164502 \n    1st quantile :  0.06484488 \n    Median       :  0.1582011 \n    Mean         :  0.1793518 \n    3r quantile  :  0.2674593 \n    Maximum      :  0.4975369 \n    Missing Rate Overall:  0.08 \n\n  Reporting Minor Allele Frequency (MAF) by Locus for population Muckleford \n  No. of loci = 683 \n  No. of individuals = 401 \n    Minimum      :  0.001253133 \n    1st quantile :  0.05874834 \n    Median       :  0.1403509 \n    Mean         :  0.1729484 \n    3r quantile  :  0.2617141 \n    Maximum      :  0.4985251 \n    Missing Rate Overall:  0.07 \n\n  Reporting Minor Allele Frequency (MAF) by Locus for population Timor \n  No. of loci = 589 \n  No. of individuals = 52 \n    Minimum      :  0.009615385 \n    1st quantile :  0.06730769 \n    Median       :  0.1666667 \n    Mean         :  0.191416 \n    3r quantile  :  0.287234 \n    Maximum      :  0.5 \n    Missing Rate Overall:  0.06 \n\n  Reporting Minor Allele Frequency (MAF) by Locus for population Wombat \n  No. of loci = 627 \n  No. of individuals = 71 \n    Minimum      :  0.007042254 \n    1st quantile :  0.063833 \n    Median       :  0.1449275 \n    Mean         :  0.1746704 \n    3r quantile  :  0.2541771 \n    Maximum      :  0.5 \n    Missing Rate Overall:  0.06 \n\n  Reporting Minor Allele Frequency (MAF) by Locus OVERALL\n  No. of loci = 703 \n  No. of individuals = 755 \n    Minimum      :  0.000665779 \n    1st quantile :  0.06181458 \n    Median       :  0.1442801 \n    Mean         :  0.1711878 \n    3r quantile  :  0.2544219 \n    Maximum      :  0.5 \n    Missing Rate Overall:  0.07 \n\n\n\n\n\n\n\n\n\n   Quantile   Threshold Retained Percent Filtered Percent\n1      100% 0.500000000        1     0.1      699    99.9\n2       95% 0.443105756       36     5.1      664    94.9\n3       90% 0.381240545       71    10.1      629    89.9\n4       85% 0.334558824      105    15.0      595    85.0\n5       80% 0.287348587      141    20.1      559    79.9\n6       75% 0.253681392      176    25.1      524    74.9\n7       70% 0.227857143      210    30.0      490    70.0\n8       65% 0.200947226      246    35.1      454    64.9\n9       60% 0.177905308      280    40.0      420    60.0\n10      55% 0.159519726      315    45.0      385    55.0\n11      50% 0.144189383      351    50.1      349    49.9\n12      45% 0.121014493      386    55.1      314    44.9\n13      40% 0.102439024      421    60.1      279    39.9\n14      35% 0.087191358      455    65.0      245    35.0\n15      30% 0.075549451      490    70.0      210    30.0\n16      25% 0.061752988      526    75.1      174    24.9\n17      20% 0.048679868      561    80.1      139    19.9\n18      15% 0.034609720      595    85.0      105    15.0\n19      10% 0.022666667      631    90.1       69     9.9\n20       5% 0.005347594      666    95.1       34     4.9\n21       0% 0.000665779      700   100.0        0     0.0\nCompleted: gl.report.maf \n\nEYR.sloppy &lt;- gl.filter.maf(EYR.sloppy, threshold = 3, verbose = 0, recalc = TRUE)\n\n\n\nFiltering SNPs for sex-linked loci and then with standard filters (“correct filtering”)\nLet’s remove sex-linked markers and then apply standard filters:\n\n# Filter for sex-linked loci\nEYR.correct &lt;- gl.drop.sexlinked(EYR, system = \"zw\")  \n\nStarting gl.drop.sexlinked \n  Processing genlight object with SNP data\n\n\n\n\n\n\n\n\n\nCompleted: gl.drop.sexlinked \n\n# Filter for read depth\nEYR.correct &lt;- gl.filter.rdepth(EYR.correct, lower = 3, upper = 11, verbose = 0)\n\n\n\n\n\n\n\n# Filter for loci call rate\ngl.report.callrate(EYR.correct, method = \"loc\")\n\nStarting gl.report.callrate \n  Processing genlight object with SNP data\n  Reporting Call Rate by Locus\n  No. of loci = 811 \n  No. of individuals = 782 \n    Minimum      :  0.20844 \n    1st quartile :  0.7436065 \n    Median       :  0.900256 \n    Mean         :  0.8192658 \n    3r quartile  :  0.951407 \n    Maximum      :  0.988491 \n    Missing Rate Overall:  0.1807 \n\n   Quantile Threshold Retained Percent Filtered Percent\n1      100%  0.988491        1     0.1      810    99.9\n2       95%  0.979540       46     5.7      765    94.3\n3       90%  0.974425       84    10.4      727    89.6\n4       85%  0.966752      130    16.0      681    84.0\n5       80%  0.957801      165    20.3      646    79.7\n6       75%  0.951407      208    25.6      603    74.4\n7       70%  0.945013      249    30.7      562    69.3\n8       65%  0.936061      289    35.6      522    64.4\n9       60%  0.924552      331    40.8      480    59.2\n10      55%  0.914322      368    45.4      443    54.6\n11      50%  0.900256      408    50.3      403    49.7\n12      45%  0.878517      449    55.4      362    44.6\n13      40%  0.850384      487    60.0      324    40.0\n14      35%  0.823529      531    65.5      280    34.5\n15      30%  0.789003      571    70.4      240    29.6\n16      25%  0.742967      609    75.1      202    24.9\n17      20%  0.672634      649    80.0      162    20.0\n18      15%  0.613811      691    85.2      120    14.8\n19      10%  0.539642      730    90.0       81    10.0\n20       5%  0.402813      771    95.1       40     4.9\n21       0%  0.208440      811   100.0        0     0.0\n\n\n\n\n\n\n\n\n\nCompleted: gl.report.callrate \n\nEYR.correct &lt;- dartR.base::gl.filter.callrate(EYR.correct, method = \"loc\",  threshold = 0.75, verbose = 0, recalc = TRUE)\n\n# Filter for individual call rate\ngl.report.callrate(EYR.correct, method = \"ind\")\n\nStarting gl.report.callrate \n  Processing genlight object with SNP data\n\n  Reporting Call Rate by Individual\n  No. of loci = 605 \n  No. of individuals = 782 \n    Minimum      :  0.03801653 \n    1st quartile :  0.9173554 \n    Median       :  0.9438017 \n    Mean         :  0.9120479 \n    3r quartile  :  0.9586777 \n    Maximum      :  0.9818182 \n    Missing Rate Overall:  0.088 \n\nListing 4 populations and their average CallRates\n  Monitor again after filtering\n  Population CallRate   N\n1     Crusoe   0.9037 238\n2 Muckleford   0.9090 421\n3      Timor   0.9418  52\n4     Wombat   0.9365  71\n\nListing 20 individuals with the lowest CallRates\n  Use this list to see which individuals will be lost on filtering by individual\n  Set ind.to.list parameter to see more individuals\n   Individual Population   CallRate\n1    M18.29.1 Muckleford 0.03801653\n2    M18.18.1 Muckleford 0.04462810\n3    M18.47.2 Muckleford 0.06776860\n4    C18.16.1     Crusoe 0.07438017\n5   027-34168     Crusoe 0.08760331\n6    C18.15.2     Crusoe 0.08760331\n7    C18.21.2     Crusoe 0.08760331\n8    M18.47.3 Muckleford 0.13719008\n9    M18.35.2 Muckleford 0.18016529\n10   M18.20.3 Muckleford 0.24132231\n11   C18.28.1     Crusoe 0.41487603\n12   M20.70.2 Muckleford 0.42644628\n13   C18.17.2     Crusoe 0.44628099\n14  027-34065 Muckleford 0.49586777\n15   C18.14.1     Crusoe 0.49752066\n16  M20.110.1 Muckleford 0.53057851\n17   M20.70.3 Muckleford 0.53553719\n18   M19.12.1 Muckleford 0.54380165\n19    M19.8.1 Muckleford 0.56694215\n20   M19.33.2 Muckleford 0.57851240\n\n)\n\n\n\n\n\n\n\n\n\nCompleted: gl.report.callrate \n\nEYR.correct &lt;- gl.filter.callrate(EYR.correct, method = \"ind\", threshold = 0.65, verbose = 0, recalc = TRUE)\n# Filter for MAC (= 3)\ngl.report.maf(EYR.correct)\n\nStarting gl.report.maf \n  Processing genlight object with SNP data\nStarting gl.report.maf \n\n  Reporting Minor Allele Frequency (MAF) by Locus for population Crusoe \n  No. of loci = 573 \n  No. of individuals = 231 \n    Minimum      :  0.002164502 \n    1st quantile :  0.06 \n    Median       :  0.1488372 \n    Mean         :  0.1741175 \n    3r quantile  :  0.2645503 \n    Maximum      :  0.4975369 \n    Missing Rate Overall:  0.08 \n\n  Reporting Minor Allele Frequency (MAF) by Locus for population Muckleford \n  No. of loci = 585 \n  No. of individuals = 401 \n    Minimum      :  0.001253133 \n    1st quantile :  0.05498721 \n    Median       :  0.1289855 \n    Mean         :  0.1639923 \n    3r quantile  :  0.247449 \n    Maximum      :  0.4985251 \n    Missing Rate Overall:  0.07 \n\n  Reporting Minor Allele Frequency (MAF) by Locus for population Timor \n  No. of loci = 504 \n  No. of individuals = 52 \n    Minimum      :  0.009615385 \n    1st quantile :  0.06829751 \n    Median       :  0.1634615 \n    Mean         :  0.1898642 \n    3r quantile  :  0.2860942 \n    Maximum      :  0.5 \n    Missing Rate Overall:  0.06 \n\n  Reporting Minor Allele Frequency (MAF) by Locus for population Wombat \n  No. of loci = 536 \n  No. of individuals = 71 \n    Minimum      :  0.007042254 \n    1st quantile :  0.06246058 \n    Median       :  0.1380348 \n    Mean         :  0.1706064 \n    3r quantile  :  0.2509058 \n    Maximum      :  0.5 \n    Missing Rate Overall:  0.06 \n\n  Reporting Minor Allele Frequency (MAF) by Locus OVERALL\n  No. of loci = 605 \n  No. of individuals = 755 \n    Minimum      :  0.000665779 \n    1st quantile :  0.05816563 \n    Median       :  0.1325038 \n    Mean         :  0.1628174 \n    3r quantile  :  0.2433774 \n    Maximum      :  0.5 \n    Missing Rate Overall:  0.07 \n\n\n\n\n\n\n\n\n\n   Quantile   Threshold Retained Percent Filtered Percent\n1      100% 0.500000000        1     0.2      601    99.8\n2       95% 0.436416185       31     5.1      571    94.9\n3       90% 0.371359223       61    10.1      541    89.9\n4       85% 0.320707071       91    15.1      511    84.9\n5       80% 0.273415978      121    20.1      481    79.9\n6       75% 0.243550835      151    25.1      451    74.9\n7       70% 0.212715856      181    30.1      421    69.9\n8       65% 0.190108192      211    35.0      391    65.0\n9       60% 0.171383648      241    40.0      361    60.0\n10      55% 0.149933066      271    45.0      331    55.0\n11      50% 0.131954351      302    50.2      300    49.8\n12      45% 0.109164420      332    55.1      270    44.9\n13      40% 0.094953519      362    60.1      240    39.9\n14      35% 0.080645161      392    65.1      210    34.9\n15      30% 0.070951586      422    70.1      180    29.9\n16      25% 0.058022923      452    75.1      150    24.9\n17      20% 0.044692737      482    80.1      120    19.9\n18      15% 0.030487805      512    85.0       90    15.0\n19      10% 0.019410977      542    90.0       60    10.0\n20       5% 0.004761905      572    95.0       30     5.0\n21       0% 0.000665779      602   100.0        0     0.0\nCompleted: gl.report.maf \n\nEYR.correct &lt;- dartR.base::gl.filter.maf(EYR.correct, threshold = 3, verbose = 0, recalc = TRUE)\n\n\n\n2.1. Differences in PCoA between “sloppily filtered” dataset (only standard filters), vs “correctly filtered” dataset (gl.drop.sexlinked and standard filters)\n\n# Sloppy\nPCA.sloppy &lt;- gl.pcoa(EYR.sloppy, verbose = 0)\n\n\n\n\n\n\n\npcplot_sloppy &lt;- gl.pcoa.plot(PCA.sloppy, EYR.sloppy, xaxis = 1, yaxis = 2)\n\n\n\n\n\n\n\n# Correct\nPCA.correct &lt;- gl.pcoa(EYR.correct, verbose = 0)\n\n\n\n\n\n\n\npcplot_correct &lt;- gl.pcoa.plot(PCA.correct, EYR.correct, xaxis = 1, yaxis = 2)\n\n\n\n\n\n\n\n\nStarting gl.colors \nSelected color type 2 \nCompleted: gl.colors \nStarting gl.pcoa.plot \n  Processing an ordination file (glPca)\n  Processing genlight object with SNP data\n  Plotting populations in a space defined by the SNPs\n  Preparing plot .... please wait\nCompleted: gl.pcoa.plot \nStarting gl.colors \nSelected color type 2 \nCompleted: gl.colors \nStarting gl.pcoa.plot \n  Processing an ordination file (glPca)\n  Processing genlight object with SNP data\n  Plotting populations in a space defined by the SNPs\n  Preparing plot .... please wait\nCompleted: gl.pcoa.plot \n\n\n\n\n\n\n\n\nNote\n\n\n\nQuestion: Do the PCoA plots look different? Why?\n\n\n\n\n2.2. Differences in genetic diversity and fixation indices between “sloppily filtered” dataset vs “correctly filtered” dataset\nLet’s check some basic stats:\n\nbasic.sloppy  &lt;- utils.basic.stats(EYR.sloppy)\nbasic.correct &lt;- utils.basic.stats(EYR.correct)\nbasic.sloppy$overall\n\n     Ho      Hs      Ht     Dst     Htp    Dstp     Fst    Fstp     Fis    Dest \n 0.1638  0.2442  0.2537  0.0095  0.2568  0.0126  0.0373  0.0491  0.3294  0.0167 \nGst_max   Gst_H \n 0.7061  0.0696 \n\nbasic.correct$overall\n\n     Ho      Hs      Ht     Dst     Htp    Dstp     Fst    Fstp     Fis    Dest \n 0.1631  0.2379  0.2459  0.0080  0.2485  0.0107  0.0325  0.0429  0.3144  0.0140 \nGst_max   Gst_H \n 0.7135  0.0601 \n\n\n\n\n\n\n\n\nNote\n\n\n\nQuestion: Why are observed Heterozygosity (Ho) and expected Heterozygosity (He) slightly higher for the “sloppyly filtered” dataset? Hint: Look at the second plot produced by function gl.report.sexlinked.\n\n\nCalculate FST fixation indices between populations:\n\ngl.fst.pop(EYR.sloppy, verbose = 0)\n\n               Crusoe Muckleford      Timor Wombat\nCrusoe             NA         NA         NA     NA\nMuckleford 0.03234709         NA         NA     NA\nTimor      0.04072932 0.05451318         NA     NA\nWombat     0.05484958 0.02376727 0.08401313     NA\n\ngl.fst.pop(EYR.correct, verbose = 0)\n\n               Crusoe Muckleford      Timor Wombat\nCrusoe             NA         NA         NA     NA\nMuckleford 0.02795813         NA         NA     NA\nTimor      0.03987369 0.04810759         NA     NA\nWombat     0.04446378 0.02270137 0.07114017     NA\n\n\n\n\n\n\n\n\nNote\n\n\n\nQuestion: Which dataset has higher FST estimates overall?",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Bonus! Sex Linked Markers</span>"
    ]
  },
  {
    "objectID": "session08.html#further-study",
    "href": "session08.html#further-study",
    "title": "8  Bonus! Sex Linked Markers",
    "section": "Further Study",
    "text": "Further Study\n\nReadings\nRobledo-Ruiz et al. (2023)\n\n\n\n\nRobledo-Ruiz, Diana A., Lana Austin, J. Nevil Amos, Jesús Castrejón-Figueroa, Daniel K. P. Harley, Michael J. L. Magrath, Paul Sunnucks, and Alexandra Pavlova. 2023. “Easy-to-Use R Functions to Separate Reduced-Representation Genomic Datasets into Sex-Linked and Autosomal Loci, and Conduct Sex Assignment.” Molecular Ecology Resources 0 (n/a). https://doi.org/10.1111/1755-0998.13844.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Bonus! Sex Linked Markers</span>"
    ]
  },
  {
    "objectID": "break.html",
    "href": "break.html",
    "title": "__________",
    "section": "",
    "text": "Everything beyond this point is for added learning, we hope you have fun exploring all the amazing things the dartRverse has to offer.",
    "crumbs": [
      "\\__________"
    ]
  },
  {
    "objectID": "tutorials.html",
    "href": "tutorials.html",
    "title": "dartR Tutorials",
    "section": "",
    "text": "Prerequistes",
    "crumbs": [
      "dartR Tutorials"
    ]
  },
  {
    "objectID": "tutorials.html#prerequistes",
    "href": "tutorials.html#prerequistes",
    "title": "dartR Tutorials",
    "section": "",
    "text": "RStudio Refresher\nUnable to display PDF file. Download instead.\n\n\ndartR Installation\nUnable to display PDF file. Download instead.",
    "crumbs": [
      "dartR Tutorials"
    ]
  },
  {
    "objectID": "tutorials.html#fundamentals",
    "href": "tutorials.html#fundamentals",
    "title": "dartR Tutorials",
    "section": "Fundamentals",
    "text": "Fundamentals\n\ndartR Data Structure and Input\nUnable to display PDF file. Download instead.\n\n\ndartR Data Manipulation\nUnable to display PDF file. Download instead.\n\n\ndartR Basic Filtering\nUnable to display PDF file. Download instead.",
    "crumbs": [
      "dartR Tutorials"
    ]
  },
  {
    "objectID": "powerpoints.html",
    "href": "powerpoints.html",
    "title": "Powerpoints",
    "section": "",
    "text": "Session 1",
    "crumbs": [
      "Powerpoints"
    ]
  },
  {
    "objectID": "powerpoints.html#session-1",
    "href": "powerpoints.html#session-1",
    "title": "Powerpoints",
    "section": "",
    "text": "Download Session 1 powerpoint",
    "crumbs": [
      "Powerpoints"
    ]
  },
  {
    "objectID": "powerpoints.html#session-8",
    "href": "powerpoints.html#session-8",
    "title": "Powerpoints",
    "section": "Session 8",
    "text": "Session 8\n\n\n\n\n\n\n Download Session 8 powerpoint",
    "crumbs": [
      "Powerpoints"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Gruber, Bernd, Peter J. Unmack, Oliver F. Berry, and Arthur Georges.\n2018. “DARTR : An R Package\nto Facilitate Analysis of SNP Data Generated from Reduced\nRepresentation Genome Sequencing.” Molecular Ecology\nResources 18 (3): 691–99. https://doi.org/10.1111/1755-0998.12745.\n\n\nJombart, T., and I. Ahmed. 2011. “Adegenet 1.3-1: New Tools for\nthe Analysis of Genome-Wide SNP Data.” Bioinformatics.\nhttps://doi.org/10.1093/bioinformatics/btr521.\n\n\nMijangos, Jose Luis, Bernd Gruber, Oliver Berry, Carlo Pacioni, and\nArthur Georges. 2022. “dartR V2:\nAn Accessible Genetic Analysis Platform for Conservation,\nEcology and Agriculture.” Methods in Ecology and\nEvolution 13 (10): 2150–58. https://doi.org/10.1111/2041-210X.13918.\n\n\nRobledo-Ruiz, Diana A., Lana Austin, J. Nevil Amos, Jesús\nCastrejón-Figueroa, Daniel K. P. Harley, Michael J. L. Magrath, Paul\nSunnucks, and Alexandra Pavlova. 2023. “Easy-to-Use R\nFunctions to Separate Reduced-Representation Genomic Datasets into\nSex-Linked and Autosomal Loci, and Conduct Sex Assignment.”\nMolecular Ecology Resources 0 (n/a). https://doi.org/10.1111/1755-0998.13844.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "feedback.html",
    "href": "feedback.html",
    "title": "Feedback",
    "section": "",
    "text": "Please provide any questions, suggestions, or praises in the message box below and then hit submit.\n\nName: \nEmail: \nMessage:",
    "crumbs": [
      "Feedback"
    ]
  }
]