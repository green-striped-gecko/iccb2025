[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analysing Genomic Data with dartRverse",
    "section": "",
    "text": "Welcome!\nWelcome, Trailblazers of Biodiversity, to the Second Gathering of our Population Genetics Workshop — this time under the vast skies and red dust of the Australian Outback (well… Brisbane’s subtropical edge of it)!\nWe’re excited to bring this workshop to the International Congress for Conservation Biology (ICCB) — a meeting ground where conservationists from every corner gather to share stories, science, and strategies for protecting the wild heart of our planet. While Brisbane may not boast the rustle of Kioloa’s forests, it hums with its own rhythm — a place where mangroves meet skyscrapers and river currents carry both eDNA and ideas.\nIn this workshop — a compact but powerful expedition — we’ll explore Population Genetics using R. Whether you’re a seasoned fieldworker or new to the code trail, you’re in good company. Here, every voice matters, and learning is a shared journey.\nThis is your chance to sharpen your analytical tools, exchange ideas, and delve into the genomic threads that weave through ecosystems across Australia and beyond. And yes — we’ll get our hands dirty (metaphorically… unless your dataset’s really dusty) with hands-on practice using your own data.\nSo bring your resilience, your field-hardened humour, and your willingness to wrestle a few data-wrangling goannas. Bugs in your code? Think of them as wildlife encounters. We’ll handle it all with tenacity, teamwork, and maybe a bit of data-fuelled bush magic.\nWe’re glad to have you on this journey. Let’s get started.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#program-and-speakers",
    "href": "index.html#program-and-speakers",
    "title": "Analysing Genomic Data with dartRverse",
    "section": "Program and Speakers",
    "text": "Program and Speakers\nWe hope you are ready for a jam-packed PROGRAM! And before getting started why not check out the amazing speakers we have lined up. They are all excited to share their knowledge and expertise.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#prerequistes",
    "href": "index.html#prerequistes",
    "title": "Analysing Genomic Data with dartRverse",
    "section": "Prerequistes",
    "text": "Prerequistes\nBefore getting started with the sessions how about checking out some tutorials to make sure you are all up to date:\n\nRStudio refresher\ninstalling dartR.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#here-are-some-things-you-might-see-along-your-journey",
    "href": "index.html#here-are-some-things-you-might-see-along-your-journey",
    "title": "Analysing Genomic Data with dartRverse",
    "section": "Here are some things you might see along your journey:",
    "text": "Here are some things you might see along your journey:\nBelow is an exercise box, this is encouraging you to give it a go yourself!\n\n\n\n\n\n\nExercise\n\n\n\n Give the code a go!\n\n\nBelow is a tip box, with added insights for your journey.\n\n\n\n\n\n\nTip\n\n\n\ntake a look…\nA variety of things to learn!\n\n\nBelow is a caution box, take note, this will keep you on your path.\n\n\n\n\n\n\nCaution\n\n\n\nTake CARE! It is easy to go astray, I am here to help.\n\n\nBelow is a warning box! Be careful and take head of what it says.\n\n\n\n\n\n\nWarning\n\n\n\nNOTICE! Thank you for noticing this warning!",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#a-big-thank-you-to-the-developers",
    "href": "index.html#a-big-thank-you-to-the-developers",
    "title": "Analysing Genomic Data with dartRverse",
    "section": "A big thank you to the developers!",
    "text": "A big thank you to the developers!\nDartR published first by Gruber et al. (2018), and DartR V2 published by Mijangos et al. (2022)\n\n\n\n\nGruber, Bernd, Peter J. Unmack, Oliver F. Berry, and Arthur Georges. 2018. “DARTR : An R Package to Facilitate Analysis of SNP Data Generated from Reduced Representation Genome Sequencing.” Molecular Ecology Resources 18 (3): 691–99. https://doi.org/10.1111/1755-0998.12745.\n\n\nMijangos, Jose Luis, Bernd Gruber, Oliver Berry, Carlo Pacioni, and Arthur Georges. 2022. “dartR V2: An Accessible Genetic Analysis Platform for Conservation, Ecology and Agriculture.” Methods in Ecology and Evolution 13 (10): 2150–58. https://doi.org/10.1111/2041-210X.13918.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Program",
    "section": "",
    "text": "#\nDay\nTime\nTopic\nPresenters\n\n\n\n\n1\nSaturday\n9 am – 11 am\nImporting and Handling Genomic Data\nArthur Georges, Diana Robledo\n\n\n2\n\n11:20 am – 12:50 pm\nEstimating Effective Population Size and Key Stats\nBernd Gruber, Luis Mijangos\n\n\n3\n\n1:30 pm – 3 pm\nIdentifying Population Structure\nLuis Mijangos, Emily Stringer\n\n\n4\n\n3:30 pm – 5 pm\nKinship, Pedigrees & Mating Recommendations\nLuis Mijangos\n\n\n5\nSunday\n9 am – 11 am\nAssigning Individuals to Populations\nArthur Georges\n\n\n6\n\n11:30 am – 12:30 pm\nSNP Panel Selection\nElise Furlan, Andrzej Killian, Bernd Gruber\n\n\n7\n\n1:10 pm – 2:10 pm\nSimulations for Conservation\nBernd Gruber\n\n\nBonus!\n\n2:10 pm – 3 pm\nSex Linked Markers\nDiana Robledo",
    "crumbs": [
      "Program"
    ]
  },
  {
    "objectID": "speakers.html",
    "href": "speakers.html",
    "title": "Speaker Bios",
    "section": "",
    "text": "Elise Furlan is a Senior Research Fellow with the eDNA Team at the University of Canberra, where she applies molecular genetic techniques to tackle a wide range of ecological questions. One of the early trailblazers in Australia’s environmental DNA (eDNA) space, Elise was among the first researchers in the country to develop methods for analysing eDNA — detecting species from the tiny traces they leave behind in the environment. Her main objective is to ensure her high quality research results in applied outcomes for conservation, therefore partnerships with government agencies and industry feature heavily in her projects. session 4 and session 6\nArthur Georges, a distinguished professor at the University of Canberra, has revolutionized the understanding of sex determination in reptiles. His major achievement? Unravelling how environmental factors influence sex in reptiles, a game-changer in herpetology and conservation genetics. Arthur’s work has far-reaching implications, from conservation strategies to understanding evolutionary processes. He’s the Dumbledore of herpetology, albeit more fascinated by dragon eggs than by magic ones, and probably wonders if he could genetically engineer a lizard to brew his morning coffee. session 1 and session 4\nBernd Gruber, from the University of Canberra, is a master at blending spatial and ecological modelling with genetics. His crowning achievement? Developing dartR, a tool that’s revolutionizing genetic data analysis in conservation projects. His approach to research is as innovative as it is impactful, making him the Houdini of ecology – he makes complex data disappear into meaningful conservation strategies. Bernd might secretly wish to decode the genetic basis for why every odd sock goes missing, solving one of life’s great mysteries.session 2, session 5, and session 6\nAndrzej Kilian, founder of DArT in 2001, has been a pioneer in genomics, creating a technology that simplifies high-throughput genotyping across various organisms. His work at DArT supports global food security, sustainable agriculture, and biodiversity, making significant strides towards understanding and improving agricultural and environmental practices. Andrzej’s commitment to science and humanity illustrates a unique blend of innovation with a purpose. Andrzej, much like a maestro in an orchestra of genomes, harmonizes the complex notes of genetics to compose a symphony for a sustainable planet, ensuring every note contributes to the grander vision of global harmony and well-being. session 4\nLuis Mijangos, at DArT, he combines his passion for technology and conservation, using genetic data analysis to protect biodiversity. His standout achievement? Applying his expertise in genetic data analysis to conservation projects, making him the tech-savvy guardian of the planet. Luis’s contributions are crucial in the fight against biodiversity loss, and he’s probably brainstorming ways to use genetic data to convince plants to grow in perfect Instagram-worthy arrangements. session 2, session 3, session 4, session 5, and session 6\nDiana Robledo-Ruiz is a name you’ll want to remember in the field of conservation biology, specifically at Monash University. She’s been making waves with her work on the Helmeted Honeyeater’s genome, leading to significant advancements in genetic rescue operations. Her high-quality genomic research is not just for the birds – it’s key to saving them from extinction and maintaining their unique identity. Diana is also the lead developer of dartR.sexlinked which will make your life easier when filtering genetic data! She is developing this and other genomic tools to keep the endangered Helmeted Honeyeater, Leadbeater’s possum and Macquarie perch buzzing in the wild. session 1 and session 3\nEmily Stringer recently completed her PhD (Whooh!) at the University of Canberra, diving deep into conservation ecology and genomics. She kicked off with a mission to save the elusive Canberra grassland earless dragon and then hopped into the world of population genetics. Her main gig? Unraveling the genetic puzzle of an Australian rodent known for its dramatic population swings. Emily’s all about cracking complex data to solve ecological mysteries, aiming to turn her findings into real-world conservation victories. session 2, session 3, and session 6. She also put this website together for you all :)",
    "crumbs": [
      "Speaker Bios"
    ]
  },
  {
    "objectID": "install.html",
    "href": "install.html",
    "title": "Install dartRverse",
    "section": "",
    "text": "Install dartRverse",
    "crumbs": [
      "Install dartRverse"
    ]
  },
  {
    "objectID": "install.html#rationale",
    "href": "install.html#rationale",
    "title": "Install dartRverse",
    "section": "Rationale",
    "text": "Rationale\nWe have developed a new suit of packages called “dartRverse” packages, that will replace the previous dartR package, which soon will be no longer supported. The new suit of packages are meant to be a 1:1 replacement and only in some instance very minor changes will be needed to update previous code. For example we reworked on the “output” of all functions, now being able to save figures in specified folders, which can be easier recovered and manipulated for further tweaking. The main reasons for splitting dartR into several packages and developing the dartRverse suit of packages was difficulty to maintain dartR, because of limits imposed by CRAN, but also limits due the the long time to test new function, when compiling the package. Therefore we were forced to split the package into several smaller packages. This has several advantages and in the best of all cases no disadvantages.\n\neasier maintenance\nfaster development\nless dependencies on other packages\neasier to become a contributor\nhave your own package developed that can be branded as part of the dartRverse\n\nThe main paradigm was also that for our users nothing (or at as little as possible) needed to change and all existing code and scripts should still work. Also the installation process was meant to be straightforward and finally the coexistance between dartR and dartRverse packages should be possible (for the interim until dartR will be no longer supported).",
    "crumbs": [
      "Install dartRverse"
    ]
  },
  {
    "objectID": "install.html#installation",
    "href": "install.html#installation",
    "title": "Install dartRverse",
    "section": "Installation",
    "text": "Installation\n\ninstall dartRverse\n\n#installs the necessary bioconductor packages\ninstall.packages(\"devtools\")\ninstall.packages(\"BiocManager\")\nBiocManager::install(\"SNPRelate\")\n\n#install dartRverse (dartRverse) & core (dartR.base, dartR.data)\ninstall.packages(\"dartRverse\")\n\nThe dartRverse package is the first package to install and its only purpose is to support the installation of the other dartRverse packages. It will also be the first port of call to provide links to tutorials and other documentation.\nIf everything works well this should install two more packages with form the core version of dartRverse, nameley dartR.base and dartR.data. Those core packages have all the main function of old dartR package that deals with input, conversion, reporting and filtering of data. Also some base function to analysse data (e.g. PCoA, Fst) are included.\nOnce the dartRverse package has been installed we can load the package to check which part of the dartRverse has been installed.\n\nlibrary(dartRverse)\n\n\n\n\n\n\n\n\ninstall additional packages\nNow we can install the additional packages that are part of the dartRverse. Depending on your needs you can install all of them or only the one you are interested.\nFor example if you are interested in additional functions to analyse population structure (e.g. run STRUCTURE or faststructure) you can install the dartR.popgen package. If you are interested in functions that support the simulation of data you can install the dartR.sim package.\nYou can check which packages are avaialbel and which of them you have installed by typing:\n\ndartRverse::dartRverse_install()\n\n\n\n\n\n\nThe currently available packages are:\n\ndartR.sim (simulate SNP data)\ndartR.popgen (run population genetic analysis)\ndartR.spatial (run landscape genetic analysis)\ndartR.captive (estimate relatedness, support captive breeding)\ndartR.sexlinked (identify sexlinked markers, not ready yet)\n\nSo to install the dartR.sim simply type:\n\ninstall.packages(\"dartR.sim\")\ninstall.packages(\"dartR.popgen\")\ninstall.packages(\"dartR.spatial\")\ninstall.packages(\"dartR.captive\")\n# currently dartR.sexlinked requires a different installation process (see below)\n\n\n\nGithub repositories\nWe make all of our packages available via CRAN. The reason for this is that CRAN packages follow a stringent testing before they are allowed to be uploaded to CRAN and therefore are more likely to contain less errors then packages that are available on other repositories. Nevertheless we also make our packages available during development via github.\nYou can find the repositories under: https://github.com/green-striped-gecko/dartR.base [for the dartR.base package] and equivalent for the other packages.\nThe reason why you might want to install a package from github is that you want to use the latest version of the package. However, you should be aware that the packages on github are not tested and therefore might contain errors. Also the packages on github might be updated on a daily basis and therefore might change without notice.\nWe use different branches and they are reflecting different stages of development and majurity.\n\nmain (the main branch, which is equivalent to the current CRAN version)\ndev (development branch, which has the latest functions that might be in the next CRAN version, but have not been tested yet)\ndev_name (these are branches of our main developers and are used for testing and development of new functions. Installing functions from here might cause problems and should only be done if you know what you are doing)\n\ndartRverse supports the installation of github version of the packages using the following syntax:\ndartRverse_install(package = \"dartR.base\", repo = \"github\", branch = \"dev\")\nThis install the dev branch of dartR.base from CRAN. All main and dev branches are tested if they can be installed (and some additional error checks via): https://github.com/green-striped-gecko/dartRverse\nPlease note that you should provide the package repository (github/cran), the branch (main, dev,dev_name) and version number in case you want to report a bug. You can use the github methods to report issues or use our google group: https://groups.google.com/d/forum/dartr.\n\n\nInstalling dartR.sexlinked\ndartRverse_install(package = \"dartR.sexlinked\", repo = \"github\", branch = \"dev\")",
    "crumbs": [
      "Install dartRverse"
    ]
  },
  {
    "objectID": "install.html#using-dartrverse",
    "href": "install.html#using-dartrverse",
    "title": "Install dartRverse",
    "section": "Using dartRverse",
    "text": "Using dartRverse\nTo use dartRverse you can simply load the package and use it as before.\n\nlibrary(dartRverse)",
    "crumbs": [
      "Install dartRverse"
    ]
  },
  {
    "objectID": "breakk.html",
    "href": "breakk.html",
    "title": "__________",
    "section": "",
    "text": "And without further ado lets get into the workshop\n\nfor session powerpoints try this link PowerPoint GoogleDrive folder",
    "crumbs": [
      "\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_"
    ]
  },
  {
    "objectID": "session01.html",
    "href": "session01.html",
    "title": "1  Importing and Handling Genomic Data",
    "section": "",
    "text": "Required packages\nSession Presenters\nlibrary(dartRverse)\nlibrary(dartR.sexlinked)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Importing and Handling Genomic Data</span>"
    ]
  },
  {
    "objectID": "session01.html#introduction",
    "href": "session01.html#introduction",
    "title": "1  Importing and Handling Genomic Data",
    "section": "Introduction",
    "text": "Introduction\nSNPs, or single nucleotide polymorphisms, are single base pair mutations at a nuclear locus (Figure 2). That nuclear locus is represented in the dataset by two sequence tags which, at a heterozygous locus, take on two allelic states, one referred to as the reference state, the other as the alternate or SNP state.\n\n\n\nFigure 2. A diagram illustrating what is meant by a SNP (single point polymorphism)\n\n\nBecause it is extremely rare for a mutation to occur twice at the same site in the genome (perhaps with the exception of Eucalypts), the SNP data are considered to be effectively biallelic. Sites with more than two states that occur rarely are typically eliminated in the quality control steps as they are bundled with multiallelic sites arising from multiple copy sequences (e.g. as would arise from gene duplications) removed during preliminary filtering.\nThe data can be represented as SNP bases (A, T, C or G), with two states for each individual at each locus in a diploid organisms. Alternatively, because the data are biallelic, it is computationally convenient to code the data as 0 for homozyogotes for one allele, 1 for heterozygotes, and 2 for homozygotes of the other allele. The reference allele is arbitrarily taken to be the most common allele, so 0 is the score for homozygous reference, and 2 is the score for homozygous alternate or SNP state. NA indicates that the SNP could not be scored.\nSNP data when using dartR are held in a genlight object that is defined in R package adegenet (Jombart, 2008; Jombart and Ahmed, 2011). The locus metadata included in the genlight object are those provided as part of your Diversity Arrays Technology report. These metadata are obtained from the Diversity Arrays Technology csv file when it is read in to the genlight object. The locus metadata are held in an R data.frame that is associated with the SNP data as part of the genlight object.\nHere is an example of the data structure of a genlight object\n\n\n\n\n\nFor further details go check out the Data Structure tutorial.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Importing and Handling Genomic Data</span>"
    ]
  },
  {
    "objectID": "session01.html#dartr-fundamentals",
    "href": "session01.html#dartr-fundamentals",
    "title": "1  Importing and Handling Genomic Data",
    "section": "dartR Fundamentals",
    "text": "dartR Fundamentals\nTo help us get our head around data interrogation, subsetting, and basic filtering we are going to work through a worked example using a test dataset.\n\n# dartR comes with a built in test dataset called testset.gl. \n# We first examine the contents of testset.gl\ntestset.gl\n\n\n\n\n\n\n\nQuestion time\n\n\n\n This is referring to the testset.gl data set you have interrogated above.\nHow many individuals have been genotyped?\nHow many SNP loci have been scored?\nWhat is the percentage of missing data?\n\n\n\n# Next let us copy the contents of testset.gl to another genlight object called gl.\ngl &lt;- testset.gl\n# Use adegenet accessors to interrogate the genlight object further\nnInd(gl)\nnLoc(gl)\nnPop(gl)\npopNames(gl)\nindNames(gl)\nlocNames(gl)\n\nNow you have a better appreciation of the contents of genlight object gl. pop(gl) is a vector of population names against each individual. Note that it is distinguished from popNames(gl) which just lists the unique names.\n\n# So if you want to tablulate the number of individuals in each population, use\ntable(pop(gl))\n\n\n   EmmacBrisWive    EmmacBurdMist    EmmacBurnBara    EmmacClarJack \n              10               10               11                5 \n   EmmacClarYate    EmmacCoopAvin   EmmacCoopCully    EmmacCoopEulb \n               5               10               10               10 \n  EmmacFitzAllig    EmmacJohnWari    EmmacMaclGeor    EmmacMaryBoru \n              10               10               11                6 \n   EmmacMaryPetr     EmmacMDBBowm     EmmacMDBCond     EmmacMDBCudg \n               4               10               10               10 \n    EmmacMDBForb     EmmacMDBGwyd     EmmacMDBMaci EmmacMDBMurrMung \n              11                9               10               10 \n    EmmacMDBSanf    EmmacNormJack    EmmacNormLeic    EmmacNormSalt \n              10                6                1                1 \n   EmmacRichCasi        EmmacRoss    EmmacRussEube     EmmacTweeUki \n              10               10               10               10 \n   EmsubRopeMata    EmvicVictJasp \n               5                5 \n\n\nWe have learned that typing the name of the genlight object gives its attributes. How do we examine the genotypes in a genlight object. This is done by converting it to a matrix.\n\nas.matrix(gl)[1:7,1:4]\n\n         100049687-12-C/T 100049698-16-G/A 100049728-23-A/G 100049805-56-T/A\nAA010915                2               NA                0                0\nUC_00126                2               NA                0                0\nAA032760               NA               NA                0                0\nAA013214                2               NA                0                0\nAA011723                2               NA                0                0\nAA012411                2               NA                0                0\nAA019237                2               NA                0                0\n\n\nWhat do you see? Is it what you expected for the coding of the SNP scores?\n\nReporting\nLets start over with a focus on reporting.\n\n# Copy the original testset.gl\ngl &lt;- testset.gl\n# Set the global verbosity to 3 – this will result in some detailed comments \n#  as you run each # script\ngl.set.verbosity(3)\n# Now lets use a report function to report the call rate for genlight object gl\ngl.report.callrate(gl)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nNote that the call rate is reported against locus. This is the default. Both a tabulated result and a graph is produced. You can use both to determine a suitable threshold for filtering on callrate.\n\n\nWhat threshold do you think might be appropriate?\nNow let’s report the call rate for genlight object gl by individual.\n\ngl.report.callrate(gl,method=\"ind\")\n\n\n\n\n\n\n\n\nCan you see the difference. Again, both a tabulated result and a graph is produced. You can use both to determine a suitable threshold for filtering on callrate. What threshold do you think might be appropriate?\nWhat about reproducibility?\n\ngl.report.reproducibility(gl)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nRecall that DArT runs a series of technical replicates as part of its routine workflow. This enables an assessment of the quality of data associated with each locus. What threshold do you think might be appropriate for a filter of reproducability?\n\n\n\n\nFiltering\nNow let’s try some filtering. Return to call rate.\n\n# First look at a report to decide a threshold\ngl.report.callrate(gl,method=\"ind\")\n\nStarting gl.report.callrate \n  Processing genlight object with SNP data\n\n  Reporting Call Rate by Individual\n  No. of loci = 255 \n  No. of individuals = 250 \n    Minimum      :  0.7490196 \n    1st quartile :  0.8666667 \n    Median       :  0.8823529 \n    Mean         :  0.8765804 \n    3r quartile  :  0.8941176 \n    Maximum      :  0.9333333 \n    Missing Rate Overall:  0.1234 \n\nListing 30 populations and their average CallRates\n  Monitor again after filtering\n         Population CallRate  N\n1     EmmacBrisWive   0.8839 10\n2     EmmacBurdMist   0.8808 10\n3     EmmacBurnBara   0.8859 11\n4     EmmacClarJack   0.8596  5\n5     EmmacClarYate   0.8769  5\n6     EmmacCoopAvin   0.7682 10\n7    EmmacCoopCully   0.9122 10\n8     EmmacCoopEulb   0.8702 10\n9    EmmacFitzAllig   0.8973 10\n10    EmmacJohnWari   0.8929 10\n11    EmmacMaclGeor   0.8806 11\n12    EmmacMaryBoru   0.8843  6\n13    EmmacMaryPetr   0.8892  4\n14     EmmacMDBBowm   0.8824 10\n15     EmmacMDBCond   0.8855 10\n16     EmmacMDBCudg   0.8878 10\n17     EmmacMDBForb   0.8766 11\n18     EmmacMDBGwyd   0.9050  9\n19     EmmacMDBMaci   0.8773 10\n20 EmmacMDBMurrMung   0.8890 10\n21     EmmacMDBSanf   0.8914 10\n22    EmmacNormJack   0.8725  6\n23    EmmacNormLeic   0.8863  1\n24    EmmacNormSalt   0.8706  1\n25    EmmacRichCasi   0.8757 10\n26        EmmacRoss   0.8706 10\n27    EmmacRussEube   0.8612 10\n28     EmmacTweeUki   0.8773 10\n29    EmsubRopeMata   0.8345  5\n30    EmvicVictJasp   0.8361  5\n\nListing 20 individuals with the lowest CallRates\n  Use this list to see which individuals will be lost on filtering by individual\n  Set ind.to.list parameter to see more individuals\n   Individual    Population  CallRate\n1    AA063722 EmmacCoopAvin 0.7490196\n2    AA063726 EmmacCoopAvin 0.7490196\n3    AA063732 EmmacCoopAvin 0.7647059\n4    AA063720 EmmacCoopAvin 0.7686275\n5    AA063712 EmmacCoopAvin 0.7686275\n6    AA063708 EmmacCoopAvin 0.7725490\n7    AA063718 EmmacCoopAvin 0.7764706\n8    AA063710 EmmacCoopAvin 0.7764706\n9    AA063714 EmmacCoopAvin 0.7764706\n10   AA063716 EmmacCoopAvin 0.7803922\n11   AA032760  EmmacMDBMaci 0.7960784\n12   UC_00210 EmsubRopeMata 0.8196078\n13   UC_00259 EmvicVictJasp 0.8196078\n14   AA018494 EmmacRichCasi 0.8235294\n15   UC_00206 EmsubRopeMata 0.8235294\n16   AA019164 EmmacRussEube 0.8274510\n17   UC_00209 EmsubRopeMata 0.8313725\n18   UC_00254 EmvicVictJasp 0.8313725\n19   AA019159 EmmacRussEube 0.8352941\n20  UC_00126c EmvicVictJasp 0.8352941\n\n)\n\n\n\n\n\n\n\n\n\nCompleted: gl.report.callrate \n\n# Then filter using that threshold\ngl &lt;- gl.filter.callrate(gl, method=\"ind\", threshold=0.80)\n\nStarting gl.filter.callrate \n  Processing genlight object with SNP data\n  Warning: Data may include monomorphic loci in call rate \n                    calculations for filtering\n  Recalculating Call Rate\n  Removing individuals based on Call Rate, threshold = 0.8 \n  Individuals deleted (CallRate &lt;=  0.8 ):\nAA032760[EmmacMDBMaci], AA063718[EmmacCoopAvin], AA063720[EmmacCoopAvin], AA063722[EmmacCoopAvin], AA063726[EmmacCoopAvin], AA063732[EmmacCoopAvin], AA063708[EmmacCoopAvin], AA063710[EmmacCoopAvin], AA063712[EmmacCoopAvin], AA063714[EmmacCoopAvin], AA063716[EmmacCoopAvin],\n  Summary of filtered dataset\n    Call Rate for individuals &gt; 0.8 \n    Original No. of loci : 255 \n    Original No. of individuals: 250 \n    No. of loci retained: 255 \n    No. of individuals retained: 239 \n    No. of populations:  29 \n\n\n\n\n\n\n\n\n\n  Note: Locus metrics not recalculated\n  Note: Resultant monomorphic loci not deleted\nCompleted: gl.filter.callrate \n\n# Use a smear plot for a visual assessment of the effectiveness of filtering\ngl &lt;- testset.gl\nsmear_pre &lt;- gl.smearplot(gl)\n\n  Processing genlight object with SNP data\nStarting gl.smearplot \n\n\n\n\n\n\n\n\n\nCompleted: gl.smearplot \n\n\n\n\n\n\n\n\nTip\n\n\n\nNote the whitespace, which indicates missing data.\n\n\n\n# Filter on callrate by locus, then on individual\ngl &lt;- gl.filter.callrate(gl,verbose=0)\ngl &lt;- gl.filter.callrate(gl, method= \"ind\", threshold=0.80, verbose=0)\n\n# Examine the smearplot again\nsmear_post &lt;- gl.smearplot(gl)\n\n\n\n\n\n\n\n\nWhat has happened. What do you conclude?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Importing and Handling Genomic Data</span>"
    ]
  },
  {
    "objectID": "session01.html#filtering-out-sex-linked-markers",
    "href": "session01.html#filtering-out-sex-linked-markers",
    "title": "1  Importing and Handling Genomic Data",
    "section": "Filtering out sex-linked markers",
    "text": "Filtering out sex-linked markers\nFor this exercise we will use the data of the Leadbeater’s possum (LBP). This data is included in the package dartR.sexlinked\n\n\n\nThe Leadbeater’s possum :)\n\n\n\nLoad data\n\nLBP                   # Explore the dataset\nLBP@n.loc             # Number of SNPs\nlength(LBP@ind.names) # Number of individuals\n\n\n\n\n\n\n\nQuestion time\n\n\n\n\nHow many SNPs and individuals does the LBP genlight object have?\n\n\n\n\nRun gl.report.sexlinked\nThis function identifies sex-linked and autosomal loci present in a SNP dataset (i.e., genlight object) using individuals with known sex. It identifies five types of loci: w-linked or y-linked, sex-biased, z-linked or x-linked, gametologous and autosomal.\n\n\n\n\n\n\nTip\n\n\n\nThe genlight object must contain in gl@other$ind.metrics a column named id, and a column named sex in which individuals with known-sex are assigned M for male, or F for female. The function ignores individuals that are assigned anything else or nothing at all (unknown-sex).\n\n\n\n\n\n\n\n\nCheck\n\n\n\n Check that ind.metrics has the necessary columns:\n\n\n\nhead(LBP@other$ind.metrics)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nid\nsex\npop\nYear.collected\nservice\nplate_location\n\n\n\n\nY2\nY2\nF\nYellingbo\n1997\nDLpos17-2786\n1-A1\n\n\nY16\nY16\nM\nYellingbo\n2001\nDLpos17-2786\n1-A10\n\n\nY17\nY17\nF\nYellingbo\n1997\nDLpos17-2786\n1-A11\n\n\nY18\nY18\nF\nYellingbo\n1999\nDLpos17-2786\n1-A12\n\n\nY3\nY3\nF\nYellingbo\n1997\nDLpos17-2786\n1-A2\n\n\nY4\nY4\nM\nYellingbo\n1997\nDLpos17-2786\n1-A3\n\n\n\n\n\n\n\n\n\n\n\nCheck\n\n\n\n Check the manual of function gl.report.sexlinked to investigate its other requirements:\n\nhelp(gl.report.sexlinked)\n\n\n\nRun the function to identify sex-linked loci in the LBP genlight object:\n\nout &lt;- gl.report.sexlinked(LBP, system = \"xy\")\n\nStarting gl.report.sexlinked \n  Processing genlight object with SNP data\n\n\nDetected 162 females and 211 males.\n\n\nStarting phase 1. May take a while...\n\n\nBuilding call rate plot.\n\n\nDone building call rate plot.\n\n\nStarting phase 2. May take a while...\n\n\nBuilding heterozygosity plot.\n\n\nDone building heterozygosity plot.\n\n\n**FINISHED** Total of analyzed loci: 1000.\nFound 77 sex-linked loci:\n   1 Y-linked loci (yellow)\n   9 sex-biased loci (blue)\n   66 X-linked loci (orange)\n   1 gametologs (green).\nAnd 923 autosomal loci (grey).\n\n\n\n\n\n\n\n\n\nCompleted: gl.report.sexlinked \n\n\n\n\n\n\n\n\nQuestion time\n\n\n\n\nQuestion: Why are we using “xy”?\nQuestion: How many males and females does the dataset contain?\nQuestion: How many sex-linked loci were found?\nThe output consists of two plots, plus a table. Examine the plots.\nQuestion: What do the colours mean in the plots? Look at the figure below for a hint.\n\n\n\nSex-linked loci in XY sex determination systems\n\n\n\n\n\nOutput dataframe\nNow check the output table\n\nout\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nindex\ncount.F.miss\ncount.M.miss\ncount.F.scored\ncount.M.scored\nratio\np.value\np.adjusted\nscoringRate.F\nscoringRate.M\ny.linked\nsex.biased\ncount.F.het\ncount.M.het\ncount.F.hom\ncount.M.hom\nstat\nstat.p.value\nstat.p.adjusted\nheterozygosity.F\nheterozygosity.M\nx.linked\ngametolog\n\n\n\n\n28681424-34-G/T\n1\n0\n1\n162\n210\n1.2953770\n1.0000000\n1\n1.0000000\n0.9952607\nFALSE\nFALSE\n1\n0\n161\n210\n1.303397\n1.0000000\n1.0000000\n0.0061728\n0.0000000\nFALSE\nFALSE\n\n\n28678947-56-C/T\n2\n12\n8\n150\n203\n2.0261283\n0.1638428\n1\n0.9259259\n0.9620853\nFALSE\nFALSE\n9\n7\n141\n196\n1.784196\n0.3044519\n0.9598961\n0.0600000\n0.0344828\nFALSE\nFALSE\n\n\n28680567-32-T/G\n3\n12\n12\n150\n199\n1.3256351\n0.5289429\n1\n0.9259259\n0.9431280\nFALSE\nFALSE\n9\n11\n141\n188\n1.090635\n1.0000000\n1.0000000\n0.0600000\n0.0552764\nFALSE\nFALSE\n\n\n28688313-7-C/G\n4\n0\n0\n162\n211\n1.3015303\n1.0000000\n1\n1.0000000\n1.0000000\nFALSE\nFALSE\n6\n0\n156\n211\n8.076192\n0.0459068\n0.3917911\n0.0370370\n0.0000000\nFALSE\nFALSE\n\n\n28681679-51-C/T\n5\n22\n30\n140\n181\n0.9482168\n0.8814171\n1\n0.8641975\n0.8578199\nFALSE\nFALSE\n1\n1\n139\n180\n1.293900\n1.0000000\n1.0000000\n0.0071429\n0.0055249\nFALSE\nFALSE\n\n\n28681994-14-G/A\n6\n0\n1\n162\n210\n1.2953770\n1.0000000\n1\n1.0000000\n0.9952607\nFALSE\nFALSE\n18\n19\n144\n191\n1.255791\n0.6007790\n1.0000000\n0.1111111\n0.0904762\nFALSE\nFALSE\n\n\n28687273-35-G/A\n7\n2\n2\n160\n209\n1.3052926\n1.0000000\n1\n0.9876543\n0.9905213\nFALSE\nFALSE\n64\n81\n96\n128\n1.053325\n0.8302485\n1.0000000\n0.4000000\n0.3875598\nFALSE\nFALSE\n\n\n\n\n\nonly showing the first 7 rows\n\n\n\nRun gl.drop.sexlinked\nRemove the sex-linked loci from the LBP genlight object:\n\nnew.gl &lt;- gl.drop.sexlinked(LBP, system = \"xy\")\nnew.gl\nnew.gl@n.loc\n\n\n\n\n\n\n\nQuestion time\n\n\n\n How many SNPs are there left after removing sex-linked loci?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Importing and Handling Genomic Data</span>"
    ]
  },
  {
    "objectID": "session01.html#more-filtering",
    "href": "session01.html#more-filtering",
    "title": "1  Importing and Handling Genomic Data",
    "section": "More filtering",
    "text": "More filtering\nKnock yourself out trying all the different report and filtering functions\n\n\n\n\n\n\nTip\n\n\n\nRemember to use them as pairs – report function to decide a threshold, filter function to apply the threshold (where appropriate)\n\n\nBelow are two tables with a number of report and filter functions you can try.\n\nReport functions\n\n\n\n\n\n\n\nReport functions\ndescription\n\n\n\n\ngl.report.callrate\nsummarises CallRate values\n\n\ngl.report.reproducibility\nsummarises repAvg (SNP) or reproducibility (SilicoDArT) values.\n\n\ngl. report.monomorphs\nprovides a count of polymorphic and monomorphic loci\n\n\ngl.report.secondaries\nprovides a count of loci that are secondaries, that is, loci that reside on the one sequence tag.\n\n\ngl.report.rdepth\nreports the estimate of average read depth for each locus\n\n\ngl.report.hamming\nreports on Hamming distances between sequence tags\n\n\ngl.report.overshoot\nreports loci for which the SNP has been trimmed along with the adaptor sequence\n\n\ngl.report.taglength\nreports a frequency tabulation of sequence tag lengths\n\n\ngl.report.sexlinked\nreports the number and type of loci likely to be in sex chromosomes\n\n\n\n\n\nFiltering functions\n\n\n\n\n\n\n\nFilter functions\ndescription\n\n\n\n\ngl.filter.callrate\nfilter out loci or individuals for which the call rate (rate of non-missing values) is less than a specified threshold, say threshold = 0.95\n\n\ngl.filter.reproducibility\nfilter out loci for which the reproducibility (strictly repeatability) is less than a specified threshold, say threshold = 0.99\n\n\ngl. filter.monomorphs\nprovides a count of polymorphic and monomorphic loci\n\n\ngl.filter.allna\nfilter out loci that are all missing values (NA)\n\n\ngl.filter.secondaries\nfilter out SNPs that share a sequence tag, except one retained at random [or the best based on reproducibility (RepAvg) and information content (AvgPIC)].\n\n\ngl.filter.rdepth\nfilter out loci with exceptionally low or high read depth (coverage)\n\n\ngl.filter.hamming\nfilter out loci that differ from each other by less than a specified number of base pairs\n\n\ngl.filter.overshoot\nfilter out loci where the SNP location lies outside the trimmed sequence tag\n\n\ngl.filter.taglength\nfilter out loci for which the tag length is less that a threshold\n\n\ngl.filter.sexlinked\nfilter out loci that are likely to be in sex chromosomes\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nHow about trying it with a different dataset?\n\n\n\n\n\n\n Download SNP data (2 row)\n\n\n\n\n\n\n\n\n\n Download metadata\n\n\n\n\n# how to load a genlight object\ngl &lt;- gl.read.dart(filename=\"./data/sample_data_2Row.csv\", \n                   ind.metafile=\"./data/sample_metadata.csv\")\n\nYou can even try it with your own data.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Importing and Handling Genomic Data</span>"
    ]
  },
  {
    "objectID": "session01.html#further-study",
    "href": "session01.html#further-study",
    "title": "1  Importing and Handling Genomic Data",
    "section": "Further Study",
    "text": "Further Study\nFor more tuturials see the dartR Tutorials section.\nCheck out the other functions contained in package dartR.sexlinked. What do they do?\nKeep your eyes peeled for Session 8!\n\nReadings\nGruber et al. (2018)\nMijangos et al. (2022)\nJombart and Ahmed (2011)\nRobledo-Ruiz et al. (2023)\n\n\n\n\nGruber, Bernd, Peter J. Unmack, Oliver F. Berry, and Arthur Georges. 2018. “DARTR : An R Package to Facilitate Analysis of SNP Data Generated from Reduced Representation Genome Sequencing.” Molecular Ecology Resources 18 (3): 691–99. https://doi.org/10.1111/1755-0998.12745.\n\n\nJombart, T., and I. Ahmed. 2011. “Adegenet 1.3-1: New Tools for the Analysis of Genome-Wide SNP Data.” Bioinformatics. https://doi.org/10.1093/bioinformatics/btr521.\n\n\nMijangos, Jose Luis, Bernd Gruber, Oliver Berry, Carlo Pacioni, and Arthur Georges. 2022. “dartR V2: An Accessible Genetic Analysis Platform for Conservation, Ecology and Agriculture.” Methods in Ecology and Evolution 13 (10): 2150–58. https://doi.org/10.1111/2041-210X.13918.\n\n\nRobledo-Ruiz, Diana A., Lana Austin, J. Nevil Amos, Jesús Castrejón-Figueroa, Daniel K. P. Harley, Michael J. L. Magrath, Paul Sunnucks, and Alexandra Pavlova. 2023. “Easy-to-Use R Functions to Separate Reduced-Representation Genomic Datasets into Sex-Linked and Autosomal Loci, and Conduct Sex Assignment.” Molecular Ecology Resources 0 (n/a). https://doi.org/10.1111/1755-0998.13844.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Importing and Handling Genomic Data</span>"
    ]
  },
  {
    "objectID": "session02.html",
    "href": "session02.html",
    "title": "2  Estimating Effective Population Size and Key Stats",
    "section": "",
    "text": "Required packages\nSession Presenters\nlibrary(dartRverse)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Estimating Effective Population Size and Key Stats</span>"
    ]
  },
  {
    "objectID": "session02.html#introduction",
    "href": "session02.html#introduction",
    "title": "2  Estimating Effective Population Size and Key Stats",
    "section": "Introduction",
    "text": "Introduction\nThis session will cover the basic statistics that are used to study populations, mainly towards a conservation perspective. We will explore how to estimate effective population size (Ne), heterozygosity (Ho, He), and other key statistics using genomic data. The session will include practical exercises using R and the dartRverse packages.\n\n\n\nHoban et al. 2022\n\n\nfor this session you can use your own data, but feel free to use the example data provided in the dartRverse package.\n\ngls &lt;- possums.gl[c(1:5,31:35),1:7]  #small data set",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Estimating Effective Population Size and Key Stats</span>"
    ]
  },
  {
    "objectID": "session02.html#calculating-the-number-of-alleles",
    "href": "session02.html#calculating-the-number-of-alleles",
    "title": "2  Estimating Effective Population Size and Key Stats",
    "section": "Calculating the number of Alleles",
    "text": "Calculating the number of Alleles\nIn conservation genetics, the number of alleles (allelic richness) is important because it reflects the genetic diversity within a population. This diversity is crucial for:\n\nAdaptive potential – more alleles mean a greater chance that some individuals carry beneficial variants to cope with environmental changes or disease.\nLong-term survival – populations with low allelic diversity are more vulnerable to inbreeding, genetic drift, and extinction.\nConservation decision-making – monitoring allele numbers helps identify populations that are genetically depauperate and may need management (e.g., genetic rescue).\n\nIn short: more alleles = higher evolutionary potential.\nThere are two ways to meassure this quantity.\n\nNumber of Alleles (Na) for SNPs:\nSince SNPs are biallelic by design, Na is either 1 or 2.\n\nIf everyone has the same allele → Na = 1 (monomorphic)\n\nIf both alleles are present → Na = 2 (polymorphic)\n\n\n\nAllelic Richness (Ar) for SNPs:\nStill measures how many alleles are present, but adjusted for sample size via rarefaction. In biallelic SNPs, Ar also ranges from 1 to 2, but:\n\nIn small samples, rare alleles might be missed → Ar &lt; Na\nAr estimates the expected number of alleles if the sample had fewer individuals.\n\n\n#by hand number of alleles\nas.matrix(gls[1:5,])\n#count the number of alleles per locus in each population\n\nnas1 &lt;- gl.report.allelerich(gls)\n\n\n\n\n\n\n\n\n\nnas1$`Allelic Richness per population`\n\n  pop sum_corrected_richness mean_corrected_richness popsize      SD\n1   A                     14                2.000000       5 0.00000\n2   B                     12                1.714286       5 0.48795\n\nnas2 &lt;- gl.report.diversity(gls, table = \"D\")\n\nStarting gl.report.diversity \n  Processing genlight object with SNP data\nStarting gl.filter.allna \n  Identifying and removing loci and individuals scored all \n                missing (NA)\n  Deleting loci that are scored as all missing (NA)\n  Deleting individuals that are scored as all missing (NA)\nCompleted: gl.filter.allna \nStarting gl.colors \nSelected color type dis \nCompleted: gl.colors \n\n\n\n\n\n\n\n\n\n\n\n|   | nloci| m_0Da| sd_0Da| m_1Da| sd_1Da| m_2Da| sd_2Da|\n|:--|-----:|-----:|------:|-----:|------:|-----:|------:|\n|A  |     7| 2.000|  0.000| 1.921|  0.076| 1.860|  0.131|\n|B  |     7| 1.714|  0.488| 1.641|  0.453| 1.595|  0.439|\n\n\npairwise non-missing loci\n\n|   |  A|  B|\n|:--|--:|--:|\n|A  | NA| NA|\n|B  |  7| NA|\n\n\n0_D_beta\n\n|   |     A|     B|\n|:--|-----:|-----:|\n|A  |    NA| 0.244|\n|B  | 1.143|    NA|\n\n\n1_D_beta\n\n|   |     A|     B|\n|:--|-----:|-----:|\n|A  |    NA| 0.094|\n|B  | 1.077|    NA|\n\n\n2_D_beta\n\n|   |    A|     B|\n|:--|----:|-----:|\n|A  |   NA| 0.198|\n|B  | 1.16|    NA|\nCompleted: gl.report.diversity \n\n\nA nice function to have is to run a bootstrapped simulation that selects a random sample of individuals and calculates the allelic richness for that sample and compares it from a sample of the same number of individuals from the combined population.\n\ngg &lt;- gl.report.nall(gls, simlevels = 1:10, reps = 20, ncores = 1)  #change the number of cores if you have more available\n\nStarting gl.report.nall \n  Processing genlight object with SNP data\nStarting gl.filter.allna \n  Identifying and removing loci that are all missing (NA) \n                    in any one population\n  Deleting loci that are all missing (NA) in any one population\n  Warning: no loci listed to delete! Genlight object returned unchanged\nCompleted: gl.filter.allna \nStarting gl.colors \nSelected color type dis \nCompleted: gl.colors \n\n\n\n\n\n\n\n\n\nCompleted: gl.report.nall \n\n\n\n\n\n\n\n\nTask\n\n\n\n Rerun the analysis with your own data (or use the glb dataset provided here)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Estimating Effective Population Size and Key Stats</span>"
    ]
  },
  {
    "objectID": "session02.html#calculating-heterozygosity",
    "href": "session02.html#calculating-heterozygosity",
    "title": "2  Estimating Effective Population Size and Key Stats",
    "section": "Calculating Heterozygosity",
    "text": "Calculating Heterozygosity\n\nObserved Heterozygosity (Ho):\nObserved heterozygosity (Ho) is the proportion of individuals in a population that are heterozygous at a given locus. It is calculated as per individual and often averaged per population.\n\ngl.report.heterozygosity(gls, method = \"ind\")\n\nStarting gl.report.heterozygosity \n  Processing genlight object with SNP data\n  Calculating observed heterozygosity for individuals\n  Note: No adjustment for invariant loci (n.invariant set to 0)\nStarting gl.colors \nSelected color type 2 \nCompleted: gl.colors \n\n\n\n\n\n\n\n\n\n ind.name        Ho f.hom.ref f.hom.alt n.Loc\n        1 0.4285714 0.0000000 0.5714286     7\n        2 0.8571429 0.1428571 0.0000000     7\n        3 0.4285714 0.2857143 0.2857143     7\n        4 0.2857143 0.5714286 0.1428571     7\n        5 0.4285714 0.0000000 0.5714286     7\n       31 0.4285714 0.2857143 0.2857143     7\n       32 0.7142857 0.1428571 0.1428571     7\n       33 0.4285714 0.2857143 0.2857143     7\n       34 0.2857143 0.5714286 0.1428571     7\n       35 0.4285714 0.2857143 0.2857143     7\nCompleted: gl.report.heterozygosity \n\ngl.report.heterozygosity(gls, method = \"pop\")\n\nStarting gl.report.heterozygosity \n  Processing genlight object with SNP data\n  Calculating Observed Heterozygosities, averaged across\n                    loci, for each population\n  Calculating Expected Heterozygosities\n\nStarting gl.colors \nSelected color type dis \nCompleted: gl.colors \n\n\n\n\n\n\n\n\n\n  pop n.Ind n.Loc n.Loc.adj polyLoc monoLoc all_NALoc       Ho     HoSD\nA   A     5     7         1       7       0         0 0.485714 0.157359\nB   B     5     7         1       5       2         0 0.457143 0.359894\n      HoSE   He     HeSD     HeSE      uHe    uHeSD    uHeSE      FIS   FISSD\nA 0.059476 0.46 0.038297 0.014475 0.511111 0.042552 0.016083  0.02898 0.36056\nB 0.136027 0.32 0.226274 0.085524 0.355556 0.251416 0.095026 -0.27500 0.33541\n     FISSE\nA 0.136279\nB       NA\nCompleted: gl.report.heterozygosity \n\n\nThere is a lot of discussion on the best way to calculate heterozygosity, but the most common method is to use the proportion of heterozygous individuals at each locus. This is “okay” if you compare individuals and populations of the same species (but see Sopniewski and Catullo 2022 and Schmidt et al. 2021 for a discussion on the limitations of this approach). The main problem is that when filtering for low quality (low read depth) often heterozygous loci are lost, which can bias the results. In addition to calculate a comparable heterozygosity across species, we would need to know the number of invariant sites, which are not easily obtained. dartR aims to estimate this number from closely neighbouring loci, if you are using dartR data (secondaries). This estimate is based on a Poisson distribution assumption which is most likely not a good idea as it underestimates the number of invariant sites. We are currently aiming to implement a better method to estimate the number of invariant sites, but for now we will use the gl.report.heterozygosity function to calculate Ho. Schmidt et al. (2021) suggests to calculate genome-wide/autosomal heterozygosity, but it basically means you need whole genome sequences, which is often not available. In summary be careful to calculate Heterozygosity, especially when comparing across species or uneven sampled populations. A rarefaction approach is often used to standardise the sample size. We can do that with the gl.report.heterozygosity function, which allows us to calculate Ho for each individual and then average it per population in combination of gl.subsample.ind() function.\n\n#Create a sample data sets \n# (two populations, once with 10 individuals and one with 5 individuals)\n\ngls1 &lt;- possums.gl[c(1:10, 31:35),]\n\n#cr\nsubfun &lt;- function(x) { \n  xx &lt;- gl.subsample.ind(x, n = 5, replace = TRUE, verbose = 0)\n  out &lt;- gl.report.heterozygosity(xx, method = \"pop\", verbose = 0)\n  return(out$Ho)\n  \n  }\n\nsubfun(gls1)\n\n  Warning: Input genlight objects both lack individual metrics\n\n\n[1] 0.343 0.436\n\nsubfun(gls1)\n\n  Warning: Input genlight objects both lack individual metrics\n\n\n[1] 0.366 0.433\n\n\n\n#ignore the warnings\nres &lt;- sapply(1:50, function(x) subfun(gls1)) \n\n\nrownames(res) &lt;- popNames(gls1)\nboxplot(t(res))\n\n\n\n\n\n\n\nsummary(t(res))\n\n       A                B         \n Min.   :0.3060   Min.   :0.4240  \n 1st Qu.:0.3360   1st Qu.:0.4350  \n Median :0.3450   Median :0.4380  \n Mean   :0.3457   Mean   :0.4376  \n 3rd Qu.:0.3590   3rd Qu.:0.4410  \n Max.   :0.3780   Max.   :0.4440  \n\n\n\n\n\n\n\n\nTask\n\n\n\n Try with your own data set\n\n\n\n\nExpected Heterozygosity (He)\nExpected heterozygosity (He) is a key measure of genetic diversity in conservation genetics, representing the probability that two alleles randomly drawn from a population are different. High He indicates a genetically diverse population, which is critical for adaptive potential and long-term viability. In contrast, low He can signal inbreeding, genetic drift, or population bottlenecks. Monitoring He helps conservationists assess population health, guide management actions such as translocations or genetic rescue, and evaluate the success of captive breeding programs in maintaining genetic variation..\n\nDecline of Heterozygosity Over Time in an Ideal Population\nIn an ideal population, the expected heterozygosity (He) declines over time due to genetic drift, even in the absence of selection, mutation, or migration. The rate of this decline is governed by the effective population size (Ne) and follows this mathematical law:\n\\[\nH_t = H_0 \\left(1 - \\frac{1}{2N_e} \\right)^t\n\\]\n\n( H_0 ): initial heterozygosity\n\n( H_t ): heterozygosity after ( t ) generations\n\n( N_e ): effective population size\n\n( (1 - ) ): per-generation retention of heterozygosity\n\n\n\nInterpretation\n\nLarger ( N_e ) → slower loss of He\n\nSmall ( N_e ) → rapid loss of He due to drift\n\nThis law underscores why maintaining a large Ne is a central goal in conservation: to preserve genetic variation over time and reduce the risk of inbreeding and loss of adaptive potential.\nExpected heterozygosity (He) is a key measure of genetic diversity in conservation genetics, representing the probability that two alleles randomly drawn from a population are different. High He indicates a genetically diverse population, which is critical for adaptive potential and long-term viability. In contrast, low He can signal inbreeding, genetic drift, or population bottlenecks. Monitoring He helps conservationists assess population health, guide management actions such as translocations or genetic rescue, and evaluate the success of captive breeding programs in maintaining genetic variation.\n\ngg &lt;- gl.report.heterozygosity(gls)\n\n\n\n\n\n\n\n\n\ngg\n\n  pop n.Ind n.Loc n.Loc.adj polyLoc monoLoc all_NALoc       Ho     HoSD\nA   A     5     7         1       7       0         0 0.485714 0.157359\nB   B     5     7         1       5       2         0 0.457143 0.359894\n      HoSE   He     HeSD     HeSE      uHe    uHeSD    uHeSE      FIS   FISSD\nA 0.059476 0.46 0.038297 0.014475 0.511111 0.042552 0.016083  0.02898 0.36056\nB 0.136027 0.32 0.226274 0.085524 0.355556 0.251416 0.095026 -0.27500 0.33541\n     FISSE\nA 0.136279\nB       NA\n\n\nExpected heterozygosity can be standardised by sample size (because allele frequencies are estimated and they are missing rare alleles at low sample size, hence is biased downwards. Therefore the correction is 2n/(2n-1) where n is the number of individuals. This is then called uHe, but is mainly important due to low sample sizes. Again you can use a rarefaction approach to standardise the sample size, which is implemented in the gl.report.heterozygosity function.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Estimating Effective Population Size and Key Stats</span>"
    ]
  },
  {
    "objectID": "session02.html#hardy-weinberg-equilibrium-hwe",
    "href": "session02.html#hardy-weinberg-equilibrium-hwe",
    "title": "2  Estimating Effective Population Size and Key Stats",
    "section": "Hardy-Weinberg Equilibrium (HWE)",
    "text": "Hardy-Weinberg Equilibrium (HWE)\nHWE is a principle that describes the genetic variation in a population under certain conditions. It states that allele and genotype frequencies will remain constant from generation to generation in the absence of evolutionary influences.\nIn conservation genetics, testing for HWE is important because:\n\nDeviations from HWE can indicate inbreeding, genetic drift, or selection pressures.\nHelps identify populations at risk of losing genetic diversity.\nCan inform management strategies to maintain genetic health.\n\nTo test for HWE, we can use the gl.report.hwe function, which performs a chi-squared test for each locus and returns the p-values.\nThis can be done on population level (subset=“each”) or on the whole dataset (subset=“all”).\n\n#does not make much sense (sample size too low)\ngl.report.hwe(gls,subset = \"each\",min_sample_size = 1 )\n\nRegistered S3 methods overwritten by 'ggtern':\n  method           from   \n  grid.draw.ggplot ggplot2\n  plot.ggplot      ggplot2\n  print.ggplot     ggplot2\n\n\n`geom_line()`: Each group consists of only one observation.\nℹ Do you need to adjust the group aesthetic?\n`geom_line()`: Each group consists of only one observation.\nℹ Do you need to adjust the group aesthetic?\n\n\n\n\n\n\n\n\n\n\n# only 10 loci... Lets try with more\ngl.report.hwe(possums.gl[1:90,],subset = \"each\")\n\nStarting gl.report.hwe \n  Processing genlight object with SNP data\n  Analysing each population separately\nStarting gl.colors \nSelected color type 2c \nCompleted: gl.colors \n\n\n\n\n\n\n\n\n\n    Reporting significant departures from Hardy-Weinberg \n            Equilibrium\n    NB: Departures significant at the alpha level of 0.05 are listed\n    Adjustment of p-values for multiple comparisons vary\n                    with sample size\n Population  Locus Hom_1   Het Hom_2     N         Prob    Sig Prob.adj Sig.adj\n     &lt;char&gt; &lt;char&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;num&gt;        &lt;num&gt; &lt;char&gt;   &lt;lgcl&gt;  &lt;lgcl&gt;\n          B   X114    19     7     4    30 0.0481152745    sig       NA      NA\n          B   X120    22     5     3    30 0.0322894276    sig       NA      NA\n          B   X123     3    24     3    30 0.0026880391    sig       NA      NA\n          C   X128    10    20     0    30 0.0108195955    sig       NA      NA\n          C   X140     4    22     4    30 0.0261558384    sig       NA      NA\n          B   X142     2    21     7    30 0.0275978824    sig       NA      NA\n          A   X152    18     7     5    30 0.0248050366    sig       NA      NA\n          B   X171    22     5     3    30 0.0322894276    sig       NA      NA\n          B   X177     1    24     5    30 0.0009308178    sig       NA      NA\n          A   X181     4     7    19    30 0.0481152745    sig       NA      NA\n          B   X198     9     9    12    30 0.0324438457    sig       NA      NA\n          A    X30    11    19     0    30 0.0279783750    sig       NA      NA\n          B    X31     3    22     5    30 0.0250646233    sig       NA      NA\n          B    X47     6    22     2    30 0.0118328520    sig       NA      NA\n          A    X48     3    22     5    30 0.0250646233    sig       NA      NA\n          A    X50     5    23     2    30 0.0079779773    sig       NA      NA\n          B    X55    11    19     0    30 0.0279783750    sig       NA      NA\n          B    X65     8     7    15    30 0.0066040187    sig       NA      NA\n  npop\n &lt;int&gt;\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n     1\n\nCompleted: gl.report.hwe",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Estimating Effective Population Size and Key Stats</span>"
    ]
  },
  {
    "objectID": "session02.html#inbreeding-fis",
    "href": "session02.html#inbreeding-fis",
    "title": "2  Estimating Effective Population Size and Key Stats",
    "section": "Inbreeding FIS",
    "text": "Inbreeding FIS\nInbreeding coefficient (FIS) is a measure of the degree of inbreeding in a population. It quantifies the reduction in heterozygosity due to inbreeding compared to a randomly mating population. A positive FIS indicates inbreeding, while a negative value suggests outbreeding or excess heterozygosity.\n\ngl.report.heterozygosity(gls)\n\nStarting gl.report.heterozygosity \n  Processing genlight object with SNP data\n  Calculating Observed Heterozygosities, averaged across\n                    loci, for each population\n  Calculating Expected Heterozygosities\n\nStarting gl.colors \nSelected color type dis \nCompleted: gl.colors \n\n\n\n\n\n\n\n\n\n  pop n.Ind n.Loc n.Loc.adj polyLoc monoLoc all_NALoc       Ho     HoSD\nA   A     5     7         1       7       0         0 0.485714 0.157359\nB   B     5     7         1       5       2         0 0.457143 0.359894\n      HoSE   He     HeSD     HeSE      uHe    uHeSD    uHeSE      FIS   FISSD\nA 0.059476 0.46 0.038297 0.014475 0.511111 0.042552 0.016083  0.02898 0.36056\nB 0.136027 0.32 0.226274 0.085524 0.355556 0.251416 0.095026 -0.27500 0.33541\n     FISSE\nA 0.136279\nB       NA\nCompleted: gl.report.heterozygosity",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Estimating Effective Population Size and Key Stats</span>"
    ]
  },
  {
    "objectID": "session02.html#fixed-and-private-alleles",
    "href": "session02.html#fixed-and-private-alleles",
    "title": "2  Estimating Effective Population Size and Key Stats",
    "section": "Fixed and private Alleles",
    "text": "Fixed and private Alleles\nPrivate alleles are alleles found only in a single population, while fixed alleles are alleles that occur at 100% frequency within a population. In conservation genetics, private alleles can indicate unique evolutionary history or local adaptation and are useful for identifying distinct populations or units for conservation. Fixed alleles, on the other hand, may signal a loss of genetic diversity due to drift or inbreeding. Monitoring both helps assess population structure, track gene flow, and guide decisions about mixing or isolating populations. Private alleles can also be used to identify assymetry in geneflow (Campbell et al. 2021).\n\nPrivate Alleles\n\ngl.map.interactive(possums.gl[1:120,])\n\nStarting gl.map.interactive \n  Processing genlight object with SNP data\nCompleted: gl.map.interactive \n\n\n\n\n\ngl.report.pa(possums.gl[1:120,] )\n\nStarting gl.report.pa \n  Processing genlight object with SNP data\n  Warning: no loci listed to keep! Genlight object returned unchanged\n  Warning: no loci listed to keep! Genlight object returned unchanged\n  p1 p2 pop1 pop2 N1 N2 fixed priv1 priv2 Chao1 Chao2 totalpriv   AFD asym\n1  1  2    A    B 30 30     0     1    24    NA     0        25 0.309   NA\n2  1  3    A    C 30 30     0     1    24    NA     0        25 0.302   NA\n3  1  4    A    D 30 30     2    49    21     0     0        70 0.370   NA\n4  2  3    B    C 30 30     0     0     0     0     0         0 0.180   NA\n5  2  4    B    D 30 30     1    52     1     0    NA        53 0.332   NA\n6  3  4    C    D 30 30     1    52     1     0    NA        53 0.314   NA\n  asym.sig\n1       NA\n2       NA\n3       NA\n4       NA\n5       NA\n6       NA\n  Table of private alleles and fixed differences returned\nCompleted: gl.report.pa \n\n\n\n\nFixed Alleles\n\ngl.fixed.diff(possums.gl[1:120,])  \n\nStarting gl.fixed.diff \n  Processing genlight object with SNP data\n  Comparing populations for absolute fixed differences\n  Monomorphic loci removed\n  Comparing populations pairwise -- this may take time. Please be patient\nCompleted: gl.fixed.diff \n\n\n$gl\n ********************\n *** DARTR OBJECT ***\n ********************\n\n ** 120 genotypes,  200 SNPs , size: 233.8 Kb\n\n    missing data: 0 (=0 %) scored as NA\n\n ** Genetic data\n   @gen: list of 120 SNPbin\n   @ploidy: ploidy of each individual  (range: 2-2)\n\n ** Additional data\n   @ind.names:  120 individual labels\n   @loc.names:  200 locus labels\n   @loc.all:   no allele labels\n   @pop: population of each individual (group size range: 30-30)\n   @other: a list containing: xy, loc.metrics, loc.metrics.flags, verbose, history, latlon \n   @other$latlon[g]: coordinates for all individuals are attached\n\n$fd\n  A B C\nB 0    \nC 0 0  \nD 2 1 1\n\n$pcfd\n  A B C\nB 0    \nC 0 0  \nD 1 0 0\n\n$nobs\n   A  B  C  D\nA NA 60 60 60\nB 60 NA 60 60\nC 60 60 NA 60\nD 60 60 60 NA\n\n$nloc\n    A   B   C   D\nA  NA 200 200 200\nB 200  NA 200 200\nC 200 200  NA 200\nD 200 200 200  NA\n\n$expfpos\n     [,1] [,2] [,3] [,4]\n[1,]   NA   NA   NA   NA\n[2,]   NA   NA   NA   NA\n[3,]   NA   NA   NA   NA\n[4,]   NA   NA   NA   NA\n\n$sdfpos\n     [,1] [,2] [,3] [,4]\n[1,]   NA   NA   NA   NA\n[2,]   NA   NA   NA   NA\n[3,]   NA   NA   NA   NA\n[4,]   NA   NA   NA   NA\n\n$pval\n     [,1] [,2] [,3] [,4]\n[1,]   NA   NA   NA   NA\n[2,]   NA   NA   NA   NA\n[3,]   NA   NA   NA   NA\n[4,]   NA   NA   NA   NA\n\nattr(,\"class\")\n[1] \"fd\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Estimating Effective Population Size and Key Stats</span>"
    ]
  },
  {
    "objectID": "session02.html#relatedness-and-kinship",
    "href": "session02.html#relatedness-and-kinship",
    "title": "2  Estimating Effective Population Size and Key Stats",
    "section": "Relatedness and Kinship",
    "text": "Relatedness and Kinship\nRelatedness and kinship are measures of genetic relatedness between individuals in a population. They are crucial for understanding population structure, mating systems, and the potential for inbreeding.\nRelatedness in dartRverse is calculated via the gl.grm function:\nBased on the A.mat function (package rrBLUP) R estimates a genomic additive relationship matrix (GRM) based on SNP genotype data. The matrix it produces approximates realized additive genetic relationships between individuals, capturing shared alleles weighted by allele frequencies. The additive relationship matrix (often denoted AA) quantifies the expected proportion of alleles shared identical-by-descent (IBD) between individuals due to additive genetic effects. This generates an n×n matrix where each entry reflects the genomic similarity between two individuals.\nEach entry \\(A_ij\\) reflects the expected genetic relatedness between individuals i and j under the additive genetic model. Diagonal entries \\(A_ii\\) represent the self-relatedness or inbreeding coefficient (1+Fi). Offf-diagonals \\(A_ij\\) represent the proportion of alleles shared IBD between individuals. It produces values centered around 0 (unrelated) and 1 (identical).\n\n#simulate some relatedness data\n\nglsim &lt;- gl.sim.Neconst(ninds = 50, nlocs = 1000)\nAmat &lt;- gl.grm(glsim)\n\nStarting gl.grm \n  Processing genlight object with SNP data\n  Processing genlight object with SNP data\n\n\n\n\n\n\n\n\n\nCompleted: gl.grm \n\n### F is diag(A)-1\n# centered around 1\nhist(diag(Amat)-1)\n\n\n\n\n\n\n\n#proportion of shared alleles  IBD between individuals\nrelA &lt;- Amat\ndiag(relA)&lt;-NA \nhist(relA)\n\n\n\n\n\n\n\n\nSo we have created a population of 50 individuals with 1000 loci, and calculated the Amat. The diagonal entries represent the inbreeding coefficient (1+Fi), so Fi is centered around 0, indicating that individuals are not highly inbred. The off-diagonal entries represent the proportion of alleles shared IBD between individuals, which is centered around 0, indicating that individuals are not closely related. As we have simulated theindividuals, we know that they are not related, so this is expected.\nNow lets add some offsprings to the mix and see how the turn up in the A mat.\n\n#create an 10 offsprings from indivivdual 1 and 2\noffsprings &lt;- gl.sim.offspring(glsim[1,], glsim[2,], noffpermother = 10, popname = \"off12\")\nglsimoff &lt;- rbind(glsim, offsprings)\n\nAmat &lt;- gl.grm(glsimoff)\n\nStarting gl.grm \n  Processing genlight object with SNP data\n  Processing genlight object with SNP data\n\n\n\n\n\n\n\n\n\nCompleted: gl.grm \n\n\nAnd here you can see the offsprings in the A mat, they are related to the parents (1 and 2) and to each other, but not to the rest of the population. There relatedness value (the proportion of alleles that individuals share IBD at any locus) is 0.5 (the expected value for half siblings and offsprings).\n\n# matrix between offsprings and parents\n\nApo &lt;- Amat[c(1,2,51:60),c(1,2,51:60) ]\nround(Apo,2)\n\n          1     2 Po_1 Po_2 Po_3 Po_4 Po_5 Po_6 Po_7 Po_8 Po_9 Po_10\n1      0.83 -0.13 0.32 0.31 0.38 0.34 0.39 0.35 0.32 0.31 0.32  0.34\n2     -0.13  0.83 0.40 0.31 0.31 0.29 0.37 0.35 0.33 0.32 0.30  0.36\nPo_1   0.32  0.40 0.93 0.31 0.37 0.30 0.45 0.42 0.38 0.36 0.29  0.37\nPo_2   0.31  0.31 0.31 0.81 0.25 0.29 0.32 0.30 0.30 0.24 0.32  0.41\nPo_3   0.38  0.31 0.37 0.25 0.93 0.31 0.40 0.30 0.35 0.22 0.35  0.31\nPo_4   0.34  0.29 0.30 0.29 0.31 0.82 0.29 0.35 0.35 0.24 0.32  0.37\nPo_5   0.39  0.37 0.45 0.32 0.40 0.29 0.95 0.35 0.31 0.43 0.24  0.38\nPo_6   0.35  0.35 0.42 0.30 0.30 0.35 0.35 0.86 0.39 0.28 0.35  0.36\nPo_7   0.32  0.33 0.38 0.30 0.35 0.35 0.31 0.39 0.83 0.27 0.33  0.36\nPo_8   0.31  0.32 0.36 0.24 0.22 0.24 0.43 0.28 0.27 0.86 0.31  0.32\nPo_9   0.32  0.30 0.29 0.32 0.35 0.32 0.24 0.35 0.33 0.31 0.83  0.28\nPo_10  0.34  0.36 0.37 0.41 0.31 0.37 0.38 0.36 0.36 0.32 0.28  0.90\n\n## only related to parents and each other\nrelpo &lt;- Apo\ndiag(relpo)&lt;-NA\nhist(relpo, main = \"Relatedness between offsprings and parents\", xlab = \"Relatedness\", ylab = \"Frequency\")\n\n\n\n\n\n\n\n\nNow lets look at the kinship matrix, which is calculated via the gl.run.EMIBD9 function. For this function to work you need to have the emibd9 package installed. An easy way to do so, is using the gl.download.binary in the dartRverse package. We asked for permission from the Author ()\n\n#install emibd9 from Wang 2022 in the temporary directory\ndir_emibd &lt;- './binaries/'\ndir &lt;- gl.download.binary(\"emibd9\", out.dir = dir_emibd)\n\nDownloaded binary to  C:\\Users\\ejstr\\AppData\\Local\\Temp\\RtmpyGf7Vq\\file124410f6598 \nUnzipped binary to ./binaries//emibd9\n\n\nWhen estimating relatedness and kinship, there is one major difficulty. We need to have a good estimate of the allele frequencies in the population. If we have a population with a lot of missing data, or if we have a population with a lot of inbred individuals the estimates of relatedness and kinship will be biased. In the best case you would estimate allele frequencies from a sample of unrelated individuals and then use these allele frequencies to estimate relatedness and kinship in the whole population. However, this is rarely possible, especially in conservation genetics where we often work with small populations and have only one sample\nEMIBD9 is aiming to take care of that, but using an algorithm that aims to estimate allele frequencies and kinship in a ‘shinkage’ fashion so both at the same time and optimising the result. It performs really well in simulations. Please note there are many other relatedness estimates, but they all suffer from this problem and often give negative results, which in principle should not happen. Lets use EMIBD9 to estimate the kinship matrix for our simulated population.\n\n#ignore the warnings...\nkinmat &lt;- gl.run.EMIBD9(glsimoff, Inbreed = 1, emibd9.path = dir_emibd)\n\nStarting gl.run.EMIBD9 \n  Processing genlight object with SNP data\n  Found necessary files to run EMIBD9.\nExporting individual diversity and inbreeding values \n  Returning a list containing the input gl object, a square matrix  of pairwise kinship, and the raw EMIBD9 results table as follows:\n           $rel -- a square matrix of relatedness \n           $raw -- raw EMIBD9 results table \n           $processed -- EMIBD9 results without self and redundant comparison \n           $inbreeding -- Individual diversity and inbreeding (if requested) \nStarting gl.colors \nSelected color type div \nCompleted: gl.colors \n\n\nFound more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics'\n\n\nAlso defined by 'spam'\n\n\nRegistered S3 method overwritten by 'dendextend':\n  method     from \n  rev.hclust vegan\n\n\n\n\n\n\n\n\n\nCompleted: gl.run.EMIBD9 \n\n\nAs before we find the related individuals. Lets check the results as before:\n\n### F is diag(kinmat$rel)-1\nhist((2*diag(kinmat$rel) - 1), main = \"Kinship\", xlab = \"Kinship\", ylab = \"Frequency\" )\n\n\n\n\n\n\n\n#kinship values between parents and offsprings and between offsprings =0.25\nkinpo &lt;- kinmat$rel[c(1,2,51:60),c(1,2,51:60) ]\ndiag(kinpo)&lt;- NA\nhist(kinpo, main = \"Kinship between offsprings and parents\", xlab = \"Kinship\", ylab = \"Frequency\" )\n\n\n\n\n\n\n\n#variance is different. \n#Parent off spring variance is zero.\n\nFinally lets compare the relatedness estimates using gl.grm and EMIBD9. The results are very similar, but in theory the EMIBD9 estimates should be more precise, as they take into account the non independence of allele frequencies in the population.\n\n#compare the two matrices\nArel &lt;- Amat[lower.tri(Amat, diag = FALSE)]\nkinrel &lt;- kinmat$rel[lower.tri(kinmat$rel, diag = FALSE)]\nplot(Arel, kinrel, \n     xlab = \"Relatedness (gl.grm)\", \n     ylab = \"Kinship (EMIBD9)\", \n     main = \"Comparison of F values from gl.grm and EMIBD9\",\n     pch = 19, col = \"blue\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Estimating Effective Population Size and Key Stats</span>"
    ]
  },
  {
    "objectID": "session02.html#effective-population-size",
    "href": "session02.html#effective-population-size",
    "title": "2  Estimating Effective Population Size and Key Stats",
    "section": "Effective Population Size",
    "text": "Effective Population Size\n\nCurrent effective population size\nEffective population size (Ne) is the size of an idealized population that would experience genetic drift or inbreeding at the same rate as the observed population.\nIt is almost always smaller than the actual census size (N) due to factors like unequal sex ratios, variation in reproductive success, or population size fluctuations.\n\n#install the Neestimator package\n\ndir &lt;- dartRverse::gl.download.binary(\"neestimator\", out.dir = tempdir())\n\nDownloaded binary to  C:\\Users\\ejstr\\AppData\\Local\\Temp\\RtmpyGf7Vq\\file124431876020 \nUnzipped binary to C:\\Users\\ejstr\\AppData\\Local\\Temp\\RtmpyGf7Vq/neestimator\n\n\n\n#simulate a population of 50 individuals with 1000 loci\n\nsim50 &lt;- gl.sim.Neconst(ninds = 50, nlocs = 3000)\n#need to reproduce a bit (to get the population to be in Hardy-Weinberg equilibrium)\n\nsim50 &lt;- gl.sim.offspring(sim50, sim50, noffpermother = 1) #ideal population\nsim50 &lt;- gl.sim.offspring(sim50, sim50, noffpermother = 1) #ideal population\nsim50 &lt;- gl.sim.offspring(sim50, sim50, noffpermother = 1) #ideal population\nsim50 &lt;- gl.sim.offspring(sim50, sim50, noffpermother = 1) #ideal population\nsim50 &lt;- gl.sim.offspring(sim50, sim50, noffpermother = 1) #ideal population\n\n\ngg &lt;-gl.LDNe(sim50, neest.path = dir, mating = \"random\", critical = c(0.1,0.05))\n\nStarting gl.LDNe \n  Processing genlight object with SNP data\nStarting gl2genepop \n  Processing genlight object with SNP data\n  The genepop file is saved as:  C:\\Users\\ejstr\\AppData\\Local\\Temp\\RtmpyGf7Vq/dummy.gen/\nCompleted: gl2genepop \n  Processing genlight object with SNP data\n\n\n\n\n\n\n\n\n\n$offspring_Po\n                    Statistic Frequency 1 Frequency 2 Frequency 3 Frequency 4\n Lowest Allele Frequency Used       0.100       0.050       No S*          0+\n    Harmonic Mean Sample Size          50          50          50          50\n      Independent Comparisons      662976     1195831     1725153     1947351\n                  OverAll r^2    0.027755    0.027571    0.026941     0.02643\n          Expected r^2 Sample    0.021276    0.021276    0.021276    0.021276\n                Estimated Ne^        49.3        50.8        56.7        62.5\n            CI low Parametric        48.5        50.2        56.1        61.9\n           CI high Parametric          50        51.4        57.3        63.2\n             CI low JackKnife        37.7        39.6        45.1        50.3\n            CI high JackKnife        67.6        67.9          74        80.6\n\n  The results are saved in: C:\\Users\\ejstr\\AppData\\Local\\Temp\\RtmpyGf7Vq/genepopLD.txt \nCompleted: gl.LDNe \n\n\n\n\nHistoric population sizes\n\n#install the Neestimator package\n\ndir &lt;- dartRverse::gl.download.binary(\"epos\", out.dir = tempdir())\n\nDownloaded binary to  C:\\Users\\ejstr\\AppData\\Local\\Temp\\RtmpyGf7Vq\\file124457e62304 \nUnzipped binary to C:\\Users\\ejstr\\AppData\\Local\\Temp\\RtmpyGf7Vq/epos\n\n\n\ngl.sfs(sim50)\n\nStarting gl.sfs \n  Processing genlight object with SNP data\n\n\n\n\n\n\n\n\n\nCompleted: gl.sfs \n\n\n  d0   d1   d2   d3   d4   d5   d6   d7   d8   d9  d10  d11  d12  d13  d14  d15 \n1026  116  129  111   71   98   72   85   70   70   64   54   57   49   34   37 \n d16  d17  d18  d19  d20  d21  d22  d23  d24  d25  d26  d27  d28  d29  d30  d31 \n  38   37   34   25   30   37   24   22   16   18   30   19   22   30   26   29 \n d32  d33  d34  d35  d36  d37  d38  d39  d40  d41  d42  d43  d44  d45  d46  d47 \n  34   27   22    9   21   18   17   17   26   25   26   25   17   30   17   34 \n d48  d49  d50 \n  19   23   13 \n\n\n\n#parameters for epos\n# mutation rate\nu =1e-8  #from simulation\n\n#To get L we need estimate the Length of the genome in base pairs.\n# watterson estimate for a sample of 50 is 4.499\nL &lt;- sum(gl.sfs(sim50)[-1])/( 4 * 50 *1e-8 * 4.499)\n\nStarting gl.sfs \n  Processing genlight object with SNP data\n\n\n\n\n\n\n\n\n\nCompleted: gl.sfs \n\ngepos &lt;- gl.run.epos(sim50, epos.path = dir, L=L, u=u, boot=10, minbinsize = 2)\n\n  Processing genlight object with SNP data\n  Output written to C:\\Users\\ejstr\\AppData\\Local\\Temp\\RtmpyGf7Vq/epos.out \n\n\n\n\n\n\n\n\n\nCompleted: gl.run.epos \n\n\n\nCGED example\n\nlibrary(dartRverse)\nnorth &lt;- readRDS(\"./data/TympoNorth.rds\")\n\n\n#filters \nnorth2 &lt;- gl.filter.callrate(north, method = \"loc\", threshold = 0.95)\n\nStarting gl.filter.callrate \n  Processing genlight object with SNP data\n  Warning: data include loci that are scored NA across all individuals.\n  Consider filtering using gl &lt;- gl.filter.allna(gl)\n  Warning: Data may include monomorphic loci in call rate \n                    calculations for filtering\n  Recalculating Call Rate\n  Removing loci based on Call Rate, threshold = 0.95 \n\n\n\n\n\n\n\n\n\nCompleted: gl.filter.callrate \n\nnorth3 &lt;- gl.filter.rdepth(north2, lower = 10, upper=40)\n\nStarting gl.filter.rdepth \n  Processing genlight object with SNP data\n  Removing loci with rdepth &lt;= 10 and &gt;= 40 \n\n\n\n\n\n\n\n\n\nCompleted: gl.filter.rdepth \n\nnorth4 &lt;- gl.filter.monomorphs(north3)\n\nStarting gl.filter.monomorphs \n  Processing genlight object with SNP data\n  Identifying monomorphic loci\n  Removing monomorphic loci and loci with all missing \n                       data\nCompleted: gl.filter.monomorphs \n\nnorth5 &lt;- gl.filter.callrate(north4, threshold = 0.9, method=\"ind\")\n\nStarting gl.filter.callrate \n  Processing genlight object with SNP data\n  Recalculating Call Rate\n  Removing individuals based on Call Rate, threshold = 0.9 \n\n\n\n\n\n\n\n\n\n  Note: Locus metrics not recalculated\n  Note: Resultant monomorphic loci not deleted\nCompleted: gl.filter.callrate \n\n#checks\nnorth5\n\n ********************\n *** DARTR OBJECT ***\n ********************\n\n ** 121 genotypes,  10,832 SNPs , size: 44.6 Mb\n\n    missing data: 13360 (=1.02 %) scored as NA\n\n ** Genetic data\n   @gen: list of 121 SNPbin\n   @ploidy: ploidy of each individual  (range: 2-2)\n\n ** Additional data\n   @ind.names:  121 individual labels\n   @loc.names:  10832 locus labels\n   @loc.all:  10832 allele labels\n   @position: integer storing positions of the SNPs [within 69 base sequence]\n   @pop: population of each individual (group size range: 121-121)\n   @other: a list containing: loc.metrics, latlon, loc.metrics.flags, verbose, history \n   @other$latlon[g]: coordinates for all individuals are attached\n\ngl.sfs(north5)\n\nStarting gl.sfs \n  Processing genlight object with SNP data\nYour data contains missing data, better filter stronger or use gl.impute to fill those gaps meaningful!\n\n\n\n\n\n\n\n\n\nCompleted: gl.sfs \n\n\n  d0   d1   d2   d3   d4   d5   d6   d7   d8   d9  d10  d11  d12  d13  d14  d15 \n   0  747  557  375  244  203  165  154  118  125  122  114  114  122  107  115 \n d16  d17  d18  d19  d20  d21  d22  d23  d24  d25  d26  d27  d28  d29  d30  d31 \n  96  106  102   96  104  106   79  105  103   98   78   89   86   79   91   89 \n d32  d33  d34  d35  d36  d37  d38  d39  d40  d41  d42  d43  d44  d45  d46  d47 \n  86   89   83  101   95   78   83   87   53   90   77   89   78   76   73   90 \n d48  d49  d50  d51  d52  d53  d54  d55  d56  d57  d58  d59  d60  d61  d62  d63 \n  66   75   88  100   75   70   71   80   75   72   77   54   81   74   63   67 \n d64  d65  d66  d67  d68  d69  d70  d71  d72  d73  d74  d75  d76  d77  d78  d79 \n  65   90   64   63   70   49   72   74   60   61   72   60   50   70   62   71 \n d80  d81  d82  d83  d84  d85  d86  d87  d88  d89  d90  d91  d92  d93  d94  d95 \n  49   70   70   64   69   58   62   51   76   51   63   54   59   56   44   61 \n d96  d97  d98  d99 d100 d101 d102 d103 d104 d105 d106 d107 d108 d109 d110 d111 \n  51   61   54   54   76   42   49   62   43   49   56   37   53   53   53   62 \nd112 d113 d114 d115 d116 d117 d118 d119 d120 d121 \n  67   60   60   61   55   66   53   43   58   39 \n\nnInd(north5)\n\n[1] 121\n\nnLoc(north5)\n\n[1] 10832\n\n### takes 10 minutes or so....\n#curNe &lt;- gl.LDNe(north5, neest.path = dir, critical = 0.05)  #-&gt; ~40\n\n\n#for dart data (times 75), 69+\nL &lt;- nLoc(north5)*75*200\nmu = 16.17e-9\n\n\n# takes a minute or so\ngg &lt;- gl.run.epos(north5, epos.path = dir,L = L, u = mu, \n                  method = \"greedy\", depth = 2, boot=5)\n\n  Processing genlight object with SNP data\n  Output written to C:\\Users\\ejstr\\AppData\\Local\\Temp\\RtmpyGf7Vq/epos.out \n\n\n\n\n\n\n\n\n\nCompleted: gl.run.epos \n\ngg$plot",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Estimating Effective Population Size and Key Stats</span>"
    ]
  },
  {
    "objectID": "session02.html#further-study",
    "href": "session02.html#further-study",
    "title": "2  Estimating Effective Population Size and Key Stats",
    "section": "Further Study",
    "text": "Further Study\n\n\n\n\n\n\nExercise\n\n\n\n Now run your own data set (or use the tympo data set) to study any of the topics from the tutorial. Have fun !!!\n\n\n\nReadings\n\nCampbell, C.D., Cowan, P., Gruber, B. et al. Has the introduction of two subspecies generated dispersal barriers among invasive possums in New Zealand?. Biol Invasions 23, 3831–3845 (2021). https://doi.org/10.1007/s10530-021-02609-1\nSchmidt, T. L., Jasper, M.-E., Weeks, A. R., & Hoffmann, A. A. (2021). Unbiased population heterozygosity estimates from genome-wide sequence data. Methods in Ecology and Evolution, 12, 1888–1898. https://doi.org/10.1111/2041-210X.13659\nSopniewski J, Catullo RA. Estimates of heterozygosity from single nucleotide polymorphism markers are context-dependent and often wrong. Mol Ecol Resour. 2024 May;24(4):e13947. doi: 10.1111/1755-0998.13947. Epub 2024 Mar 3. PMID: 38433491.\nWang, J. (2022). A joint likelihood estimator of relatedness and allele frequencies from a small sample of individuals. Methods in Ecology and Evolution, 13(11), 2443-2462.\nWaples, R. S. (2006). “A bias correction for estimates of effective population size based on linkage disequilibrium at unlinked gene loci*.” Conservation Genetics 7(2): 167-184.\nWaples, R. K., et al. (2016). “Estimating contemporary effective population size in non-model species using linkage disequilibrium across thousands of loci.” Heredity 117(4): 233-240.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Estimating Effective Population Size and Key Stats</span>"
    ]
  },
  {
    "objectID": "session03.html",
    "href": "session03.html",
    "title": "3  Identifying Population Structure",
    "section": "",
    "text": "Required packages\nSession Presenters\nAs always we need to have dartRverse installed and loaded. In addition you need to have dartR.popgen installend.\nlibrary(dartRverse)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Identifying Population Structure</span>"
    ]
  },
  {
    "objectID": "session03.html#uncovering-population-structure",
    "href": "session03.html#uncovering-population-structure",
    "title": "3  Identifying Population Structure",
    "section": "Uncovering Population Structure",
    "text": "Uncovering Population Structure\n\nIntroduction\nWhy population structure matters\n\nWhat is a “population” in population genetics?\nGenetic structure defined – how allele frequencies vary among groups.\nKey drivers: effective population size, gene flow/immigration, natural selection, drift.\nIsolation-by-distance & sampling design – avoiding spurious structure.\nWhy we care: management units, inbreeding, local adaptation, introgression.\n\n\nAnalytical toolkit\n\n\n\n\n\n\n\n\nApproach\nPurpose\ndartR entry point\n\n\nPCoA / PCA\nQuick multivariate overview\ngl.pcoa(), gl.pcoa.plot()\n\n\nSTRUCTURE\nBayesian clustering\ngl.run.structure(), gl.plot.structure(), gl.map.structure()\n\n\nfastSTRUCTURE\nFast variational STRUCTURE (Mac/Linux)\ngl.run.faststructure(), gl.plot.faststructure()\n\n\nsNMF\nSparse non-negative matrix factorisation\ngl.run.snmf(), gl.plot.snmf(), gl.map.snmf()\n\n\nPOPCLUSTER\nUltra-fast admixture inference\ngl.run.popcluster(), gl.plot.popcluster(), gl.map.popcluster()\n\n\n\n\n\n\nExample\nTo help us understand our analytical toolkit better let’s start with a simple example using a simulated dataset.\nThe dataset is a genlight object and contains 10 populations of 30 individuals each and 1000 loci and is part of the dartRverse package. The populations are fairly independent but are linked by some imigration, so a typical Metapopulation scenario. The populations are named A to J and follow more or less an isolation by distance (actually an isolation by resistance model). So population next to each other (e.g. B and C) are fairly well mixed and populations further apart from the rest (e.g. D) are more isolated.\nTo simplify this further we limit our exercise to the first 150 individuals only (which entails now 5 populations a 30 individuals, A to E). To get an overview on the population we use the function: gl.map.interactive which plots the individuals on a map. Please note the genlight/dartR object needs to have valid lat long coordinates for each individual to be able to do so.\nLets get started.\n\nPCA\n\n# Read in the simulated possum data\ngl &lt;- possums.gl[1:150,]\n# Interrogate to see what the data are\nnLoc(gl)\n\n[1] 200\n\nnInd(gl)\n\n[1] 150\n\ntable(pop(gl))\n\n\n A  B  C  D  E \n30 30 30 30 30 \n\n# SNP coding for individuals 1-5 and loci 1-8\nas.matrix(gl)[1:5, 1:8]\n\n  X1 X2 X3 X4 X5 X6 X7 X8\n1  1  2  1  2  2  2  1  2\n2  1  1  1  1  1  1  0  1\n3  2  0  2  0  1  1  1  1\n4  0  1  2  0  0  1  0  1\n5  1  2  1  2  2  2  1  0\n\n\nThe next step is to actually calculate genetic difference between individuals. We do this by measuring euclidean distance but it is worth remembering that there are a myriad of different distances we can use. There are five different options for the function we will using, gl.dist.ind, that may be worth exploring depending on the context of your data.\nThe distance measure for SNP genotypes can be one of:\n\nEuclidean Distance\nScaled Euclidean Distance\nSimple Mismatch Distance\nAbsolute Mismatch Distance\nCzekanowski (Manhattan) Distance\n\nBut lets stick with euclidean distance for now. Euclidean distance is quite simple it treats\npossum.gl\n\n# Calculate an Euclidean Distance Matrix on individuals\nD &lt;- gl.dist.ind(gl)\n\n\n\n\n\n\n\n# Represent visually as a heat map\ngl.plot.heatmap(D)\n\nWarning in rep(col, length.out = leaves_length): 'x' is NULL so the result will\nbe NULL\n\n\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\nWarning in rep(if (nam %in% names(L)) L[[nam]] else default, length.out =\nindx): 'x' is NULL so the result will be NULL\n\n\n\n\n\n\n\n\n\n\n# Undertake a PCA on the raw data\npc &lt;- gl.pcoa(gl, verbose = 3)\n\nStarting gl.pcoa \n  Processing genlight object with SNP data\n  Performing a PCA, individuals as entities, loci as attributes, SNP genotype as state\n\n\n\n\n\n\n\n\n\n  Ordination yielded 4 informative dimensions( broken-stick criterion) from 149 original dimensions\n    PCA Axis 1 explains 15.5 % of the total variance\n    PCA Axis 1 and 2 combined explain 30.8 % of the total variance\n    PCA Axis 1-3 combined explain 41.2 % of the total variance\nStarting gl.colors \nSelected color type 2 \nCompleted: gl.colors \n\n\n\n\n\n\n\n\n\nCompleted: gl.pcoa \n\n\n\n# Plot the first two dimensions of the PCA\npc_a1a2 &lt;- gl.pcoa.plot(pc,gl,pop.labels=\"legend\")\n\n\n\n\n\n\n\n# Plot the first and third dimensions of the PCA\npc_a1a3 &lt;- gl.pcoa.plot(pc,gl,xaxis=1,yaxis=3, pop.labels=\"legend\")\n\n\n\n\n\n\n\n\n\n\nSelect one cluster\n\n# Select only the data from one cluster in the primary PCA\ntemp &lt;- gl.drop.pop(gl, pop.list=c('D', 'A'))\n\nStarting gl.drop.pop \n  Processing genlight object with SNP data\n  Checking for presence of nominated populations, deleting them\n  Warning: Resultant dataset may contain monomorphic loci\n  Locus metrics not recalculated\nCompleted: gl.drop.pop \n\n# Plot the first two dimensions of the secondary PCA\npc &lt;- gl.pcoa(temp, verbose = 3)\n\nStarting gl.pcoa \n  Processing genlight object with SNP data\n  Performing a PCA, individuals as entities, loci as attributes, SNP genotype as state\n\n\n\n\n\n\n\n\n\n  Ordination yielded 2 informative dimensions( broken-stick criterion) from 89 original dimensions\n    PCA Axis 1 explains 22.9 % of the total variance\n    PCA Axis 1 and 2 combined explain 30.5 % of the total variance\n    PCA Axis 1-3 combined explain NA % of the total variance\nStarting gl.colors \nSelected color type 2 \nCompleted: gl.colors \n\n\n\n\n\n\n\n\n\nCompleted: gl.pcoa \n\npc_plot &lt;- gl.pcoa.plot(pc, temp,pop.labels=\"legend\")\n\nStarting gl.pcoa.plot \n  Processing an ordination file (glPca)\n  Processing genlight object with SNP data\n  Plotting populations identified by a legend\n  Preparing plot .... please wait\n\n\n\n\n\n\n\n\n\nCompleted: gl.pcoa.plot \n\n\n\n\n\nWhat can go wrong\nMissing data causes distortion, which can lead to misinterpretation.\ndartR, that uses the adgenet package for its pca, fills missing data with the global average.\nYou can choose alternative methods of filling in the missing data prior to running your pca using the gl.impute function.\nPCA is a hypothesis generating tool, not a tool for definitive decisions of the structure of populations.\nStructure variants can also turn up on a PCA, like an inversion.\nPCA is sample size dependent - but this is more for the top two dimensions not all the informative dimensions.\n\n\nStructure and FastStructure\nTo run STRUCTURE from within R, we need to install the non-GUI executable (the version without frontend) for your operating system [e.g windows, mac or linux]. You can download STRUCTURE for your OS from http://web.stanford.edu/group/pritchardlab/structure_software/release_versions/v2.3.4/html/structure.html.\nTo let R know where the executable is, you need to set the path to the executable. For example, under windows, if you have the executable in d:/programms/structure/structure.exe, you can use the command below.\n\n\nRunning STRUCTURE\n\nsrnoad &lt;- gl.run.structure(possums, k.range = 2:7, num.k.rep = 10, exec =\n                             './binaries/structure.exe',plot.out = FALSE,\n                           burnin=50, numreps=100, # this is just for a test run\n                         # burnin=50000, numreps=100000, # for robust results\n                           noadmix=FALSE)\n\nev &lt;- gl.evanno(srnoad)\n\nqmatnoad &lt;- gl.plot.structure(srnoad2, K=4, clumpak = TRUE)\n\n\ngm &lt;- gl.map.structure(qmat = qmatnoad, x = possums, K=3, scalex=1, scaley=0.5 )\n\n\n\n\n\n\n\nExercise: Study the results using different Ks and with/without admixture\n\n\n\n The above run was a structure run using the no-admixture model for a range of K=2:7. Study the results by plotting it for various Ks and try to interpret the results in the light of the simulated population structure.\nHow about trying it on your own data or the example data provided.\n\n\n\n\nsnmf\n\n\nPopclusture",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Identifying Population Structure</span>"
    ]
  },
  {
    "objectID": "session03.html#exercise",
    "href": "session03.html#exercise",
    "title": "3  Identifying Population Structure",
    "section": "Exercise",
    "text": "Exercise\nFun example on real data.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Identifying Population Structure</span>"
    ]
  },
  {
    "objectID": "session03.html#further-study",
    "href": "session03.html#further-study",
    "title": "3  Identifying Population Structure",
    "section": "Further Study",
    "text": "Further Study\nPdfs/links\n\nReadings\n• Evanno et al. 2005 – Detecting the number of clusters (ΔK).\n• Lawson et al. 2018 – How not to over-interpret STRUCTURE/ADMIXTURE plots.\n• Wang 2017 – Common pitfalls when using STRUCTURE.\n• Raj et al. 2014 – fastSTRUCTURE.\n• Frichot et al. 2014 – sNMF.\n• Wang 2022 – POPCLUSTER.\n• Kopelman et al. 2015 – CLUMPAK.\n• Jakobsson & Rosenberg 2007 – CLUMPP.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Identifying Population Structure</span>"
    ]
  },
  {
    "objectID": "session04.html",
    "href": "session04.html",
    "title": "4  Kinship, Pedigrees & Mating Recommendations",
    "section": "",
    "text": "Required packages\nSession Presenters\nlibrary(dartR.base)\nlibrary(dartR.data)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Kinship, Pedigrees & Mating Recommendations</span>"
    ]
  },
  {
    "objectID": "session04.html#session-content",
    "href": "session04.html#session-content",
    "title": "4  Kinship, Pedigrees & Mating Recommendations",
    "section": "Session Content",
    "text": "Session Content",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Kinship, Pedigrees & Mating Recommendations</span>"
    ]
  },
  {
    "objectID": "session04.html#further-study",
    "href": "session04.html#further-study",
    "title": "4  Kinship, Pedigrees & Mating Recommendations",
    "section": "Further Study",
    "text": "Further Study\n\nReadings",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Kinship, Pedigrees & Mating Recommendations</span>"
    ]
  },
  {
    "objectID": "session05.html",
    "href": "session05.html",
    "title": "5  Assigning Individuals to Populations",
    "section": "",
    "text": "Required packages\nSession Presenter\nlibrary(dartRverse)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Assigning Individuals to Populations</span>"
    ]
  },
  {
    "objectID": "session05.html#introduction",
    "href": "session05.html#introduction",
    "title": "5  Assigning Individuals to Populations",
    "section": "Introduction",
    "text": "Introduction\n\n\n\nEmydura River Turtle\n\n\nWe will explore four analysis for assignment of an individual of unknown provenance to a source population.\n\nGenotype Likelihood: The likelihood of drawing the unknown from a population with the observed allele frequencies is calculated assuming Hardy-Weinberg equilibrium.\nPrivate Alleles: A focal unknown individual is likely to have fewer private alleles in comparison with its source population than in comparison with other putative source populations.\nPCA: The genotype of a focal unknown individual is likely to lie within the confidence envelope of its source population than within the confidence envelope of other putative source populations.\nMahalanobis Distance: The distances of the focal unknown individual from the centroids of the standardized confidence envelops of its putative source populations are used to calculate a z-scores and associated probabilities of assignment.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Assigning Individuals to Populations</span>"
    ]
  },
  {
    "objectID": "session05.html#emydura-population-assignment",
    "href": "session05.html#emydura-population-assignment",
    "title": "5  Assigning Individuals to Populations",
    "section": "Emydura population assignment",
    "text": "Emydura population assignment\nHere is some context for our turtle example, below are two maps. The first is a map of eastern mainland Australia showing the distribution of the Emydura macquarii complex, the river drainage basins in which it occurs, and the broad regions, The second is of Northern Australia and Papua New Guinea.\n\n\n\nGeorges et al. 2018\n\n\n\n\n\nGeorges et al. 2025, in review\n\n\n\nLoad data\n\n# We will first set the verbosity globally to level 3\ngl.set.verbosity(3)\n\nStarting gl.set.verbosity \n  Global verbosity set to: 3 \nCompleted: gl.set.verbosity \n\n\n\n# Read in the data set for the worked example\ngl &lt;- readRDS(\"./data/assignment_example1.Rdata\")\n# Familiarize yourself with its contents\ngl  \n\n ********************\n *** DARTR OBJECT ***\n ********************\n\n ** 835 genotypes,  20,688 SNPs , size: 57.3 Mb\n\n    missing data: 289548 (=1.68 %) scored as NA\n\n ** Genetic data\n   @gen: list of 835 SNPbin\n   @ploidy: ploidy of each individual  (range: 2-2)\n\n ** Additional data\n   @ind.names:  835 individual labels\n   @loc.names:  20688 locus labels\n   @loc.all:  20688 allele labels\n   @position: integer storing positions of the SNPs [within 69 base sequence]\n   @pop: population of each individual (group size range: 3-30)\n   @other: a list containing: loc.metrics, ind.metrics, latlon, loc.metrics.flags, verbose, history \n    @other$ind.metrics: id, pop, lat, lon, sex, maturity, collector, location, basin, drainage, service, plate_location \n    @other$loc.metrics: AlleleID, CloneID, AlleleSequence, SNP, SnpPosition, CallRate, OneRatioRef, OneRatioSnp, FreqHomRef, FreqHomSnp, FreqHets, PICRef, PICSnp, AvgPIC, AvgCountRef, AvgCountSnp, RepAvg, clone, uid, rdepth, monomorphs, maf, OneRatio, PIC, TrimmedSequence \n   @other$latlon[g]: coordinates for all individuals are attached\n\nnLoc(gl)\n\n[1] 20688\n\nnInd(gl)\n\n[1] 835\n\nnPop(gl)\n\n[1] 81\n\n# Display a list of populations and sample sizes\ntable(pop(gl))\n\n\n         Brisbane          Burdekin           Burnett          Clarence \n               10                10                11                10 \n     Cooper_Alvin      Cooper_Cully  Cooper_Eulbertie        Dumaresque \n               10                10                10                10 \nFitzroy_Alligator  Fitzroy_Carnavan  Fitzroy_Fairburn     Fraser_Island \n               10                10                10                10 \n           Hunter     EmmacJohnWari     EmmacMaclGeor              Mary \n               10                10                11                10 \n     EmmacMDBBarr      EmmacMDBBarw     EmmacMDBBooth      EmmacMDBBowm \n               10                10                 9                10 \n     EmmacMDBBurr      EmmacMDBCond      EmmacMDBCudg  EmmacMDBDarlBour \n               10                10                10                10 \n EmmacMDBDarlWeth      EmmacMDBDart      EmmacMDBEulo      EmmacMDBForb \n               10                10                10                10 \n     EmmacMDBGoul        GurraGurra      EmmacMDBGwyd      EmmacMDBLach \n               10                10                10                10 \n     EmmacMDBLodd      EmmacMDBMaci      EmmacMDBMoon  EmmacMDBMurrGunb \n               10                10                10                10 \n EmmacMDBMurrLock  EmmacMDBMurrMorg  EmmacMDBMurrMung  EmmacMDBMurrMurr \n               10                10                10                10 \n EmmacMDBMurrTink EmmacMDBMurrYarra      EmmacMDBOven  EmmacMDBParoBiny \n               10                10                10                10 \n     EmmacMDBPind      EmmacMDBSanf      EmmacMDBToon          Normanby \n               10                10                11                11 \n             Pine     EmmacRichCasi         EmmacRoss      EmmacTweeUki \n               10                10                10                10 \n     EmsubBamuAli     EmsubBamuAwab     EmsubMorehead      EmsubFlyGuka \n               10                 9                16                10 \n     EmsubFlyJikw      EmsubJardine       EmsubKerema       EmsubKikori \n               30                16                10                 4 \n       EmworRoper        EmtanBlyth      EmtanFinniss     EmtanHolrChai \n               11                10                 7                10 \n    EmtanMitchell     EmtanMitcMitc     EmtanPascFarm      EmtanWenlock \n                9                 3                 9                10 \n        EmvicDaly     EmvicDrysdale        Fitzroy_WA     EmvicIsdeBell \n               10                10                10                12 \n    EmvicKingMool          EmvicOrd     EmworClavPung         EmworDaly \n               10                18                10                10 \n    EmworDalySlei     EmworLeicAlex     EmworLimmNath     EmworLiveMann \n                7                10                10                 9 \n    EmworNichGreg \n               12 \n\n\n\n\n\n\n\n\nNote\n\n\n\nSeveral populations have sample sizes less than 10 and will be discarded during the analysis\n\n\n\n\nAssignment by genotype likelihood\n\ngen.result&lt;-gl.assign.on.genotype(gl, unknown=\"AA011731\", nmin=10)\n\nStarting gl.assign.on.genotype \n  Processing genlight object with SNP data\n          population Log Likelihood        AIC        dAIC        AIC.wt assign\n3            Burnett      -4926.957   9853.914      0.0000  1.000000e+00    yes\n16              Mary      -5341.050  10682.101    828.1863 1.450906e-180     no\n1           Brisbane     -19251.444  38502.888  28648.9733  0.000000e+00     no\n2           Burdekin     -32844.476  65688.953  55835.0384  0.000000e+00     no\n4           Clarence     -31620.048  63240.095  53386.1808  0.000000e+00     no\n5       Cooper_Alvin     -42008.293  84016.586  74162.6716  0.000000e+00     no\n6       Cooper_Cully     -42849.639  85699.278  75845.3633  0.000000e+00     no\n7   Cooper_Eulbertie     -42636.382  85272.764  75418.8497  0.000000e+00     no\n8         Dumaresque     -28852.254  57704.509  47850.5946  0.000000e+00     no\n9  Fitzroy_Alligator     -12133.240  24266.480  14412.5655  0.000000e+00     no\n10  Fitzroy_Carnavan     -13118.904  26237.808  16383.8939  0.000000e+00     no\n11  Fitzroy_Fairburn     -12281.682  24563.364  14709.4500  0.000000e+00     no\n12     Fraser_Island     -17364.115  34728.231  24874.3162  0.000000e+00     no\n13            Hunter     -49665.375  99330.751  89476.8365  0.000000e+00     no\n14     EmmacJohnWari     -35711.561  71423.121  61569.2070  0.000000e+00     no\n15     EmmacMaclGeor     -37389.885  74779.769  64925.8549  0.000000e+00     no\n17      EmmacMDBBarr     -29473.892  58947.783  49093.8690  0.000000e+00     no\n18      EmmacMDBBarw     -29276.257  58552.514  48698.5994  0.000000e+00     no\n19      EmmacMDBBowm     -30859.543  61719.085  51865.1709  0.000000e+00     no\n20      EmmacMDBBurr     -32296.475  64592.951  54739.0361  0.000000e+00     no\n21      EmmacMDBCond     -25487.072  50974.145  41120.2302  0.000000e+00     no\n22      EmmacMDBCudg     -29695.945  59391.891  49537.9762  0.000000e+00     no\n23  EmmacMDBDarlBour     -28964.950  57929.900  48075.9852  0.000000e+00     no\n24  EmmacMDBDarlWeth     -27302.477  54604.954  44751.0400  0.000000e+00     no\n25      EmmacMDBDart     -33067.630  66135.261  56281.3466  0.000000e+00     no\n26      EmmacMDBEulo     -20835.127  41670.254  31816.3394  0.000000e+00     no\n27      EmmacMDBForb     -32680.705  65361.409  55507.4948  0.000000e+00     no\n28      EmmacMDBGoul     -29137.664  58275.328  48421.4131  0.000000e+00     no\n29        GurraGurra     -29715.298  59430.595  49576.6806  0.000000e+00     no\n30      EmmacMDBGwyd     -29369.851  58739.701  48885.7868  0.000000e+00     no\n31      EmmacMDBLach     -32476.968  64953.935  55100.0211  0.000000e+00     no\n32      EmmacMDBLodd     -29746.861  59493.723  49639.8084  0.000000e+00     no\n33      EmmacMDBMaci     -28944.433  57888.866  48034.9512  0.000000e+00     no\n34      EmmacMDBMoon     -29257.025  58514.050  48660.1356  0.000000e+00     no\n35  EmmacMDBMurrGunb     -28266.313  56532.626  46678.7116  0.000000e+00     no\n36  EmmacMDBMurrLock     -29738.313  59476.625  49622.7109  0.000000e+00     no\n37  EmmacMDBMurrMorg     -29058.787  58117.573  48263.6589  0.000000e+00     no\n38  EmmacMDBMurrMung     -29471.357  58942.715  49088.8005  0.000000e+00     no\n39  EmmacMDBMurrMurr     -29727.568  59455.137  49601.2226  0.000000e+00     no\n40  EmmacMDBMurrTink     -28706.653  57413.305  47559.3909  0.000000e+00     no\n41 EmmacMDBMurrYarra     -29584.123  59168.246  49314.3315  0.000000e+00     no\n42      EmmacMDBOven     -29769.909  59539.819  49685.9045  0.000000e+00     no\n43  EmmacMDBParoBiny     -30378.843  60757.686  50903.7713  0.000000e+00     no\n44      EmmacMDBPind     -32423.222  64846.444  54992.5292  0.000000e+00     no\n45      EmmacMDBSanf     -30946.657  61893.315  52039.4005  0.000000e+00     no\n46      EmmacMDBToon     -21983.158  43966.316  34112.4020  0.000000e+00     no\n47          Normanby     -42201.524  84403.048  74549.1332  0.000000e+00     no\n48              Pine      -8578.105  17156.211   7302.2964  0.000000e+00     no\n49     EmmacRichCasi     -25491.051  50982.103  41128.1884  0.000000e+00     no\n50         EmmacRoss     -34003.894  68007.788  58153.8734  0.000000e+00     no\n51      EmmacTweeUki     -20216.624  40433.249  30579.3343  0.000000e+00     no\n52      EmsubBamuAli     -84564.461 169128.921 159275.0068  0.000000e+00     no\n53     EmsubMorehead     -81201.565 162403.130 152549.2157  0.000000e+00     no\n54      EmsubFlyGuka     -83272.339 166544.677 156690.7630  0.000000e+00     no\n55      EmsubFlyJikw     -79486.100 158972.200 149118.2860  0.000000e+00     no\n56      EmsubJardine     -86359.491 172718.983 162865.0685  0.000000e+00     no\n57       EmsubKerema     -94433.639 188867.278 179013.3636  0.000000e+00     no\n58        EmworRoper     -84920.595 169841.191 159987.2763  0.000000e+00     no\n59        EmtanBlyth    -103876.148 207752.297 197898.3826  0.000000e+00     no\n60     EmtanHolrChai    -101420.838 202841.676 192987.7618  0.000000e+00     no\n61      EmtanWenlock    -101328.752 202657.504 192803.5897  0.000000e+00     no\n62         EmvicDaly     -85769.402 171538.805 161684.8903  0.000000e+00     no\n63     EmvicDrysdale     -97248.693 194497.386 184643.4716  0.000000e+00     no\n64        Fitzroy_WA     -96787.705 193575.409 183721.4946  0.000000e+00     no\n65     EmvicIsdeBell     -95745.919 191491.838 181637.9234  0.000000e+00     no\n66     EmvicKingMool     -96702.092 193404.185 183550.2704  0.000000e+00     no\n67          EmvicOrd     -93520.359 187040.717 177186.8030  0.000000e+00     no\n68     EmworClavPung     -88270.073 176540.145 166686.2306  0.000000e+00     no\n69         EmworDaly     -90298.465 180596.931 170743.0165  0.000000e+00     no\n70     EmworLeicAlex     -91795.194 183590.389 173736.4745  0.000000e+00     no\n71     EmworLimmNath     -91979.158 183958.316 174104.4020  0.000000e+00     no\n72     EmworNichGreg     -85210.317 170420.635 160566.7205  0.000000e+00     no\n  Warning: parameter by must be either 'join.by.ind' or 'join.by.loc', set to default 'join.by.loc'\nCompleted: gl.assign.on.genotype \n\n\n\n\nAssignment by Private Alleles\n\npa.result &lt;- gl.assign.pa(gl, unknown=\"AA011731\", nmin=10, alpha=0.05)\n\nStarting gl.assign.pa \n  Processing genlight object with SNP data\n  Discarding 9 populations with sample size &lt; 10 :\n                 pop count    Z-score  p-value assign\n16              Mary    81 -0.1692350 0.567194    yes\n3            Burnett    77  0.2743299 0.391916    yes\n49              Pine   167  1.1555039 0.123942    yes\n22      EmmacMDBCond   785  2.0204271 0.021670     no\n47      EmmacMDBToon   668  2.7347470 0.003121     no\n15     EmmacMaclGeor  1040  3.4791497 0.000252     no\n69         EmvicDaly  1284  3.5437788 0.000197     no\n20      EmmacMDBBowm   992  3.6051586 0.000156     no\n81     EmworNichGreg  1260  3.8784997 0.000053     no\n61        EmworRoper  1273  4.1008215 0.000021     no\n25  EmmacMDBDarlWeth   865  4.8762430 0.000001     no\n1           Brisbane   523 17.1445337 0.000000     no\n2           Burdekin   821 15.7683126 0.000000     no\n4           Clarence   915 14.1798931 0.000000     no\n5       Cooper_Alvin   992 15.6406240 0.000000     no\n6       Cooper_Cully  1008 18.1191005 0.000000     no\n7   Cooper_Eulbertie  1001  9.1930282 0.000000     no\n8         Dumaresque   929 31.3868949 0.000000     no\n9  Fitzroy_Alligator   306 11.4289937 0.000000     no\n10  Fitzroy_Carnavan   339 10.2951686 0.000000     no\n11  Fitzroy_Fairburn   303  7.6467045 0.000000     no\n12     Fraser_Island   457  5.0064421 0.000000     no\n13            Hunter  1340 12.4578521 0.000000     no\n14     EmmacJohnWari   893 11.1739703 0.000000     no\n17      EmmacMDBBarr   940 26.7349588 0.000000     no\n18      EmmacMDBBarw   937 26.1751262 0.000000     no\n19     EmmacMDBBooth  1035 15.7478733 0.000000     no\n21      EmmacMDBBurr  1025 15.2447327 0.000000     no\n23      EmmacMDBCudg   952 18.4925912 0.000000     no\n24  EmmacMDBDarlBour   916 13.1037035 0.000000     no\n26      EmmacMDBDart  1079 14.9852921 0.000000     no\n27      EmmacMDBEulo   639  6.1130987 0.000000     no\n28      EmmacMDBForb  1051  5.2168208 0.000000     no\n29      EmmacMDBGoul   922 12.4532508 0.000000     no\n30        GurraGurra   957 13.0155533 0.000000     no\n31      EmmacMDBGwyd   940 23.3109909 0.000000     no\n32      EmmacMDBLach  1053 17.7866486 0.000000     no\n33      EmmacMDBLodd   950 16.0172441 0.000000     no\n34      EmmacMDBMaci   925 15.1899478 0.000000     no\n35      EmmacMDBMoon   928 21.5894040 0.000000     no\n36  EmmacMDBMurrGunb   898  7.6464411 0.000000     no\n37  EmmacMDBMurrLock   959  8.1186128 0.000000     no\n38  EmmacMDBMurrMorg   922 15.3803498 0.000000     no\n39  EmmacMDBMurrMung   946 15.3622303 0.000000     no\n40  EmmacMDBMurrMurr   958 27.7218281 0.000000     no\n41  EmmacMDBMurrTink   912 11.1714406 0.000000     no\n42 EmmacMDBMurrYarra   950 27.2732611 0.000000     no\n43      EmmacMDBOven   949 27.2094137 0.000000     no\n44  EmmacMDBParoBiny   975 11.8093091 0.000000     no\n45      EmmacMDBPind  1037 25.1472989 0.000000     no\n46      EmmacMDBSanf   995 20.6254532 0.000000     no\n48          Normanby  1014  8.9353965 0.000000     no\n50     EmmacRichCasi   727 23.4264098 0.000000     no\n51         EmmacRoss   853 16.4775772 0.000000     no\n52      EmmacTweeUki   591 10.7132631 0.000000     no\n53      EmsubBamuAli  1286 23.2269725 0.000000     no\n54     EmsubBamuAwab  1285 16.8725666 0.000000     no\n55     EmsubMorehead  1238 21.7595831 0.000000     no\n56      EmsubFlyGuka  1268 25.9689306 0.000000     no\n57      EmsubFlyJikw  1226 17.9295179 0.000000     no\n58      EmsubJardine  1287 10.9701686 0.000000     no\n59       EmsubKerema  1370  5.1264437 0.000000     no\n60       EmsubKikori  1326 20.7904053 0.000000     no\n62        EmtanBlyth  1396  8.9673202 0.000000     no\n63      EmtanFinniss  1382  7.6892448 0.000000     no\n64     EmtanHolrChai  1361 10.7419476 0.000000     no\n65     EmtanMitchell  1343  5.4248309 0.000000     no\n66     EmtanMitcMitc  1369 12.8371209 0.000000     no\n67     EmtanPascFarm  1365 17.4254784 0.000000     no\n68      EmtanWenlock  1351 10.6423539 0.000000     no\n70     EmvicDrysdale  1365 13.7459176 0.000000     no\n71        Fitzroy_WA  1372 10.2841962 0.000000     no\n72     EmvicIsdeBell  1355 14.7314585 0.000000     no\n73     EmvicKingMool  1363 24.4944007 0.000000     no\n74          EmvicOrd  1333 12.5867638 0.000000     no\n75     EmworClavPung  1299 22.5017244 0.000000     no\n76         EmworDaly  1307  5.2935238 0.000000     no\n77     EmworDalySlei  1321  4.8949185 0.000000     no\n78     EmworLeicAlex  1324 15.9637009 0.000000     no\n79     EmworLimmNath  1322  5.7857267 0.000000     no\n80     EmworLiveMann  1331 19.8407465 0.000000     no\n  Warning: parameter by must be either 'join.by.ind' or 'join.by.loc', set to default 'join.by.loc'\nCompleted: gl.assign.pa \n\n\n\n\nAssignment by PCA\n\npca_pa_result &lt;-gl.assign.pca(pa.result, unknown=\"AA011731\")\n\nStarting gl.assign.pca \nStarting gl.keep.pop \n  Processing genlight object with SNP data\n  Checking for presence of nominated populations\n  Retaining only populations Unknown \n  Locus metrics not recalculated\nCompleted: gl.keep.pop \n  Discarding 0 populations with sample size &lt; nmin = 10 :\n\n\nFound more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics'\n\n\nAlso defined by 'spam'\n\n\nFound more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics'\n\n\nAlso defined by 'spam'\n\n\n  Calculating a PCA to represent the unknown in the context\n                   of putative sources\n\n\n\n\n\n\n\n\n\nStarting gl.colors \nSelected color type 2 \nCompleted: gl.colors \n\n\n\n\n\n\n\n\n\n  Eliminating populations for which the unknown is outside\n                   their confidence envelope\n  Returning a genlight object with remaining putative source\n                   populations plus the unknown\nCompleted: gl.assign.pca \n\n\n\n\nAssignment by Mahalanobis Distances\n\n#mahal_result &lt;- gl.assign.mahalanobis(pa.result,unknown=\"AA011731\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Assigning Individuals to Populations</span>"
    ]
  },
  {
    "objectID": "session05.html#scenario",
    "href": "session05.html#scenario",
    "title": "5  Assigning Individuals to Populations",
    "section": "Scenario",
    "text": "Scenario\nThe authorities have recently raided a premises in Brisbane and found a number of reptiles held without permit. One of these is the painted turtle Emydura subglobosa. This species is widespread and common in southern New Guinea, but restricted in Australia to the Jardine River at the tip of Cape York. The Australian population is considered critically endangered under the EPBC Act. The question is, was the animal sourced from Cape York or imported from New Guinea? The specimen was genotyped and run in a service with the other available specimens from localities shown in Figure 1. The datafile is assignment_example1.Rdata. The SpecimenID is “AA046092“. Before you begin the analysis, restrict the populations under consideration to Emydura subglobosa.\n\n\n\n\n\n\nExercise\n\n\n\n Can you confidently decide if the animal was sourced from Cape York or New Guinea using the tools we have provided you via dartR?\n\n\n\nThe data\n\ngl\n# The unknown\nUnknown = \"AA046092\"\n# Preliminaries\npopNames(gl)\n\ngl2 &lt;- gl.keep.pop(gl, pop.list=c(\"EmsubBamuAli\", \"EmsubFlyGuka\", \"EmsubFlyJikw\",\n                                  \"EmsubJardine\", \"EmsubKerema\", \"EmsubMorehead\"))\n\n# Knock yourself out",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Assigning Individuals to Populations</span>"
    ]
  },
  {
    "objectID": "session05.html#further-study",
    "href": "session05.html#further-study",
    "title": "5  Assigning Individuals to Populations",
    "section": "Further Study",
    "text": "Further Study\nTutorial yet to come…\n\nReadings",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Assigning Individuals to Populations</span>"
    ]
  },
  {
    "objectID": "session06.html",
    "href": "session06.html",
    "title": "6  SNP Panel Selection & Simulations for Conservation",
    "section": "",
    "text": "Required packages\nSession Presenters\nlibrary(dartRverse)\nlibrary(knitr)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>SNP Panel Selection & Simulations for Conservation</span>"
    ]
  },
  {
    "objectID": "session06.html#introduction",
    "href": "session06.html#introduction",
    "title": "6  SNP Panel Selection & Simulations for Conservation",
    "section": "Introduction",
    "text": "Introduction\n\n\n\nHow to go from tens of thousands of SNPs across the genome to just 100?\n\n\nThis session will cover the selection of SNP panels for conservation genetics. We will explore how to select SNPs that are informative for population structure, inbreeding, and other conservation-related analyses. The session will include practical exercises using R and the dartRverse packages.\nSNP panels can be used to address either specific questions or to span multiple conservation genetic applications\n\nPopulation assignment\nParentage or relatedness\nIndividual ID\nHybridisation\nAdditional metrics\n\nSex-linked SNPs\nCandidate adaptive markers\nDiagnostic SNPs for population ID\nPhenotypic markers\n\n\nThere are a few requirements, like an existing genome wide SNP dataset and good geographical coverage.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>SNP Panel Selection & Simulations for Conservation</span>"
    ]
  },
  {
    "objectID": "session06.html#selecting-panels",
    "href": "session06.html#selecting-panels",
    "title": "6  SNP Panel Selection & Simulations for Conservation",
    "section": "Selecting panels",
    "text": "Selecting panels\n\n\n\nRedfin blue eye\n\n\nTo select panels we will use an example dataset of a fish species as introduced by the slides. The idea is to select a SNP panel that helps to monitor the species. Key aspects to consider a panel is to think about the following:\n\nWhat is the purpose of the panel? (estimates of Ne, Ho, Fst or all of the above)\nHow many SNPs can you afford to sequence?\n\nOnce you decided on those aspects, you can use the dartRverse package to select a panel of SNPs. The package provides functions to - 1. filter SNPs based on various criteria, mainly for quality - 2. filter SNPs in accordance lab consideration (mainly can we get reliable sequences from the SNPs) - 3. select of the remaining SNPs an informative subsample for the purpose of the panel\n\nLoad data\nThe first two decisions are that we would like to create a SNP panel that is informative for population structure (Fst) and we have resources to develop a panel of 50 SNPs.\nLets load our example data\n\nrfbe &lt;- readRDS(\"./data/rfbe.rds\")\ngl.report.basics(rfbe)\n\nStarting gl.report.basics \n\nSUMMARY STATISTICS\n\nDatatype: SNP \nLoci: 9849 \nIndividuals: 383 \nPopulations: 16 \n\nAverage Read Depth: 28.70085\nValues: 3772167 \n           0    1    2   NA\npercent 65.5 22.0 11.2  1.3\n\nMonomorphic Loci: 2 \nLoci all NA: 0 \nIndividuals all NA: 0 \n\nSample Sizes:\n\n    BHA_A2       E504       E508       E509       E518       NW30       NW70 \n        19         19         20         20         20         20         20 \n      NW72       NW80 PJTub1.2.3   PJTub4.5     PJTub6       SE60       SW10 \n        10         10         64         51         33         20         19 \n      SW20       SW60 \n        18         20 \n\nLoci all NA across individuals by Population\n BHA_A2 E504 E508 E509 E518 NW30 NW70 NW72 NW80 PJTub1.2.3 PJTub4.5 PJTub6 SE60\n      0    0    0    0    0    0    0    0    0          0        0      0    0\n SW10 SW20 SW60\n    0    0    0\n\nIndividuals all NA across loci by Population\n BHA_A2 E504 E508 E509 E518 NW30 NW70 NW72 NW80 PJTub1.2.3 PJTub4.5 PJTub6 SE60\n      0    0    0    0    0    0    0    0    0          0        0      0    0\n SW10 SW20 SW60\n    0    0    0\n\nCompleted: gl.report.basics \n\n\n\n\nFiltering for quality\nSo we have 9849 SNPs (they are prefiltered for quality already). You can check the looking at callrate, rdepth). So we already have high quality SNPs, with a low missing value rate across loci.\nour main aim is to find a panel of 50 SNPs that are informative for population structure (Fst).\nTo be able to calculate Fst reliably we decided to have a threshold of more than 10 individuals per population so we filter the SNPs for a minimum of 11 individuals per population.\n\ntt &lt;- table(pop(rfbe))\npop20 &lt;- names(tt)[tt&gt;10]\n\nrfbe20 &lt;- gl.keep.pop(rfbe, pop.list=pop20)\n\nStarting gl.keep.pop \n  Processing genlight object with SNP data\n  Checking for presence of nominated populations\n  Retaining only populations BHA_A2, E504, E508, E509, E518, NW30, NW70, PJTub1.2.3, PJTub4.5, PJTub6, SE60, SW10, SW20, SW60 \n  Warning: Resultant dataset may contain monomorphic loci\n  Locus metrics not recalculated\nCompleted: gl.keep.pop \n\nkable(table(pop(rfbe20)))\n\n\n\n\nVar1\nFreq\n\n\n\n\nBHA_A2\n19\n\n\nE504\n19\n\n\nE508\n20\n\n\nE509\n20\n\n\nE518\n20\n\n\nNW30\n20\n\n\nNW70\n20\n\n\nPJTub1.2.3\n64\n\n\nPJTub4.5\n51\n\n\nPJTub6\n33\n\n\nSE60\n20\n\n\nSW10\n19\n\n\nSW20\n18\n\n\nSW60\n20\n\n\n\n\n\nBecause we have filtered the data by individual we want to make sure we have not created missing data in any of the populations and we want to filter also finally for minor allele frequency (MAF) using the count option as we want to make sure we have high quality SNPs which are not spurious in terms of aonly occuring in very low frequency.\nYou can use the report function before filtering to test their effect.\n\nrfbe20_1 &lt;- gl.filter.allna(rfbe20, by.pop = T)\n\nStarting gl.filter.allna \n  Identifying and removing loci that are all missing (NA) \n                    in any one population\n  Deleting loci that are all missing (NA) in any one population\n  Warning: no loci listed to delete! Genlight object returned unchanged\nCompleted: gl.filter.allna \n\nrfbe20_2 &lt;- gl.filter.callrate(rfbe20_1, threshold=0.99)\n\nStarting gl.filter.callrate \n  Processing genlight object with SNP data\n  Warning: Data may include monomorphic loci in call rate \n                    calculations for filtering\n  Recalculating Call Rate\n  Removing loci based on Call Rate, threshold = 0.99 \n\n\n\n\n\n\n\n\n\nCompleted: gl.filter.callrate \n\nrfbe20_3 &lt;- gl.filter.maf(rfbe20_2, threshold = 5, by.pop = FALSE)\n\nStarting gl.filter.maf \n  Processing genlight object with SNP data\n  Warning: genlight object contains monomorphic loci\n  Removing loci with MAF &lt; 0.0068870523415978 over all the dataset\n                and recalculating FreqHoms and FreqHets\n\n\n\n\n\n\n\n\n\nCompleted: gl.filter.maf \n\nnLoc(rfbe20_3)\n\n[1] 6815\n\n\nThis should result in high quality SNPs.\nIf you have a reference genome you would like to filter for SNPs that are 100% aligned and of a certain length. For example you want to make sure the sequences you have are at least of a certain length.\n\n\nFilter SNPs with sequences that are less than 30 characters long\n\nindex &lt;- nchar(as.character(rfbe20_3@other$loc.metrics$TrimmedSequence))&gt;29\nrfbe20_4 &lt;- rfbe20_3[, index]\n\nAs we have a reference genome we include another step, manly to filter for SNPs that are aligned very well to the reference genome. This is important and can help if your SNP is towards the beginning of your sequence but you want to design primers that have the SNP more towards the middle of a sequence.\n\n\nblast to find SNPs\n\n#takes a while to run, hence load the pre run data set\n#rfbe20_5 &lt;- gl.blast(rfbe20_4,ref_genome=\"d:/bernd/r/Elise_pansnp/final.genome.scf.fasta\", \n#                     task = \"blastn\", number_of_threads = 10 )\n#saveRDS(rfbe20_5, \"d:/bernd/r/Elise_pansnp/rfbe20_5_blast.rds\")\n\nrfbe20_5 &lt;- readRDS(\"./data/rfbe20_5_blast.rds\")\n\nWe can now filter the SNPs based on the blast results.\n\n#bitscore &gt;=100\nindex &lt;- rfbe20_5@other$loc.metrics$bitscore &gt;= 100\nindex &lt;- ifelse(is.na(index), FALSE, index)\nrfbe20_6 &lt;- rfbe20_5[,index]\n\nDepending on your lab requirements you might want to filter for SNPs that are not too close to close to the beginning of the sequence. As we have a reference genome, that allows us to extend sequences, we do not do that here. In case you are interested we are currently have a semi-developed script that allows to do this, but it is not yet part of the package.\n\n\nSelecting informative SNPs\nWe can now select a subsample of SNPs using several different methods. Depending on the aim of your panel you might want to select SNPs that are informative for population structure (Fst) or inbreeding (Ho). It turns out that the dapc method is a good method to select SNPs that are informative for population structure. The code below uses this method to select 50 SNPs.\n\nrun gl.select.panel\n\n#takes a while to run\npanel &lt;- gl.select.panel(rfbe20_6, method=\"dapc\", nl = 50)\n\nStarting gl.select.panel \n  Processing genlight object with SNP data\n\n\nFound more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics'\n\n\nAlso defined by 'spam'\n\n\nFound more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics'\n\n\nAlso defined by 'spam'\n\n\nStarting gl.keep.loc \n  Processing genlight object with SNP data\n  List of loci to keep has been specified\n  Deleting all but the specified loci\nCompleted: gl.keep.loc \nCompleted: gl.select.panel \n\nnLoc(panel)\n\n[1] 66\n\n\n\n\nrun gl.check.panel\n\noutdapc &lt;- gl.check.panel(panel, rfbe20_6, parameter = \"Fst\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nAs we can see Fst values between populations is nicely reconstructed by selecting only 50 SNPs based on the dapc method. We can compare it to a random selection:\n\npanel_random &lt;- gl.select.panel(rfbe20_6, method=\"random\", nl = 50)\n\nStarting gl.select.panel \n  Processing genlight object with SNP data\nStarting gl.keep.loc \n  Processing genlight object with SNP data\n  List of loci to keep has been specified\n  Deleting all but the specified loci\nCompleted: gl.keep.loc \nCompleted: gl.select.panel \n\noutrandom &lt;- gl.check.panel(panel_random, rfbe20_6, parameter = \"Fst\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nNot as good so it pays off.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>SNP Panel Selection & Simulations for Conservation</span>"
    ]
  },
  {
    "objectID": "session06.html#further-study",
    "href": "session06.html#further-study",
    "title": "6  SNP Panel Selection & Simulations for Conservation",
    "section": "Further Study",
    "text": "Further Study\n\n\n\n\n\n\nExercise\n\n\n\n Now it is time for you to select a SNP panel.\nYou can try different methods and compare them. E.g How good is a random panel, or one based on PIC values.\n\n\n\nReadings",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>SNP Panel Selection & Simulations for Conservation</span>"
    ]
  },
  {
    "objectID": "session07.html",
    "href": "session07.html",
    "title": "7  Simulations for Conservation",
    "section": "",
    "text": "Required packages\nSession Presenters\nlibrary(dartR.base)\nlibrary(dartR.data)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Simulations for Conservation</span>"
    ]
  },
  {
    "objectID": "session07.html#session-content",
    "href": "session07.html#session-content",
    "title": "7  Simulations for Conservation",
    "section": "Session Content",
    "text": "Session Content",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Simulations for Conservation</span>"
    ]
  },
  {
    "objectID": "session07.html#further-study",
    "href": "session07.html#further-study",
    "title": "7  Simulations for Conservation",
    "section": "Further Study",
    "text": "Further Study\n\nReadings",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Simulations for Conservation</span>"
    ]
  },
  {
    "objectID": "session08.html",
    "href": "session08.html",
    "title": "8  Bonus! Sex Linked Markers",
    "section": "",
    "text": "Required packages\nSession Presenters\nlibrary(dartRverse)\nlibrary(dartR.sexlinked)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Bonus! Sex Linked Markers</span>"
    ]
  },
  {
    "objectID": "session08.html#session-overview",
    "href": "session08.html#session-overview",
    "title": "8  Bonus! Sex Linked Markers",
    "section": "Session overview",
    "text": "Session overview\nIn this tutorial you will read about sex-linked loci and do two excercises.\n\nIntroduction\nExercises\n\nExercise 1: Identifying sex-linked loci and using them for sexing\nExercise 2: Observing the effects of not removing sex-linked loci on population genetic analyses\n\n2.1. Differences in PCoA\n2.2. Differences in genetic diversity and fixation indices\n\n\nReferences",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Bonus! Sex Linked Markers</span>"
    ]
  },
  {
    "objectID": "session08.html#introduction",
    "href": "session08.html#introduction",
    "title": "8  Bonus! Sex Linked Markers",
    "section": "Introduction",
    "text": "Introduction\nMany population genetic studies assume autosomal loci. Therefore, it is best practice to exclude sex-linked loci from SNP datasets. Failing to remove these loci can lead to skewed estimates of genetic diversity—such as heterozygosity, fixation indices (like FIS), polymorphism, and allelic richness—especially when the sample has an uneven sex ratio or when there are differences in diversity between sex chromosomes and autosomes. Identifying population structure also improves when sex-linked loci are excluded, since these markers can obscure patterns shaped by evolutionary forces like gene flow, selection, and drift. Similarly, parentage analyses, which rely on autosomal Mendelian inheritance, can be compromised by sex-linked loci, leading to apparent mismatches between true parent-offspring pairs. Therefore, accurately identifying sex-linked loci is essential for reliable genetic analysis and informed management decisions.\nOn the other hand, identifying sex-linked markers can be valuable for determining the sex of individuals in species without sexual dimorphism, and for uncovering sex-specific ecological or evolutionary patterns.\nSex-linked markers are those that are inherited differently between the sexes, usually because they are present in sex chromosomes. In animal species, the two most common chromosomal sex-determination systems are ZW and XY. In the ZW system, typical for birds and some reptiles and insects, females are heterogametic (ZW) and males are homogametic (ZZ). On the contrary, in an XY system, typical for mammals and some insects, males are the heterogametic sex with one X and one Y chromosome, and females are the homogametic sex with two X chromosomes.\nSex-linked markers can be classified into three types (Figure 1):\n\nW-linked or Y-linked loci\nZ-linked or X-linked loci\nGametologs\n\n\n\n\nFigure 1. Sex-linked markers in ZW sex-determination systems",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Bonus! Sex Linked Markers</span>"
    ]
  },
  {
    "objectID": "session08.html#exercise-data",
    "href": "session08.html#exercise-data",
    "title": "8  Bonus! Sex Linked Markers",
    "section": "Exercise Data",
    "text": "Exercise Data\nThe following exercises can be done with the dataset included in the dartR.sexlinked package (that of the beautiful Eastern Yellow Robin, EYR; Figure 2; Robledo-Ruiz et al. 2023) or on your own data!\n\n\n\nFigure 2. Eastern Yellow Robin. Isn’t it a cutie?",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Bonus! Sex Linked Markers</span>"
    ]
  },
  {
    "objectID": "session08.html#exercise-1-identify-sex-linked-loci-and-use-them-for-sexing",
    "href": "session08.html#exercise-1-identify-sex-linked-loci-and-use-them-for-sexing",
    "title": "8  Bonus! Sex Linked Markers",
    "section": "Exercise 1: Identify sex-linked loci and use them for sexing",
    "text": "Exercise 1: Identify sex-linked loci and use them for sexing\n\nImagine you have a genetic dataset in which you have the sexes of most individuals but not all. You are also not sure about the sexes you have recorded for some individuals during fieldwork (human error exists!). Because you know a lot about sex-linked loci, you want to see if you can identify some in order to help you double-check sexes.\n\nLoad data\nStart by calling the dataset and exploring it.\n\ndata(\"EYR\")\nEYR                   # Explore the dataset\n\n ********************\n *** DARTR OBJECT ***\n ********************\n\n ** 782 genotypes,  1,000 SNPs , size: 20.2 Mb\n\n    missing data: 147031 (=18.8 %) scored as NA\n\n ** Genetic data\n   @gen: list of 782 SNPbin\n   @ploidy: ploidy of each individual  (range: 2-2)\n\n ** Additional data\n   @ind.names:  782 individual labels\n   @loc.names:  1000 locus labels\n   @loc.all:  1000 allele labels\n   @position: integer storing positions of the SNPs [within 69 base sequence]\n   @pop: population of each individual (group size range: 52-421)\n   @other: a list containing: loc.metrics, ind.metrics, loc.metrics.flags, verbose, history \n    @other$ind.metrics: id, pop, sex, Mito, service, plate_location \n    @other$loc.metrics: AlleleID, CloneID, AlleleSequence, TrimmedSequence, Chrom_Yellow_robin_HiC_v2, ChromPos_Yellow_robin_HiC_v2, AlnCnt_Yellow_robin_HiC_v2, AlnEvalue_Yellow_robin_HiC_v2, SNP, SnpPosition, CallRate, OneRatioRef, OneRatioSnp, FreqHomRef, FreqHomSnp, FreqHets, PICRef, PICSnp, AvgPIC, AvgCountRef, AvgCountSnp, RepAvg, clone, uid, rdepth, maf \n   @other$latlon[g]: no coordinates attached\n\nEYR@n.loc             # Number of SNPs\n\n[1] 1000\n\nlength(EYR@ind.names) # Number of individuals\n\n[1] 782\n\n\n\n\nSearch for sex-linked loci\nThe function gl.report.sexlinked identifies sex-linked and autosomal loci present in a SNP dataset (genlight object) using individuals with known sex. It identifies five types of loci: w-linked or y-linked, sex-biased, z-linked or x-linked, gametologous and autosomal.\n\n\n\n\n\n\nTip\n\n\n\nThe genlight object must contain in gl@other$ind.metrics a column named id, and a column named sex in which individuals with known-sex are assigned M for male, or F for female. The function ignores individuals that are assigned anything else or nothing at all (unknown-sex).\n\n\nCheck that ind.metrics has the necessary columns:\n\nknitr::kable(EYR@other$ind.metrics[1:10,])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nid\npop\nsex\nMito\nservice\nplate_location\n\n\n\n\n024-96401\n024-96401\nCrusoe\nM\nB\nDYro17-3039\n2-D9\n\n\n024-96401b\n024-96401b\nCrusoe\nM\nB\nDYro21-6107\n3-D3\n\n\n024-96402\n024-96402\nCrusoe\nF\nA\nDYro17-3039\n2-C9\n\n\n024-96403\n024-96403\nCrusoe\nM\nB\nDYro17-3039\n2-B9\n\n\n024-96404\n024-96404\nCrusoe\nM\nA\nDYro17-3039\n2-A9\n\n\n024-96405\n024-96405\nMuckleford\nM\nA\nDYro17-3039\n2-D6\n\n\n024-96406\n024-96406\nCrusoe\nF\nA\nDYro17-3039\n2-H8\n\n\n024-96407\n024-96407\nCrusoe\nF\nA\nDYro17-3039\n2-G8\n\n\n024-96408\n024-96408\nCrusoe\nM\nA\nDYro17-3039\n2-F8\n\n\n024-96410\n024-96410\nMuckleford\nM\nA\nDYro17-3039\n1-E9\n\n\n\n\n\nonly showing first 10 rows\nRun the function to identify sex-linked loci in the EYR genlight object:\n\nout &lt;- gl.report.sexlinked(EYR, system = \"zw\")\n\nStarting gl.report.sexlinked \n  Processing genlight object with SNP data\n\n\nDetected 352 females and 429 males.\n\n\nStarting phase 1. May take a while...\n\n\nBuilding call rate plot.\n\n\nDone building call rate plot.\n\n\nStarting phase 2. May take a while...\n\n\nBuilding heterozygosity plot.\n\n\nDone building heterozygosity plot.\n\n\n**FINISHED** Total of analyzed loci: 1000.\nFound 150 sex-linked loci:\n   16 W-linked loci (yellow)\n   82 sex-biased loci (blue)\n   32 Z-linked loci (orange)\n   20 gametologs (green).\nAnd 850 autosomal loci (grey).\n\n\n\n\n\n\n\n\n\nCompleted: gl.report.sexlinked \n\n\n\n\n\n\n\n\nQuestion time\n\n\n\nQuestion: How many males and females does the dataset contain?\nQuestion: How many sex-linked loci were found?\nQuestion: Why are there two plots?\nQuestion: What does each point in the plots represent?\nQuestion: What do the colours in the plots mean? Look at Figure 1 for a hint. What about the blue dots?\n\n\n\n\nSexing individuals with unknown sex\nThe dartR.sexlinked package has more functions that can be useful when a dataset has some missing sex data.\n\n\n\n\n\n\nQuestion time\n\n\n\nQuestion: How many individuals does the EYR genlight object contain?\nQuestion: How many males and females were detected by function gl.report.sexlinked? Are there individuals with unknown sex?\n\n\nFind the id of the individual that is not sexed:\n\nEYR@other$ind.metrics[!(EYR@other$ind.metrics$sex %in% c(\"M\", \"F\")), ]\n\n                 id        pop sex Mito     service plate_location\n024-96417 024-96417 Muckleford        B DYro17-3039           2-E5\n\n\nUse the sex-linked loci you have identified to infer the sex of that individual by running function infer.sex.\nThis function uses the output of function gl.keep.sexlinked to infer the sex of all individuals in the dataset. It uses 3 types of sex-linked loci (W-/Y-linked, Z-/X-linked, and gametologs), assigns a preliminary genetic sex for each type of sex-linked loci available, and outputs an agreed sex:\n\nEYR_sexLinked &lt;- gl.keep.sexlinked(EYR, system = \"zw\") # save sex-linked loci\n\nStarting gl.keep.sexlinked \n  Processing genlight object with SNP data\n\n\nDetected 352 females and 429 males.\n\n\nStarting phase 1. May take a while...\n\n\nBuilding call rate plots.\n\n\nStarting phase 2. May take a while...\n\n\nBuilding heterozygosity plots.\n\n\nDone building heterozygosity plots.\n\n\n**FINISHED** Total of analyzed loci: 1000.\nKept 150 sex-linked loci:\n   16 W-linked loci (yellow)\n   82 sex-biased loci (blue)\n   32 Z-linked loci (orange)\n   20 gametologs (green).\nAnd removed 850 autosomal loci (grey).\n\n\n\n\n\n\n\n\n\nCompleted: gl.keep.sexlinked \n\ninferred.sexes &lt;- gl.infer.sex(gl_sexlinked = EYR_sexLinked, \n                               system = \"zw\", seed = 124) # use sex-linked loci\n\n***FINISHED***\n\n\nThe function outputs a table with assigned sexes based on sex-linked loci:\n\nhead(inferred.sexes, 10) \n\n                   id w.linked.sex #called #missing z.linked.sex #Het.z #Hom.z\n024-96401   024-96401            M       0       16            M      7     25\n024-96401b 024-96401b            M       0       16            M      9     21\n024-96402   024-96402            F      15        1            F      0     32\n024-96403   024-96403            M       1       15            M     11     21\n024-96404   024-96404            M       0       16            M     12     20\n024-96405   024-96405            M       0       16            M     11     21\n024-96406   024-96406            F      15        1            F      0     30\n024-96407   024-96407            F      15        1            F      0     28\n024-96408   024-96408            M       0       16            F      4     28\n024-96410   024-96410            M       0       16            M      7     25\n           gametolog.sex #Het.g #Hom.g agreed.sex\n024-96401              M      0      5          M\n024-96401b             M      0      5          M\n024-96402              F      5      0          F\n024-96403              M      0      5          M\n024-96404              M      0      5          M\n024-96405              M      0      5          M\n024-96406              F      5      0          F\n024-96407              F      5      0          F\n024-96408              M      0      5         *M\n024-96410              M      0      5          M\n\n\nExamine the output table. There are four assigned sexes per individual: one according to w-linked loci, one according to z-linked loci, one according to gametologs, and one final agreed sex.\n\n\n\n\n\n\nQuestion time\n\n\n\nQuestion: What agreed sex was assigned to the individual with missing sex?\nQuestion: Can you find individuals for which the agreed sex is uncertain (i.e., has an asterisk ‘*’)? How would you decide which is their correct sex?",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Bonus! Sex Linked Markers</span>"
    ]
  },
  {
    "objectID": "session08.html#exercise-2-observe-the-effects-of-not-removing-sex-linked-loci-on-population-genetic-analyses",
    "href": "session08.html#exercise-2-observe-the-effects-of-not-removing-sex-linked-loci-on-population-genetic-analyses",
    "title": "8  Bonus! Sex Linked Markers",
    "section": "Exercise 2: Observe the effects of not removing sex-linked loci on population genetic analyses",
    "text": "Exercise 2: Observe the effects of not removing sex-linked loci on population genetic analyses\n\nImagine you are analyzing the genetic data of a species and you want to look at its population structure and genetic diversity. You start by filtering your beautiful set of SNPs. Because you are a rigorous scientist, you want to test whether using function gl.drop.sexlinked to properly filter out sex-linked loci changes the results of the populations analyses. So you: (1) process your SNP dataset by applying only standard filters (from here on “sloppy filtering”) and run analyses, and (2) process the dataset by filtering out sex-linked loci first, applying standard filters second (from here on “correct filtering”), and then run analyses.\nUse the EYR dataset or your own data to report:\n\nDo you see any changes in a population structure analysis (PCoA) when you filter out sex-linked markers versus when you do not?\nDo you see any differences in genetic diversity and fixation indices when you filter out sex-linked markers versus when you do not?\n\n\nStandard filtering\nFiltering SNPs only with standard filters (“sloppy filtering”)\nLet’s apply only standard filters (read depth, call rate, and MAC):\n\n# Filter for read depth\ngl.report.rdepth(EYR)\n\nStarting gl.report.rdepth \n  Processing genlight object with SNP data\n  Reporting Read Depth by Locus\n  No. of loci = 1000 \n  No. of individuals = 782 \n    Minimum      :  2.6 \n    1st quartile :  4.3 \n    Median       :  5.6 \n    Mean         :  5.9649 \n    3r quartile  :  7.325 \n    Maximum      :  13.2 \n    Missing Rate Overall:  0.19 \n\n\n\n\n\n\n\n\n\n   Quantile Threshold Retained Percent Filtered Percent\n1      100%      13.2        1     0.1      999    99.9\n2       95%       9.9       51     5.1      949    94.9\n3       90%       9.0      105    10.5      895    89.5\n4       85%       8.3      151    15.1      849    84.9\n5       80%       7.8      208    20.8      792    79.2\n6       75%       7.3      258    25.8      742    74.2\n7       70%       6.9      304    30.4      696    69.6\n8       65%       6.5      354    35.4      646    64.6\n9       60%       6.2      404    40.4      596    59.6\n10      55%       5.9      451    45.1      549    54.9\n11      50%       5.6      504    50.4      496    49.6\n12      45%       5.3      563    56.3      437    43.7\n13      40%       5.1      602    60.2      398    39.8\n14      35%       4.8      659    65.9      341    34.1\n15      30%       4.6      702    70.2      298    29.8\n16      25%       4.3      752    75.2      248    24.8\n17      20%       4.0      823    82.3      177    17.7\n18      15%       3.9      852    85.2      148    14.8\n19      10%       3.6      906    90.6       94     9.4\n20       5%       3.3      956    95.6       44     4.4\n21       0%       2.6     1000   100.0        0     0.0\nCompleted: gl.report.rdepth \n\nEYR.sloppy &lt;- gl.filter.rdepth(EYR, lower = 3, upper = 11, verbose = 0)\n\n\n\n\n\n\n\n# Filter for loci call rate\ngl.report.callrate(EYR.sloppy, method = \"loc\")\n\nStarting gl.report.callrate \n  Processing genlight object with SNP data\n  Reporting Call Rate by Locus\n  No. of loci = 958 \n  No. of individuals = 782 \n    Minimum      :  0.20844 \n    1st quartile :  0.7202688 \n    Median       :  0.895141 \n    Mean         :  0.8131871 \n    3r quartile  :  0.950128 \n    Maximum      :  0.988491 \n    Missing Rate Overall:  0.1868 \n\n   Quantile Threshold Retained Percent Filtered Percent\n1      100%  0.988491        1     0.1      957    99.9\n2       95%  0.979540       52     5.4      906    94.6\n3       90%  0.973146      104    10.9      854    89.1\n4       85%  0.965473      145    15.1      813    84.9\n5       80%  0.956522      197    20.6      761    79.4\n6       75%  0.950128      247    25.8      711    74.2\n7       70%  0.943734      291    30.4      667    69.6\n8       65%  0.932225      339    35.4      619    64.6\n9       60%  0.921995      386    40.3      572    59.7\n10      55%  0.910486      434    45.3      524    54.7\n11      50%  0.895141      482    50.3      476    49.7\n12      45%  0.872123      527    55.0      431    45.0\n13      40%  0.847826      575    60.0      383    40.0\n14      35%  0.819693      623    65.0      335    35.0\n15      30%  0.780051      671    70.0      287    30.0\n16      25%  0.719949      719    75.1      239    24.9\n17      20%  0.662404      768    80.2      190    19.8\n18      15%  0.594629      815    85.1      143    14.9\n19      10%  0.523018      863    90.1       95     9.9\n20       5%  0.402813      911    95.1       47     4.9\n21       0%  0.208440      958   100.0        0     0.0\n\n\n\n\n\n\n\n\n\nCompleted: gl.report.callrate \n\nEYR.sloppy &lt;- gl.filter.callrate(EYR.sloppy, method = \"loc\",  threshold = 0.75, verbose = 0, recalc = TRUE)\n\n# Filter for individual call rate\ngl.report.callrate(EYR.sloppy, method = \"ind\")\n\nStarting gl.report.callrate \n  Processing genlight object with SNP data\n\n  Reporting Call Rate by Individual\n  No. of loci = 703 \n  No. of individuals = 782 \n    Minimum      :  0.03556188 \n    1st quartile :  0.9174964 \n    Median       :  0.9416785 \n    Mean         :  0.9108097 \n    3r quartile  :  0.9573257 \n    Maximum      :  0.9829303 \n    Missing Rate Overall:  0.0892 \n\nListing 4 populations and their average CallRates\n  Monitor again after filtering\n  Population CallRate   N\n1     Crusoe   0.9027 238\n2 Muckleford   0.9073 421\n3      Timor   0.9402  52\n4     Wombat   0.9371  71\n\nListing 20 individuals with the lowest CallRates\n  Use this list to see which individuals will be lost on filtering by individual\n  Set ind.to.list parameter to see more individuals\n   Individual Population   CallRate\n1    M18.29.1 Muckleford 0.03556188\n2    M18.18.1 Muckleford 0.03982930\n3    M18.47.2 Muckleford 0.06970128\n4    C18.16.1     Crusoe 0.07112376\n5   027-34168     Crusoe 0.07681366\n6    C18.15.2     Crusoe 0.08534851\n7    C18.21.2     Crusoe 0.08677098\n8    M18.47.3 Muckleford 0.14224751\n9    M18.35.2 Muckleford 0.17211949\n10   M18.20.3 Muckleford 0.24039829\n11   M20.70.2 Muckleford 0.39687055\n12   C18.28.1     Crusoe 0.39971550\n13   C18.17.2     Crusoe 0.46088193\n14  027-34065 Muckleford 0.50640114\n15   C18.14.1     Crusoe 0.50640114\n16   M20.70.3 Muckleford 0.50782361\n17  M20.110.1 Muckleford 0.52347084\n18   M19.12.1 Muckleford 0.53342817\n19    M19.8.1 Muckleford 0.54907539\n20   M20.64.3 Muckleford 0.56045519\n\n)\n\n\n\n\n\n\n\n\n\nCompleted: gl.report.callrate \n\nEYR.sloppy &lt;- gl.filter.callrate(EYR.sloppy, method = \"ind\", threshold = 0.65, verbose = 0, recalc = TRUE)\n# Filter for MAC (= 3)\ngl.report.maf(EYR.sloppy)\n\nStarting gl.report.maf \n  Processing genlight object with SNP data\nStarting gl.report.maf \n\n  Reporting Minor Allele Frequency (MAF) by Locus for population Crusoe \n  No. of loci = 670 \n  No. of individuals = 231 \n    Minimum      :  0.002164502 \n    1st quantile :  0.06484488 \n    Median       :  0.1582011 \n    Mean         :  0.1793518 \n    3r quantile  :  0.2674593 \n    Maximum      :  0.4975369 \n    Missing Rate Overall:  0.08 \n\n  Reporting Minor Allele Frequency (MAF) by Locus for population Muckleford \n  No. of loci = 683 \n  No. of individuals = 401 \n    Minimum      :  0.001253133 \n    1st quantile :  0.05874834 \n    Median       :  0.1403509 \n    Mean         :  0.1729484 \n    3r quantile  :  0.2617141 \n    Maximum      :  0.4985251 \n    Missing Rate Overall:  0.07 \n\n  Reporting Minor Allele Frequency (MAF) by Locus for population Timor \n  No. of loci = 589 \n  No. of individuals = 52 \n    Minimum      :  0.009615385 \n    1st quantile :  0.06730769 \n    Median       :  0.1666667 \n    Mean         :  0.191416 \n    3r quantile  :  0.287234 \n    Maximum      :  0.5 \n    Missing Rate Overall:  0.06 \n\n  Reporting Minor Allele Frequency (MAF) by Locus for population Wombat \n  No. of loci = 627 \n  No. of individuals = 71 \n    Minimum      :  0.007042254 \n    1st quantile :  0.063833 \n    Median       :  0.1449275 \n    Mean         :  0.1746704 \n    3r quantile  :  0.2541771 \n    Maximum      :  0.5 \n    Missing Rate Overall:  0.06 \n\n  Reporting Minor Allele Frequency (MAF) by Locus OVERALL\n  No. of loci = 703 \n  No. of individuals = 755 \n    Minimum      :  0.000665779 \n    1st quantile :  0.06181458 \n    Median       :  0.1442801 \n    Mean         :  0.1711878 \n    3r quantile  :  0.2544219 \n    Maximum      :  0.5 \n    Missing Rate Overall:  0.07 \n\n\n\n\n\n\n\n\n\n   Quantile   Threshold Retained Percent Filtered Percent\n1      100% 0.500000000        1     0.1      699    99.9\n2       95% 0.443105756       36     5.1      664    94.9\n3       90% 0.381240545       71    10.1      629    89.9\n4       85% 0.334558824      105    15.0      595    85.0\n5       80% 0.287348587      141    20.1      559    79.9\n6       75% 0.253681392      176    25.1      524    74.9\n7       70% 0.227857143      210    30.0      490    70.0\n8       65% 0.200947226      246    35.1      454    64.9\n9       60% 0.177905308      280    40.0      420    60.0\n10      55% 0.159519726      315    45.0      385    55.0\n11      50% 0.144189383      351    50.1      349    49.9\n12      45% 0.121014493      386    55.1      314    44.9\n13      40% 0.102439024      421    60.1      279    39.9\n14      35% 0.087191358      455    65.0      245    35.0\n15      30% 0.075549451      490    70.0      210    30.0\n16      25% 0.061752988      526    75.1      174    24.9\n17      20% 0.048679868      561    80.1      139    19.9\n18      15% 0.034609720      595    85.0      105    15.0\n19      10% 0.022666667      631    90.1       69     9.9\n20       5% 0.005347594      666    95.1       34     4.9\n21       0% 0.000665779      700   100.0        0     0.0\nCompleted: gl.report.maf \n\nEYR.sloppy &lt;- gl.filter.maf(EYR.sloppy, threshold = 3, verbose = 0, recalc = TRUE)\n\n\n\nSex-linked filtering & standard Filtering\nFiltering SNPs for sex-linked loci and then with standard filters (“correct filtering”)\nLet’s remove sex-linked markers and then apply standard filters:\n\n# Filter for sex-linked loci\nEYR.correct &lt;- gl.drop.sexlinked(EYR, system = \"zw\")  \n\nStarting gl.drop.sexlinked \n  Processing genlight object with SNP data\n\n\n\n\n\n\n\n\n\nCompleted: gl.drop.sexlinked \n\n# Filter for read depth\nEYR.correct &lt;- gl.filter.rdepth(EYR.correct, lower = 3, upper = 11, verbose = 0)\n\n\n\n\n\n\n\n# Filter for loci call rate\ngl.report.callrate(EYR.correct, method = \"loc\")\n\nStarting gl.report.callrate \n  Processing genlight object with SNP data\n  Reporting Call Rate by Locus\n  No. of loci = 811 \n  No. of individuals = 782 \n    Minimum      :  0.20844 \n    1st quartile :  0.7436065 \n    Median       :  0.900256 \n    Mean         :  0.8192658 \n    3r quartile  :  0.951407 \n    Maximum      :  0.988491 \n    Missing Rate Overall:  0.1807 \n\n   Quantile Threshold Retained Percent Filtered Percent\n1      100%  0.988491        1     0.1      810    99.9\n2       95%  0.979540       46     5.7      765    94.3\n3       90%  0.974425       84    10.4      727    89.6\n4       85%  0.966752      130    16.0      681    84.0\n5       80%  0.957801      165    20.3      646    79.7\n6       75%  0.951407      208    25.6      603    74.4\n7       70%  0.945013      249    30.7      562    69.3\n8       65%  0.936061      289    35.6      522    64.4\n9       60%  0.924552      331    40.8      480    59.2\n10      55%  0.914322      368    45.4      443    54.6\n11      50%  0.900256      408    50.3      403    49.7\n12      45%  0.878517      449    55.4      362    44.6\n13      40%  0.850384      487    60.0      324    40.0\n14      35%  0.823529      531    65.5      280    34.5\n15      30%  0.789003      571    70.4      240    29.6\n16      25%  0.742967      609    75.1      202    24.9\n17      20%  0.672634      649    80.0      162    20.0\n18      15%  0.613811      691    85.2      120    14.8\n19      10%  0.539642      730    90.0       81    10.0\n20       5%  0.402813      771    95.1       40     4.9\n21       0%  0.208440      811   100.0        0     0.0\n\n\n\n\n\n\n\n\n\nCompleted: gl.report.callrate \n\nEYR.correct &lt;- dartR.base::gl.filter.callrate(EYR.correct, method = \"loc\",  threshold = 0.75, verbose = 0, recalc = TRUE)\n\n# Filter for individual call rate\ngl.report.callrate(EYR.correct, method = \"ind\")\n\nStarting gl.report.callrate \n  Processing genlight object with SNP data\n\n  Reporting Call Rate by Individual\n  No. of loci = 605 \n  No. of individuals = 782 \n    Minimum      :  0.03801653 \n    1st quartile :  0.9173554 \n    Median       :  0.9438017 \n    Mean         :  0.9120479 \n    3r quartile  :  0.9586777 \n    Maximum      :  0.9818182 \n    Missing Rate Overall:  0.088 \n\nListing 4 populations and their average CallRates\n  Monitor again after filtering\n  Population CallRate   N\n1     Crusoe   0.9037 238\n2 Muckleford   0.9090 421\n3      Timor   0.9418  52\n4     Wombat   0.9365  71\n\nListing 20 individuals with the lowest CallRates\n  Use this list to see which individuals will be lost on filtering by individual\n  Set ind.to.list parameter to see more individuals\n   Individual Population   CallRate\n1    M18.29.1 Muckleford 0.03801653\n2    M18.18.1 Muckleford 0.04462810\n3    M18.47.2 Muckleford 0.06776860\n4    C18.16.1     Crusoe 0.07438017\n5   027-34168     Crusoe 0.08760331\n6    C18.15.2     Crusoe 0.08760331\n7    C18.21.2     Crusoe 0.08760331\n8    M18.47.3 Muckleford 0.13719008\n9    M18.35.2 Muckleford 0.18016529\n10   M18.20.3 Muckleford 0.24132231\n11   C18.28.1     Crusoe 0.41487603\n12   M20.70.2 Muckleford 0.42644628\n13   C18.17.2     Crusoe 0.44628099\n14  027-34065 Muckleford 0.49586777\n15   C18.14.1     Crusoe 0.49752066\n16  M20.110.1 Muckleford 0.53057851\n17   M20.70.3 Muckleford 0.53553719\n18   M19.12.1 Muckleford 0.54380165\n19    M19.8.1 Muckleford 0.56694215\n20   M19.33.2 Muckleford 0.57851240\n\n)\n\n\n\n\n\n\n\n\n\nCompleted: gl.report.callrate \n\nEYR.correct &lt;- gl.filter.callrate(EYR.correct, method = \"ind\", threshold = 0.65, verbose = 0, recalc = TRUE)\n# Filter for MAC (= 3)\ngl.report.maf(EYR.correct)\n\nStarting gl.report.maf \n  Processing genlight object with SNP data\nStarting gl.report.maf \n\n  Reporting Minor Allele Frequency (MAF) by Locus for population Crusoe \n  No. of loci = 573 \n  No. of individuals = 231 \n    Minimum      :  0.002164502 \n    1st quantile :  0.06 \n    Median       :  0.1488372 \n    Mean         :  0.1741175 \n    3r quantile  :  0.2645503 \n    Maximum      :  0.4975369 \n    Missing Rate Overall:  0.08 \n\n  Reporting Minor Allele Frequency (MAF) by Locus for population Muckleford \n  No. of loci = 585 \n  No. of individuals = 401 \n    Minimum      :  0.001253133 \n    1st quantile :  0.05498721 \n    Median       :  0.1289855 \n    Mean         :  0.1639923 \n    3r quantile  :  0.247449 \n    Maximum      :  0.4985251 \n    Missing Rate Overall:  0.07 \n\n  Reporting Minor Allele Frequency (MAF) by Locus for population Timor \n  No. of loci = 504 \n  No. of individuals = 52 \n    Minimum      :  0.009615385 \n    1st quantile :  0.06829751 \n    Median       :  0.1634615 \n    Mean         :  0.1898642 \n    3r quantile  :  0.2860942 \n    Maximum      :  0.5 \n    Missing Rate Overall:  0.06 \n\n  Reporting Minor Allele Frequency (MAF) by Locus for population Wombat \n  No. of loci = 536 \n  No. of individuals = 71 \n    Minimum      :  0.007042254 \n    1st quantile :  0.06246058 \n    Median       :  0.1380348 \n    Mean         :  0.1706064 \n    3r quantile  :  0.2509058 \n    Maximum      :  0.5 \n    Missing Rate Overall:  0.06 \n\n  Reporting Minor Allele Frequency (MAF) by Locus OVERALL\n  No. of loci = 605 \n  No. of individuals = 755 \n    Minimum      :  0.000665779 \n    1st quantile :  0.05816563 \n    Median       :  0.1325038 \n    Mean         :  0.1628174 \n    3r quantile  :  0.2433774 \n    Maximum      :  0.5 \n    Missing Rate Overall:  0.07 \n\n\n\n\n\n\n\n\n\n   Quantile   Threshold Retained Percent Filtered Percent\n1      100% 0.500000000        1     0.2      601    99.8\n2       95% 0.436416185       31     5.1      571    94.9\n3       90% 0.371359223       61    10.1      541    89.9\n4       85% 0.320707071       91    15.1      511    84.9\n5       80% 0.273415978      121    20.1      481    79.9\n6       75% 0.243550835      151    25.1      451    74.9\n7       70% 0.212715856      181    30.1      421    69.9\n8       65% 0.190108192      211    35.0      391    65.0\n9       60% 0.171383648      241    40.0      361    60.0\n10      55% 0.149933066      271    45.0      331    55.0\n11      50% 0.131954351      302    50.2      300    49.8\n12      45% 0.109164420      332    55.1      270    44.9\n13      40% 0.094953519      362    60.1      240    39.9\n14      35% 0.080645161      392    65.1      210    34.9\n15      30% 0.070951586      422    70.1      180    29.9\n16      25% 0.058022923      452    75.1      150    24.9\n17      20% 0.044692737      482    80.1      120    19.9\n18      15% 0.030487805      512    85.0       90    15.0\n19      10% 0.019410977      542    90.0       60    10.0\n20       5% 0.004761905      572    95.0       30     5.0\n21       0% 0.000665779      602   100.0        0     0.0\nCompleted: gl.report.maf \n\nEYR.correct &lt;- dartR.base::gl.filter.maf(EYR.correct, threshold = 3, verbose = 0, recalc = TRUE)\n\n\n\nFiltering differences in PCoA\nDifferences in PCoA between “sloppily filtered” dataset (only standard filters), vs “correctly filtered” dataset (gl.drop.sexlinked and standard filters)\n\n# Sloppy\nPCA.sloppy &lt;- gl.pcoa(EYR.sloppy, verbose = 0)\n\n\n\n\n\n\n\npcplot_sloppy &lt;- gl.pcoa.plot(PCA.sloppy, EYR.sloppy, xaxis = 1, yaxis = 2)\n\n\n\n\n\n\n\n# Correct\nPCA.correct &lt;- gl.pcoa(EYR.correct, verbose = 0)\n\n\n\n\n\n\n\npcplot_correct &lt;- gl.pcoa.plot(PCA.correct, EYR.correct, xaxis = 1, yaxis = 2)\n\n\n\n\n\n\n\n\nStarting gl.colors \nSelected color type 2 \nCompleted: gl.colors \nStarting gl.pcoa.plot \n  Processing an ordination file (glPca)\n  Processing genlight object with SNP data\n  Plotting populations in a space defined by the SNPs\n  Preparing plot .... please wait\nCompleted: gl.pcoa.plot \nStarting gl.colors \nSelected color type 2 \nCompleted: gl.colors \nStarting gl.pcoa.plot \n  Processing an ordination file (glPca)\n  Processing genlight object with SNP data\n  Plotting populations in a space defined by the SNPs\n  Preparing plot .... please wait\nCompleted: gl.pcoa.plot \n\n\n\n\n\n\n\n\nQuestion time\n\n\n\nQuestion: Do the PCoA plots look different? Why?\n\n\n\n\nFiltering differences in genetic diversity and fixation indices\nDifferences in genetic diversity and fixation indices between “sloppily filtered” dataset vs “correctly filtered” dataset\nLet’s check some basic stats:\n\nbasic.sloppy  &lt;- utils.basic.stats(EYR.sloppy)\nbasic.correct &lt;- utils.basic.stats(EYR.correct)\nbasic.sloppy$overall\n\n     Ho      Hs      Ht     Dst     Htp    Dstp     Fst    Fstp     Fis    Dest \n 0.1638  0.2442  0.2537  0.0095  0.2568  0.0126  0.0373  0.0491  0.3294  0.0167 \nGst_max   Gst_H \n 0.7061  0.0696 \n\nbasic.correct$overall\n\n     Ho      Hs      Ht     Dst     Htp    Dstp     Fst    Fstp     Fis    Dest \n 0.1631  0.2379  0.2459  0.0080  0.2485  0.0107  0.0325  0.0429  0.3144  0.0140 \nGst_max   Gst_H \n 0.7135  0.0601 \n\n\n\n\n\n\n\n\nQuestion time\n\n\n\nQuestion: Why are observed Heterozygosity (Ho) and expected Heterozygosity (He) slightly higher for the “sloppyly filtered” dataset?\nHint: Look at the second plot produced by function gl.report.sexlinked.\n\n\nCalculate FST fixation indices between populations:\n\ngl.fst.pop(EYR.sloppy, verbose = 0)\n\n               Crusoe Muckleford      Timor Wombat\nCrusoe             NA         NA         NA     NA\nMuckleford 0.03234709         NA         NA     NA\nTimor      0.04072932 0.05451318         NA     NA\nWombat     0.05484958 0.02376727 0.08401313     NA\n\ngl.fst.pop(EYR.correct, verbose = 0)\n\n               Crusoe Muckleford      Timor Wombat\nCrusoe             NA         NA         NA     NA\nMuckleford 0.02795813         NA         NA     NA\nTimor      0.03987369 0.04810759         NA     NA\nWombat     0.04446378 0.02270137 0.07114017     NA\n\n\n\n\n\n\n\n\nQuestion time\n\n\n\nQuestion: Which dataset has higher FST estimates overall?",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Bonus! Sex Linked Markers</span>"
    ]
  },
  {
    "objectID": "session08.html#further-study",
    "href": "session08.html#further-study",
    "title": "8  Bonus! Sex Linked Markers",
    "section": "Further Study",
    "text": "Further Study\n\nReadings\nRobledo-Ruiz et al. (2023)\n\n\n\n\nRobledo-Ruiz, Diana A., Lana Austin, J. Nevil Amos, Jesús Castrejón-Figueroa, Daniel K. P. Harley, Michael J. L. Magrath, Paul Sunnucks, and Alexandra Pavlova. 2023. “Easy-to-Use R Functions to Separate Reduced-Representation Genomic Datasets into Sex-Linked and Autosomal Loci, and Conduct Sex Assignment.” Molecular Ecology Resources 0 (n/a). https://doi.org/10.1111/1755-0998.13844.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Bonus! Sex Linked Markers</span>"
    ]
  },
  {
    "objectID": "break.html",
    "href": "break.html",
    "title": "__________",
    "section": "",
    "text": "Everything beyond this point is for added learning, we hope you have fun exploring all the amazing things the dartRverse has to offer.",
    "crumbs": [
      "\\__________"
    ]
  },
  {
    "objectID": "tutorials.html",
    "href": "tutorials.html",
    "title": "dartR Tutorials",
    "section": "",
    "text": "Prerequistes",
    "crumbs": [
      "dartR Tutorials"
    ]
  },
  {
    "objectID": "tutorials.html#prerequistes",
    "href": "tutorials.html#prerequistes",
    "title": "dartR Tutorials",
    "section": "",
    "text": "RStudio Refresher\nUnable to display PDF file. Download instead.\n\n\ndartR Installation\nUnable to display PDF file. Download instead.",
    "crumbs": [
      "dartR Tutorials"
    ]
  },
  {
    "objectID": "tutorials.html#fundamentals",
    "href": "tutorials.html#fundamentals",
    "title": "dartR Tutorials",
    "section": "Fundamentals",
    "text": "Fundamentals\n\ndartR Data Structure and Input\nUnable to display PDF file. Download instead.\n\n\ndartR Data Manipulation\nUnable to display PDF file. Download instead.\n\n\ndartR Basic Filtering\nUnable to display PDF file. Download instead.",
    "crumbs": [
      "dartR Tutorials"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Gruber, Bernd, Peter J. Unmack, Oliver F. Berry, and Arthur Georges.\n2018. “DARTR : An R Package\nto Facilitate Analysis of SNP Data Generated from Reduced\nRepresentation Genome Sequencing.” Molecular Ecology\nResources 18 (3): 691–99. https://doi.org/10.1111/1755-0998.12745.\n\n\nJombart, T., and I. Ahmed. 2011. “Adegenet 1.3-1: New Tools for\nthe Analysis of Genome-Wide SNP Data.” Bioinformatics.\nhttps://doi.org/10.1093/bioinformatics/btr521.\n\n\nMijangos, Jose Luis, Bernd Gruber, Oliver Berry, Carlo Pacioni, and\nArthur Georges. 2022. “dartR V2:\nAn Accessible Genetic Analysis Platform for Conservation,\nEcology and Agriculture.” Methods in Ecology and\nEvolution 13 (10): 2150–58. https://doi.org/10.1111/2041-210X.13918.\n\n\nRobledo-Ruiz, Diana A., Lana Austin, J. Nevil Amos, Jesús\nCastrejón-Figueroa, Daniel K. P. Harley, Michael J. L. Magrath, Paul\nSunnucks, and Alexandra Pavlova. 2023. “Easy-to-Use R\nFunctions to Separate Reduced-Representation Genomic Datasets into\nSex-Linked and Autosomal Loci, and Conduct Sex Assignment.”\nMolecular Ecology Resources 0 (n/a). https://doi.org/10.1111/1755-0998.13844.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "feedback.html",
    "href": "feedback.html",
    "title": "Feedback",
    "section": "",
    "text": "Please provide any questions, suggestions, or praises in the message box below and then hit submit.\n\nName: \nEmail: \nMessage:",
    "crumbs": [
      "Feedback"
    ]
  }
]